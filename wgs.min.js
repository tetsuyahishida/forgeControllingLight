/*!
 * @license
 * Copyright 2016 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 */
var WGS=function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={exports:{},id:d,loaded:!1};return a[d].call(e.exports,e,e.exports,b),e.loaded=!0,e.exports}var c={};return b.m=a,b.c=c,b.p="",b(0)}([function(a,b,c){var d,e,f;(function(g){"use strict";var h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a};!function(g,i){"object"===h(b)&&void 0!==a?i(b,c(1)):(e=[b,c(1)],d=i,void 0!==(f="function"==typeof d?d.apply(b,e):d)&&(a.exports=f))}(0,function(a,b){function c(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)}function d(){return"undefined"!=typeof window&&null!==window?window:"undefined"!=typeof self&&null!==self?self:g}function e(a){return["#if defined( USE_SURFACE_ALBEDO_MAP ) || defined( USE_SURFACE_ROUGHNESS_MAP ) || defined( USE_SURFACE_CUTOUT_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_OPAQUE_ALBEDO_MAP ) || defined( USE_OPAQUE_F0_MAP ) || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP ) || defined( USE_LAYERED_BOTTOM_F0_MAP ) || defined( USE_LAYERED_F0_MAP ) || defined( USE_LAYERED_DIFFUSE_MAP ) || defined( USE_LAYERED_FRACTION_MAP ) || defined( USE_LAYERED_ROUGHNESS_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_METAL_F0_MAP ) || defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )","#define "+a,"#endif"].join("\n")}function f(a,b,c,d){var e=c?"_v3":"",f=c?"vec3 ":"",g=c?b+" = averageOfFloat3("+b+e+");":"",h=d?b+e+" = SRGBToLinear("+b+e+");":"";return["#if defined( USE_"+a.toUpperCase()+"_MAP )","vec2 uv_"+a+"_map = ("+a+"_map_texMatrix * vec3(vUv, 1.0)).xy;",a.toUpperCase()+"_CLAMP_TEST;",f+b+e+" = texture2D("+a+"_map, uv_"+a+"_map).xyz;",h,"if("+a+"_map_invert) "+b+e+" = vec3(1.0) - "+b+e+";",g,"#else",b+" = "+a+";","#endif"].join("\n")}function h(a){var b=a+"_texMatrix",c=a+"_invert";return["#if defined( "+("USE_"+a).toUpperCase()+" )","uniform sampler2D "+a+";","uniform mat3 "+b+";","uniform bool "+c+";","#endif"].join("\n")}function i(a){var b=a+"_texMatrix",c=a+"_bumpScale",d=a+"_bumpmapType";return["#if defined( "+("USE_"+a).toUpperCase()+" )","uniform sampler2D "+a+";","uniform mat3 "+b+";","uniform vec2 "+c+";","uniform int "+d+";","#endif"].join("\n")}function j(a){return a.vb?a.vb.length/a.vbstride:a.attributes.positions?a.attributes.positions.count:0}function k(a,b,c){var d,e=a.attributes,f=a.vb||e.position.array,g=a.vb?a.vbstride:3;if(a.vblayout){if(!a.vblayout.position)return;d=a.vblayout.position.offset}else{if(!e.position)return;d=e.position.itemOffset||0}var h=f.length/g;$c||($c=new hd);for(var i=d,j=0;j<h;j++,i+=g)$c.set(f[i],f[i+1],f[i+2]),c&&$c.applyMatrix4(c),b($c,j)}function l(a,b){var c,d,e,f=a.attributes;_c||(_c=new hd,ad=new hd,bd=new hd,cd=new hd,dd=new hd,ed=new hd);var g,h=a.vb||f.position.array,i=a.vb||f.normal&&f.normal.array,j=a.vb?a.vbstride:3;if(a.vblayout){if(!a.vblayout.position)return;g=a.vblayout.position.offset}else{if(!f.position)return;g=f.position.itemOffset||0}var k=0,l=a.vblayout?a.vblayout.normal:f.normal||null;l?k=l.offset||l.itemOffset:i=null,!l||3===l.itemSize&&4===l.bytesPerItem||(i=null);var m=a.ib||a.indices||(f.index?f.index.array:null);if(m){var n=a.offsets;n&&0!==n.length||(n=[{start:0,count:m.length,index:0}]);for(var o=0,p=n.length;o<p;++o)for(var q=n[o].start,r=n[o].count,s=n[o].index,t=q,u=q+r;t<u;t+=3){c=s+m[t],d=s+m[t+1],e=s+m[t+2];var v=c*j+g,w=d*j+g,x=e*j+g;if(_c.x=h[v],_c.y=h[v+1],_c.z=h[v+2],ad.x=h[w],ad.y=h[w+1],ad.z=h[w+2],bd.x=h[x],bd.y=h[x+1],bd.z=h[x+2],i){var y=c*j+k,z=d*j+k,A=e*j+k;cd.x=i[y],cd.y=i[y+1],cd.z=i[y+2],dd.x=i[z],dd.y=i[z+1],dd.z=i[z+2],ed.x=i[A],ed.y=i[A+1],ed.z=i[A+2],b(_c,ad,bd,c,d,e,cd,dd,ed)}else b(_c,ad,bd,c,d,e)}}else for(var B=a.vb?a.vb.length/a.vbstride:h.length/3,t=0;t<B;t++){c=3*t,d=3*t+1,e=3*t+2;var v=c*j+g,w=d*j+g,x=e*j+g;if(_c.x=h[v],_c.y=h[v+1],_c.z=h[v+2],ad.x=h[w],ad.y=h[w+1],ad.z=h[w+2],bd.x=h[x],bd.y=h[x+1],bd.z=h[x+2],i){var y=c*j+k,z=d*j+k,A=e*j+k;cd.x=i[y],cd.y=i[y+1],cd.z=i[y+2],dd.x=i[z],dd.y=i[z+1],dd.z=i[z+2],ed.x=i[A],ed.y=i[A+1],ed.z=i[A+2],b(_c,ad,bd,c,d,e,cd,dd,ed)}else b(_c,ad,bd,c,d,e)}}function m(a,b){var c,d,e=a.attributes;fd||(fd=new hd,gd=new hd);var f=2;a.lineWidth&&(f=6);var f=2;a.lineWidth&&(f=6);var g=a.ib||a.indices||(e.index?e.index.array:null);if(g){var h=a.vb?a.vb:e.position.array,i=a.vb?a.vbstride:3,j=a.offsets;j&&0!==j.length||(j=[{start:0,count:g.length,index:0}]);for(var k=0,l=j.length;k<l;++k)for(var m=j[k].start,n=j[k].count,o=j[k].index,p=m,q=m+n;p<q;p+=f)c=o+g[p],d=o+g[p+1],fd.x=h[c*i],fd.y=h[c*i+1],fd.z=h[c*i+2],gd.x=h[d*i],gd.y=h[d*i+1],gd.z=h[d*i+2],b(fd,gd,c,d)}else for(var h=a.vb?a.vb:e.position.array,i=a.vb?a.vbstride:3,p=0,q=h.length;p<q;p+=f)c=p,d=p+1,fd.x=h[c*i],fd.y=h[c*i+1],fd.z=h[c*i+2],gd.x=h[d*i],gd.y=h[d*i+1],gd.z=h[d*i+2],b(fd,gd,c,d)}function n(a,b){function c(a,b){var c=0|a.x*j,d=0|a.y*j,e=0|a.z*j,g=f[c];g||(f[c]=g={});var h=g[d];h||(g[d]=h={});var i=h[e];return void 0===i&&(h[e]=i=b),i}function d(a,b){var d=c(a,b);e[b]=d}var e=[],f={},g=1;if(a.boundingBox||b){var h=(new kd).copy(a.boundingBox||b),i=h.size();g=Math.max(i.x,Math.max(i.y,i.z))}var j=65536/g;return sd(a,d),e}function o(a,b){function c(a,b){d[3*b]=a.x,d[3*b+1]=a.y,d[3*b+2]=a.z}var d=new Float32Array(3*qd(a));return sd(a,c,b),d}function p(a,b,c,d){function e(a,b){b.x=j[3*a],b.y=j[3*a+1],b.z=j[3*a+2]}function f(a,b,c,d){e(a,m),e(b,p),e(c,q),p.sub(m),q.sub(m),p.cross(q),d.copy(p).normalize()}function g(a,b,c){var e=i[a],g=i[b],h=i[c];if(e!==g&&e!==h&&g!==h){var j=!1;if(e>g){var m=e;e=g,g=m,j=!0}var n=k[e];if(n){var o=n[g];if(void 0===o)n[g]=j?-c-1:c;else{if(d)l.push(a),l.push(b);else{f(a,b,c,r),o<0?f(g,e,i[-o-1],s):f(e,g,i[o],s);var p=r.dot(s);Math.abs(p)<.25&&(l.push(a),l.push(b))}delete n[g]}}else k[e]={},k[e][g]=c}}function h(a,b,c,d,e,f){g(d,e,f),g(e,f,d),g(f,d,e)}if(!a.isLines&&!a.iblines){var i=n(a,c),j=o(a,b),k={},l=[],m=new jd,p=new jd,q=new jd,r=new jd,s=new jd;rd(a,h);for(var t in k)for(var u in k[t])l.push(parseInt(t)),l.push(parseInt(u));l.length>1&&(a.iblines=new Uint16Array(l.length),a.iblines.set(l))}}function q(){ld||(ld=new THREE.Matrix4,md=new THREE.Ray,nd=new THREE.Vector3,od=new THREE.Vector3,pd=new THREE.Vector3)}function r(a,b,c){q();var d=a.geometry;if(d){var e=a.material,f=e?e.side:THREE.FrontSide;ld.getInverse(a.matrixWorld),md.copy(b.ray).applyMatrix4(ld);var g,h,i=b.precision;id.enumMeshTriangles(d,function(d,e,j,k,l,m){null!==(g=f===THREE.BackSide?md.intersectTriangle(j,e,d,!0):md.intersectTriangle(d,e,j,f!==THREE.DoubleSide))&&(g.applyMatrix4(a.matrixWorld),(h=b.ray.origin.distanceTo(g))<i||h<b.near||h>b.far||c.push({distance:h,point:g,face:new THREE.Face3(k,l,m,THREE.Triangle.normal(d,e,j)),faceIndex:null,fragId:a.fragId,dbId:a.dbId}))})}}function s(a,b,c){q();var d=a.geometry;if(d){var e=b.linePrecision;a.isWideLine&&a.geometry.lineWidth&&(e=a.geometry.lineWidth);var f=e*e;ld.getInverse(a.matrixWorld),md.copy(b.ray).applyMatrix4(ld);var g=new THREE.Vector3,h=new THREE.Vector3;d instanceof THREE.BufferGeometry&&id.enumMeshLines(d,function(d,e){var i,j;md.distanceSqToSegment(d,e,h,g),g.applyMatrix4(a.matrixWorld),h.applyMatrix4(a.matrixWorld),(j=g.distanceToSquared(h))>f||(i=b.ray.origin.distanceTo(g))<b.near||i>b.far||c.push({distance:i,point:g,face:null,faceIndex:null,fragId:a.fragId,dbId:a.dbId})})}}function t(a,b,c){q();var d=a.geometry;if(d){ld.getInverse(a.matrixWorld),md.copy(b.ray).applyMatrix4(ld);var e=b.precision,f=b.params.PointCloud.threshold;f||(f=1),f*=Math.max(3,d.pointSize),f/=4,d instanceof THREE.BufferGeometry&&id.enumMeshVertices(d,function(d){if(!(md.distanceToPoint(d)>f)){var g=md.closestPointToPoint(d);if(null!==g){g.applyMatrix4(a.matrixWorld);var h=b.ray.origin.distanceTo(g);h<e||h<b.near||h>b.far||c.push({distance:h,point:d,face:null,faceIndex:null,fragId:a.fragId,dbId:a.dbId})}}})}}function u(a,b,c){a.isLine||a.isWideLine?s(a,b,c):a.isPoint?t(a,b,c):r(a,b,c)}function v(a,b,c,d){if(a instanceof THREE.Mesh?u(a,b,c):a.raycast(b,c),!0===d)for(var e=a.children,f=0,g=e.length;f<g;f++)v(e[f],b,c,!0)}function w(a,b,c,d){v(a,b,c,d),c.sort(ud)}function z(a,b,c){this.geoms=[null],this.numGeomsInMemory=0,this.geomMemory=0,this.gpuMeshMemory=0,this.gpuNumMeshes=0,this.geomPolyCount=0,this.instancePolyCount=0,this.is2d=b,this.geomBoxes=new Float32Array(6*Math.max(1,a+1)),this.disableStreaming=!!c}function A(){this.frustum=new THREE.Frustum,this.viewProj=new THREE.Matrix4,this.viewDir=[0,0,1],this.ar=1,this.viewport=new THREE.Vector3(1,1,1),this.areaConv=1,this.areaCullThreshold=1,this.eye=new THREE.Vector3}function B(){xd||(xd=new THREE.Box3)}function C(a,b,c,d){this.frags=a,this.indices=b,this.start=c,this.count=d,this.lastItem=c,this.overrideMaterial=null,this.sortDone=!1,this.numAdded=0,this.avgFrameTime=void 0,this.nodeIndex=void 0,this.boundingBox=new THREE.Box3,this.boundingBoxHidden=new THREE.Box3,this.sortObjects=!1,this.sortDone=!1,this.sortByShaderDone=!1,this.depths=null,this.indicesView=null,this.frustumCulled=!0,this.forceVisible=!1,this.renderImmediate=!a.useThreeMesh,this.renderImportance=0,B()}function D(a,b,c,d){var e=!1;return c.getWorldBounds(d,xd),a&&!b.intersectsBox(xd)&&(e=!0),e}function E(a,b,c){var d;if(b.array)d=new THREE.BufferAttribute(b.array,b.itemSize);else{var e=a+"|"+b.bytesPerItem+"|"+b.normalize+"|"+b.isPattern+"|"+b.divisor+"|"+b.offset;if(d=Bd[e])return d;d=new THREE.BufferAttribute(void 0,b.itemSize),Bd[e]=d}return d.bytesPerItem=b.bytesPerItem,d.normalize=b.normalize,d.isPattern=b.isPattern,c&&(d.divisor=b.divisor),b.array||(b.hasOwnProperty("offset")?d.itemOffset=b.offset:THREE.warn("VB attribute is neither interleaved nor separate. Something is wrong with the buffer specificaiton.")),d}function F(a){var b="";for(var c in a.attributes)b+=c+"|";var d=Cd[b];return d||(d=Object.keys(a.attributes),Cd[b]=d,d)}function G(){yd=new THREE.BufferAttribute(void 0,1),yd.bytesPerItem=2,zd=new THREE.BufferAttribute(void 0,1),zd.bytesPerItem=4,Ad=function(){this.uuid=null,this.name=null,this.id=Dd++,this.attributes={},this.attributesKeys=[],this.drawcalls=[],this.offsets=this.drawcalls,this.boundingBox=null,this.boundingSphere=null,this.numInstances=void 0,this.streamingDraw=!1,this.streamingIndex=!1,this.svfid=void 0,this.vb=null,this.vbbuffer=void 0,this.ib=null,this.ibbuffer=void 0,this.iblines=null,this.iblinesbuffer=void 0,this.vaos=void 0,this.vbNeedsUpdate=!1,this.vbstride=0,this.byteSize=0,this.attributesKeys=void 0,this.__webglInit=void 0},Ad.prototype=Object.create(THREE.BufferGeometry.prototype),Ad.prototype.constructor=Ad}function H(){return Ad||G(),new Ad}function I(b){var c=b.mesh,d=H();Bc()&&(d.packId=b.packId,d.meshIndex=b.meshIndex),d.byteSize=0,d.vb=c.vb,d.vbbuffer=void 0,d.vbNeedsUpdate=!0,d.byteSize+=c.vb.byteLength,d.vbstride=c.vbstride,c.isLines&&(d.isLines=c.isLines),c.isWideLines&&(d.isWideLines=!0,d.lineWidth=c.lineWidth),c.isPoints&&(d.isPoints=c.isPoints,d.pointSize=c.pointSize),b.is2d&&(d.is2d=!0),d.numInstances=c.numInstances;for(var e in c.vblayout){var f=c.vblayout[e];d.attributes[e]=E(e,f,d.numInstances)}if(a.memoryOptimizedLoading)d.attributes.index=c.indices instanceof Uint32Array?zd:yd,d.ib=c.indices,d.ibbuffer=void 0,c.iblines&&(d.attributes.indexlines=c.iblines instanceof Uint32Array?zd:yd,d.iblines=c.iblines,d.iblinesbuffer=void 0);else{var g=new THREE.BufferAttribute(c.indices,1);g.bytesPerItem=c.indices instanceof Uint32Array?4:2,d.addAttribute("index",g)}d.attributesKeys=F(d),d.byteSize+=c.indices.byteLength,d.boundingBox=(new THREE.Box3).copy(c.boundingBox),d.boundingSphere=(new THREE.Sphere).copy(c.boundingSphere),d.drawcalls=null,d.offsets=null,b.geometry=d,b.mesh=null}function J(){return Fd++}function K(){this.vb=null,this.vbstride=0,this.posOffset=0,this.normalOffset=0,this.matrices=null,this.ranges=null,this.dbIds=null,this.id=J()}function L(a){a.x=.5*(1+Math.atan2(a.y,a.x)/Math.PI),a.y=.5*(1+a.z),a.z=0}function M(a){var b=2*a.x-1,c=2*a.y-1,d=Math.sin(b*Math.PI),e=Math.cos(b*Math.PI),f=Math.sqrt(1-c*c),g=c;a.x=e*f,a.y=d*f,a.z=g}function N(a,b,c){b[c++]=255&a,b[c++]=a>>8&255,b[c++]=a>>16&255,b[c]=0}function O(a,b){return b.copy(a),b[12]=0,b[13]=0,b[14]=0,b.getInverse(b).transpose()}function P(a,b,c){for(var d=16*a,e=0;e<16;e++)c.elements[e]=b[e+d]}function Q(a){for(var b=new Uint16Array(a.length+1),c=0,d=0;d<a.length;d++)b[d]=c,c+=Hd(a[d]);return b[d]=c,b}function R(a,b,c,d){var e=Q(a),f=new K;return f.vb=b.vb,f.vbstride=b.vbstride,f.posOffset=b.attributes.position.itemOffset,f.normalOffset=b.attributes.normal?b.attributes.normal.itemOffset:-1,f.matrices=c,f.ranges=e,f.dbIds=d,f}function S(a,b){b.vb=a.vb,b.attributes.id.array=a.vertexIds,b.needsUpdate=!0}function T(a){function b(a){for(var b=a.data,e=0;e<b.length;e++){var h=b[e],i=h.taskId;S(h,d[i]),delete d[i]}if(0===--c)for(f.inProgress=!1,e=0;e<g.length;e++)g[e].clearAllEventListenerWithIntercept(),g[e].terminate(),g[e]=null}var c=0,d={},e=[],f=a,g=new Array(2);this.addMergeTask=function(a,b,c,f){var g=R(a,b,c,f);e.push(g),d[g.id]=b},this.runTasks=function(){for(var a=0;a<2;a++)g[a]=T.createWorker(),g[a].addEventListenerWithIntercept(b);for(var d=e.length,h=Math.floor(d/2),i=0;i<2;i++){var j=1===i,k=i*h,l=j?d:k+h,m=l-k,n=[],o=new Array(4*m),p=0;for(a=k;a<l;a++){var q=e[a];o[p++]=q.vb.buffer,o[p++]=q.matrices.buffer,o[p++]=q.ranges.buffer,o[p++]=q.dbIds.buffer,n.push(q)}var r={operation:"MERGE_GEOMETRY",tasks:n};g[i].doOperation(r,o),c++}f.inProgress=!0}}function U(a,b,c,d){var e=R(a,b,c,d),f=new THREE.Vector3,g=new THREE.Matrix4;S(e.run(g,f),b)}function V(a){var b=a+"_texMatrix",c=a+"_invert",d={};return d[a]={type:"t",value:null},d[b]={type:"m3",value:new THREE.Matrix3},d[c]={type:"i",value:0},d}function W(a){var b=a+"_texMatrix",c=a+"_bumpScale",d=a+"_bumpmapType",e={};return e[a]={type:"t",value:null},e[b]={type:"m3",value:new THREE.Matrix3},e[c]={type:"v2",value:new THREE.Vector2(1,1)},e[d]={type:"i",value:0},e}function X(b){a.logger=b}function Y(a,b){if(!a||!a.colors)return new THREE.Color(1,0,0);var c=a.colors[b];if(!c)return new THREE.Color(0,0,0);var d=c.values;if(!d||!d.length)return new THREE.Color(1,0,0);var e=d[0];return new THREE.Color(e.r,e.g,e.b)}function Z(a,b,c){if(!a||!a.scalars)return c;var d=a.scalars[b];return d?d.values[0]:c}function $(a,b,c){if(!a||!a.booleans)return c;var d=a.booleans;return d?d[b]:c}function _(a,b,c,d){if(!a||!a[b])return d;var e=a[b][c];return e?e.values[0]:d}function aa(a,b,c){var d={bands:0,weights:new THREE.Vector4(1,1,1,1),frequencies:new THREE.Vector4(1,1,1,1)};if(!a||!a[b])return d;var e=a[b][c];if(!(e&&e.values&&e.values instanceof Array))return d;var f=e.values;d.bands=f.length/2;for(var g=0;g<d.bands;++g)d.frequencies.setComponent(g,1/f[2*g]),d.weights.setComponent(g,f[2*g+1]);return d}function ba(a,b,c,d){if(!a||!a.scalars)return d;var e=a.scalars[b];return e?fa(e.values[0],e.units,c):d}function ca(a,b,c,d){if(!a||!a[b])return d;var e=a[b][c];return e&&e.connections?e.connections[0]:d}function da(a){var b=a;return b<=.04045?b/=12.92:b=Math.pow((b+.055)/1.055,2.4),b}function ea(a){var b,c,d;return b=da(a.r),c=da(a.g),d=da(a.b),new THREE.Color(b,c,d)}function fa(a,b,c){var d=Sd[c];d||(d=1,THREE.warn("Unsupported unit: "+c));var e=Sd[b];return e||(e=1,THREE.warn("Unsupported unit: "+b)),a*d/e}function ga(a,b,c){if(0===b){var d=ba(a,"bumpmap_Depth",c,0),e=1,f=1;return null!=_(a,"scalars","texture_RealWorldScale")?e=f=ba(a,"texture_RealWorldScale",c,1):(e=ba(a,"texture_RealWorldScaleX",c,1),f=ba(a,"texture_RealWorldScaleY",c,1)),e=0===e?1:1/e,f=0===f?1:1/f,new THREE.Vector2(e*d,f*d)}var g=_(a,"scalars","bumpmap_NormalScale",1);return new THREE.Vector2(g,g)}function ha(a,b){var c=ba(a,"texture_RealWorldOffsetX",b,0),d=ba(a,"texture_RealWorldOffsetY",b,0),e=_(a,"scalars","texture_UOffset",0),f=_(a,"scalars","texture_VOffset",0),g=1,h=1;null!=_(a,"scalars","texture_RealWorldScale")?g=h=ba(a,"texture_RealWorldScale",b,1):(g=ba(a,"texture_RealWorldScaleX",b,1),h=ba(a,"texture_RealWorldScaleY",b,1)),g=0===g?1:g,h=0===h?1:h;var i=_(a,"scalars","texture_UScale",1),j=_(a,"scalars","texture_VScale",1),k=_(a,"scalars","texture_WAngle",1);k*=Math.PI/180;var l=Math.cos(k),m=Math.sin(k),n=i/g,o=j/h;return{elements:[l*n,m*n,0,-m*o,l*o,0,-l*n*c+m*o*d+e,-m*n*c-l*o*d+f,1]}}function ia(){var a=[0,128,64,191,32,160,96,223,16,143,80,207,48,175,112,239,8,135,72,199,40,167,103,231,25,151,88,215,56,183,120,250],b=new Uint8Array(a),c=new THREE.DataTexture(b,32,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);c.generateMipmaps=!1,c.flipY=!1,c.needsUpdate=!0;for(var d,e,f=function(a,b){return Math.atan2(a*b,Math.sqrt(a*a+b*b+1))},g=new Uint8Array(16384),h=0;h<128;++h)for(var i=0;i<128;++i){d=h/128*2-1,e=i/128*2-1,d=Math.min(Math.max(1/128-1,d),1-1/128),e=Math.min(Math.max(1/128-1,e),1-1/128);var j=d-1/128,k=d+1/128,l=e-1/128,m=e+1/128,n=f(k,m)-f(j,m)-f(k,l)+f(j,l);g[128*h+i]=1e6*n}var o=new THREE.DataTexture(g,128,128,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);o.generateMipmaps=!1,o.flipY=!1,o.needsUpdate=!0,Qd={randomNum:c,solidAngle:o}}function ja(){var a=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],b=new Uint8Array(a),c=new THREE.DataTexture(b,256,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);c.generateMipmaps=!1,c.flipY=!1,c.needsUpdate=!0;var d=[225,39,122,231,29,173,15,159,75,88,233,19,179,79,72,94,54,73,151,161,171,113,221,144,127,83,168,19,88,122,62,225,109,128,246,247,172,101,61,139,211,168,64,210,224,82,87,97,119,250,201,44,242,239,154,99,126,13,44,70,246,170,100,52,135,28,187,22,207,119,199,1,235,187,55,131,190,124,222,249,236,53,225,231,71,30,173,185,153,47,79,133,225,10,140,62,17,99,100,29,137,95,142,244,76,5,83,124,38,216,253,195,44,210,148,185,188,39,78,195,132,30,60,73,92,223,133,80,230,56,118,207,79,15,251,211,111,21,79,23,240,146,150,207,3,61,103,27,148,6,31,127,235,58,173,244,116,81,34,120,192,213,188,226,97,23,16,161,106,80,242,148,35,37,91,117,51,216,97,193,126,222,39,38,133,217,215,23,237,57,205,42,222,165,126,133,33,8,227,154,27,18,56,11,192,120,80,92,236,38,210,207,128,31,135,39,123,5,49,127,107,200,34,14,153,239,134,19,248,162,58,201,159,198,243,158,72,5,138,184,222,200,34,141,233,40,195,238,191,122,171,32,66,254,229,197],e=new Uint8Array(d),f=new THREE.DataTexture(e,256,1,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);f.generateMipmaps=!1,f.flipY=!1,f.needsUpdate=!0;for(var g,h,i,j,k,l,m,n,o=function(b){return a[b%256]},p=new Array(262144),q=0;q<256;++q)for(n=0;n<256;++n)g=o(n)+q,h=o(g),i=o(g+1),j=o(n+1)+q,k=o(j),l=o(j+1),m=4*(256*q+n),p[m]=h,p[m+1]=i,p[m+2]=k,p[m+3]=l;var r=new Uint8Array(p),s=new THREE.DataTexture(r,256,256,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);s.generateMipmaps=!1,s.flipY=!1,s.needsUpdate=!0;var t=[1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1,1,1,0,0,-1,1,-1,1,0,0,-1,-1],u=new Array(1024);for(n=0;n<256;++n){var v=a[n]%16;u[4*n]=127*t[3*v]+128,u[4*n+1]=127*t[3*v+1]+128,u[4*n+2]=127*t[3*v+2]+128,u[4*n+3]=0}var w=new Uint8Array(u),x=new THREE.DataTexture(w,256,1,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter,0);x.generateMipmaps=!1,x.flipY=!1,x.needsUpdate=!0,Rd={permutation:c,gradient:f,perm2D:s,permGrad:x}}function ka(a,b,c){a[c+"_enable"]=_(b,"booleans",c+"_enable",0);var d=aa(b,"scalars",c+"_prof");a[c+"_bands"]=d.bands,a[c+"_weights"]=d.weights,a[c+"_frequencies"]=d.frequencies}function la(a){var b,c,d=a.materials,e=d[a.userassets[0]],f=e.properties,g=pa(a),h=g?Pd.createPrismMaterial():new THREE.MeshPhongMaterial;if(h.proteinMat=a,h.packedNormals=!0,e&&g){h.tag=e.tag,h.prismType=e.definition,void 0===h.prismType&&(h.prismType=""),void 0!==a.IsSingleSided&&!1===a.IsSingleSided&&(h.side=THREE.DoubleSide);var i=h.mapList;switch(h.transparent=!1,h.envExponentMin=1,h.envExponentMax=512,h.envExponentCount=10,h.surface_albedo=ea(Y(f,"surface_albedo",new THREE.Color(1,0,0))),i.surface_albedo_map=ca(f,"colors","surface_albedo",null),h.surface_anisotropy=_(f,"scalars","surface_anisotropy",0),i.surface_anisotropy_map=ca(f,"scalars","surface_anisotropy",null),h.surface_rotation=_(f,"scalars","surface_rotation",0),i.surface_rotation_map=ca(f,"scalars","surface_rotation",null),h.surface_roughness=_(f,"scalars","surface_roughness",0),i.surface_roughness_map=ca(f,"scalars","surface_roughness",null),i.surface_cutout_map=ca(f,"textures","surface_cutout",null),i.surface_normal_map=ca(f,"textures","surface_normal",null),null!=i.surface_cutout_map&&(h.side=THREE.DoubleSide,h.transparent=!0),h.prismType){case"PrismOpaque":h.opaque_albedo=ea(Y(f,"opaque_albedo",new THREE.Color(1,0,0))),i.opaque_albedo_map=ca(f,"colors","opaque_albedo",null),h.opaque_luminance_modifier=ea(Y(f,"opaque_luminance_modifier",new THREE.Color(0,0,0))),i.opaque_luminance_modifier_map=ca(f,"colors","opaque_luminance_modifier",null),h.opaque_f0=_(f,"scalars","opaque_f0",0),i.opaque_f0_map=ca(f,"scalars","opaque_f0",null),h.opaque_luminance=_(f,"scalars","opaque_luminance",0);break;case"PrismMetal":h.metal_f0=ea(Y(f,"metal_f0",new THREE.Color(1,0,0))),i.metal_f0_map=ca(f,"colors","metal_f0",null);break;case"PrismLayered":h.layered_bottom_f0=ea(Y(f,"layered_bottom_f0",new THREE.Color(1,1,1))),i.layered_bottom_f0_map=ca(f,"colors","layered_bottom_f0",null),h.layered_diffuse=ea(Y(f,"layered_diffuse",new THREE.Color(1,0,0))),i.layered_diffuse_map=ca(f,"colors","layered_diffuse",null),h.layered_anisotropy=_(f,"scalars","layered_anisotropy",0),i.layered_anisotropy_map=ca(f,"scalars","layered_anisotropy",null),h.layered_f0=_(f,"scalars","layered_f0",0),i.layered_f0_map=ca(f,"scalars","layered_f0",null),h.layered_fraction=_(f,"scalars","layered_fraction",0),i.layered_fraction_map=ca(f,"scalars","layered_fraction",null),h.layered_rotation=_(f,"scalars","layered_rotation",0),i.layered_rotation_map=ca(f,"scalars","layered_rotation",null),h.layered_roughness=_(f,"scalars","layered_roughness",0),i.layered_roughness_map=ca(f,"scalars","layered_roughness",null),i.layered_normal_map=ca(f,"textures","layered_normal",null);break;case"PrismTransparent":h.transparent_color=ea(Y(f,"transparent_color",new THREE.Color(1,0,0))),h.transparent_distance=_(f,"scalars","transparent_distance",0),h.transparent_ior=_(f,"scalars","transparent_ior",0),h.transparent=!0;break;case"PrismWood":ka(h,f,"wood_fiber_cosine"),ka(h,f,"wood_fiber_perlin"),h.wood_fiber_perlin_scale_z=_(f,"scalars","wood_fiber_perlin_scale_z",0),ka(h,f,"wood_growth_perlin"),h.wood_latewood_ratio=_(f,"scalars","wood_latewood_ratio",0),h.wood_earlywood_sharpness=_(f,"scalars","wood_earlywood_sharpness",0),h.wood_latewood_sharpness=_(f,"scalars","wood_latewood_sharpness",0),h.wood_ring_thickness=_(f,"scalars","wood_ring_thickness",0),ka(h,f,"wood_earlycolor_perlin"),h.wood_early_color=ea(Y(f,"wood_early_color",new THREE.Color(1,0,0))),h.wood_use_manual_late_color=_(f,"booleans","wood_use_manual_late_color",0),h.wood_manual_late_color=ea(Y(f,"wood_manual_late_color",new THREE.Color(1,0,0))),ka(h,f,"wood_latecolor_perlin"),h.wood_late_color_power=_(f,"scalars","wood_late_color_power",0),ka(h,f,"wood_diffuse_perlin"),h.wood_diffuse_perlin_scale_z=_(f,"scalars","wood_diffuse_perlin_scale_z",0),h.wood_use_pores=_(f,"booleans","wood_use_pores",0),h.wood_pore_type=_(f,"choicelists","wood_pore_type",0),h.wood_pore_radius=_(f,"scalars","wood_pore_radius",0),h.wood_pore_cell_dim=_(f,"scalars","wood_pore_cell_dim",0),h.wood_pore_color_power=_(f,"scalars","wood_pore_color_power",0),h.wood_pore_depth=_(f,"scalars","wood_pore_depth",0),h.wood_use_rays=_(f,"booleans","wood_use_rays",0),h.wood_ray_color_power=_(f,"scalars","wood_ray_color_power",0),h.wood_ray_seg_length_z=_(f,"scalars","wood_ray_seg_length_z",0),h.wood_ray_num_slices=_(f,"integers","wood_ray_num_slices",0),h.wood_ray_ellipse_z2x=_(f,"scalars","wood_ray_ellipse_z2x",0),h.wood_ray_ellipse_radius_x=_(f,"scalars","wood_ray_ellipse_radius_x",0),h.wood_use_latewood_bump=_(f,"booleans","wood_use_latewood_bump",0),h.wood_latewood_bump_depth=_(f,"scalars","wood_latewood_bump_depth",0),h.wood_use_groove_roughness=_(f,"booleans","wood_use_groove_roughness",0),h.wood_groove_roughness=_(f,"scalars","wood_groove_roughness",0),h.wood_diffuse_lobe_weight=_(f,"scalars","wood_diffuse_lobe_weight",0),h.wood_curly_distortion_enable=_(f,"booleans","wood_curly_distortion_enable",0),h.wood_curly_distortion_scale=_(f,"scalars","wood_curly_distortion_scale",0),i.wood_curly_distortion_map=ca(f,"scalars","wood_curly_distortion_map",null),Rd||ja(),h.uniforms.permutationMap.value=Rd.permutation,h.uniforms.gradientMap.value=Rd.gradient,h.uniforms.perm2DMap.value=Rd.perm2D,h.uniforms.permGradMap.value=Rd.permGrad;break;default:THREE.warn("Unknown prism type: "+h.prismType)}h.enableImportantSampling&&(h.surface_anisotropy||h.surface_rotation||h.layered_anisotropy||h.layered_rotation)&&(Qd||ia(),h.uniforms.importantSamplingRandomMap.value=Qd.randomNum,h.uniforms.importantSamplingSolidAngleMap.value=Qd.solidAngle),h.defines={},h.textureMaps={};for(var j in i)if(i[j]){var k=d[i[j]];c=k.properties;var l="BumpMap"==k.definition?"bumpmap_Bitmap":"unifiedbitmap_Bitmap",m=c.uris[l].values[0];m&&(b={mapName:j,uri:m,textureObj:k,isPrism:!0},h.textureMaps[b.mapName]=b,h.defines["USE_"+j.toUpperCase()]="")}h.defines[h.prismType.toUpperCase()]="","PrismWood"==h.prismType&&h.enable3DWoodBump&&(h.defines.PRISMWOODBUMP=""),h.enableImportantSampling&&(h.defines.ENABLEIMPORTANTSAMPLING="")}else if(e&&!g&&"SimplePhong"==e.definition){h.tag=e.tag,h.proteinType=e.proteinType,void 0===h.proteinType&&(h.proteinType=null);var n=h.ambient=Y(f,"generic_ambient"),o=h.color=Y(f,"generic_diffuse"),p=h.specular=Y(f,"generic_specular"),q=h.emissive=Y(f,"generic_emissive");h.shininess=Z(f,"generic_glossiness",30),h.opacity=1-Z(f,"generic_transparency",0),h.reflectivity=Z(f,"generic_reflectivity_at_0deg",0);var r=$(f,"generic_bump_is_normal"),s=Z(f,"generic_bump_amount",0);null==s&&(s=1),r?(s>1&&(s=1),h.normalScale=new THREE.Vector2(s,s)):(s>=1&&(s=.03),h.bumpScale=s);var t=$(f,"generic_is_metal");void 0!==t&&(h.metal=t);var u=$(f,"generic_backface_cull");void 0===u||u||(h.side=THREE.DoubleSide),h.transparent=e.transparent,h.textureMaps={};var v=e.textures;for(var w in v)if(b={},b.textureObj=d[v[w].connections[0]],c=b.textureObj.properties,b.uri=c.uris.unifiedbitmap_Bitmap.values[0],b.uri){if("generic_diffuse"==w)b.mapName="map",(!h.color||0===h.color.r&&0===h.color.g&&0===h.color.b)&&h.color.setRGB(1,1,1);else if("generic_bump"==w)b.mapName=r?"normalMap":"bumpMap";else if("generic_specular"==w)b.mapName="specularMap";else{if("generic_alpha"!=w)continue;b.mapName="alphaMap",h.side=THREE.DoubleSide,h.transparent=!0}h.textureMaps[b.mapName]=b}0===o.r&&0===o.g&&0===o.b&&0===p.r&&0===p.g&&0===p.b&&0===n.r&&0===n.g&&0===n.b&&0===q.r&&0===q.g&&0===q.b&&(o.r=o.g=o.b=.4),h.extraDepthOffset=Z(f,"generic_depth_offset"),h.extraDepthOffset&&(h.polygonOffset=!0,h.polygonOffsetFactor=h.extraDepthOffset,h.polygonOffsetUnits=0)}else h.ambient=197379,h.color=7829367,h.specular=3355443,h.shininess=30,h.shading=THREE.SmoothShading;return a.transparent=h.transparent,h}function ma(a,b,c){var d=a.properties;b.clampS=!_(d,"booleans","texture_URepeat",!1),b.clampT=!_(d,"booleans","texture_VRepeat",!1),b.wrapS=b.clampS?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,b.wrapT=b.clampT?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,b.matrix=ha(d,c),"UnifiedBitmap"==a.definition&&(b.invert=_(d,"booleans","unifiedbitmap_Invert",!1)),"BumpMap"==a.definition&&(b.bumpmapType=_(d,"choicelists","bumpmap_Type",0),b.bumpScale=ga(d,b.bumpmapType,c))}function na(a,b){if(a){var c=a.properties;b.invert=$(c,"unifiedbitmap_Invert"),b.clampS=!$(c,"texture_URepeat",!0),b.clampT=!$(c,"texture_VRepeat",!0),b.wrapS=b.clampS?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping,b.wrapT=b.clampT?THREE.ClampToEdgeWrapping:THREE.RepeatWrapping;var d=Z(c,"texture_UScale",1),e=Z(c,"texture_VScale",1),f=Z(c,"texture_UOffset",0),g=Z(c,"texture_VOffset",0),h=Z(c,"texture_WAngle",0);b.matrix={elements:[Math.cos(h)*d,Math.sin(h)*e,0,-Math.sin(h)*d,Math.cos(h)*e,0,f,g,1]}}}function oa(a,b,c,d){"bumpMap"==a.mapName||"normalMap"==a.mapName?b.anisotropy=0:b.anisotropy=d||0,b.flipY=void 0===a.flipY||a.flipY,b.invert=!1,b.wrapS=THREE.RepeatWrapping,b.wrapT=THREE.RepeatWrapping,a.isPrism?ma(a.textureObj,b,c):na(a.textureObj,b)}function pa(a){var b=a.materials,c=b[a.userassets[0]];if(c){var d=c.definition;return"PrismLayered"==d||"PrismMetal"==d||"PrismOpaque"==d||"PrismTransparent"==d||"PrismWood"==d}return!1}function qa(a,b){var c=new THREE.MeshPhongMaterial;c.packedNormals=!0,c.textureMaps={};var d=a.values,e=d.diffuse;if(e)if(Array.isArray(e))c.color=new THREE.Color(e[0],e[1],e[2]);else if("string"==typeof e){c.color=new THREE.Color(1,1,1);var f={};f.mapName="map";var g=b.gltf.textures[e];f.uri=g.source,f.flipY=!1,c.textureMaps[f.mapName]=f}var h=d.specular;return h&&(c.specular=new THREE.Color(h[0],h[1],h[2])),d.shininess&&(c.shininess=d.shininess),c.reflectivity=0,c.transparent=!1,c}function ra(a){return.299*a.r+.587*a.g+.114*a.b}function sa(a,b,c){var d=a.proteinMat?a.proteinMat:null,e=a.prismType&&-1!==a.prismType.indexOf("Prism");if(e&&a.transparent&&(a.side===THREE.FrontSide&&(a.side=THREE.DoubleSide),a.side===THREE.DoubleSide&&a.depthTest&&(a.twoPassTransparency=!0)),!b){var f=a.proteinType&&-1!==a.proteinType.indexOf("Prism");if(a.metal)a.reflectivity||(a.reflectivity=ra(a.specular)),d&&(1===a.reflectivity&&(a.reflectivity=ra(a.specular)),0===a.color.r&&0===a.color.g&&0===a.color.b||(a.color.r*=.1,a.color.g*=.1,a.color.b*=.1));else if(f){var g=!1;if("PrismLayered"===a.proteinType&&(a.clearcoat=!0,a.reflectivity=.06,d)){var h=d.materials[d.userassets[0]],i=h.categories;i&&i.length&&-1!=i[0].indexOf("Metal")&&(g=!0)}a.reflectivity=Math.sqrt(a.reflectivity),g?a.specular.copy(a.color):(a.specular.r=a.reflectivity,a.specular.g=a.reflectivity,a.specular.b=a.reflectivity)}else a.reflectivity?a.reflectivity>.3?(a.metal=!0,a.specular.r=a.color.r,a.specular.g=a.color.g,a.specular.b=a.color.b,a.color.r*=.1,a.color.g*=.1,a.color.b*=.1):(a.specular.r*=a.reflectivity,a.specular.g*=a.reflectivity,a.specular.b*=a.reflectivity):1!==a.color.r||1!==a.color.g||1!==a.color.b||1!==a.specular.r||1!==a.specular.g||1!==a.specular.b||a.textureMaps&&(a.textureMaps.map||a.textureMaps.specularMap)?(a.reflectivity=.01+.06*ra(a.specular),a.specular.r*=a.reflectivity,
a.specular.g*=a.reflectivity,a.specular.b*=a.reflectivity):(a.metal=!0,a.reflectivity=.7,a.color.r*=.1,a.color.g*=.1,a.color.b*=.1),a.opacity<1&&(a.reflectivity=1);(a.transparent||a.textureMaps&&(a.textureMaps.map&&-1!==a.textureMaps.map.uri.toLowerCase().indexOf(".png")||a.textureMaps.alphaMap))&&(a.alphaTest=.01)}if(a.textureMaps&&a.textureMaps.normalMap){var j=a.bumpScale;(void 0===j||j>=1)&&(j=1),a.normalScale=new THREE.Vector2(j,j)}else void 0===a.bumpScale&&a.textureMaps&&(a.textureMaps.map||a.textureMaps.bumpMap)?a.bumpScale=.03:a.bumpScale>=1&&(a.bumpScale=.03);if((!b||e)&&a.transparent)if(e)a.lmv_depthWriteTransparent=!0,a.depthWrite=!!c;else if(a.opacity>=1){var k=a.textureMaps&&a.textureMaps.alphaMap;k||(a.transparency=!1)}else a.lmv_depthWriteTransparent=!0,a.depthWrite=!!c;void 0!==a.shininess&&(a.shininess*=.25)}function ta(a,b){b.attributes.color&&(a.vertexColors=THREE.VertexColors,a.needsUpdate=!0),!a.proteinType&&b.attributes.uv&&b.attributes.uv.isPattern&&(a.map&&!a.bumpMap&&(a.bumpMap=a.map,a.needsUpdate=!0),a.textureMaps&&a.textureMaps.map&&!a.textureMaps.bumpMap&&(a.textureMaps.bumpMap=a.textureMaps.map,a.needsUpdate=!0),a.bumpScale=.03)}function ua(a){return a.isLines?_d.LINES:a.isPoints?_d.POINTS:a.isWideLines?_d.WIDE_LINES:_d.TRIANGLES}function va(a,b){switch(!0===a.isLines&&(a.isLines=void 0),!0===a.isWideLines&&(a.isWideLines=void 0),!0===a.isPoints&&(a.isPoints=void 0),b){case _d.LINES:a.isLines=!0;break;case _d.WIDE_LINES:a.isWideLines=!0;break;case _d.POINTS:a.isPoints=!0}}function wa(a){this.geoms=[],this.matrices=[],this.vertexCount=0,this.material=a,this.fragIds=[],this.worldBox=new THREE.Box3}function xa(a,b){a.vb&&a.vbstride||THREE.warn("copyVertexFormat() supports only interleaved buffers");for(var c in a.attributes)b.attributes[c]=a.attributes[c];b.attributesKeys=a.attributesKeys.slice(0),b.vbstride=a.vbstride}function ya(a,b){va(b,ua(a)),b.lineWidth=a.lineWidth,b.pointSize=a.pointSize}function za(a){for(var b=a[0].vbstride,c=0,d=0,e=0,f=0;f<a.length;f++){var g=a[f];c+=a[f].ib.length,d+=Xd(g),a[f].iblines&&(e+=a[f].iblines.length)}var h=H();h.vb=new Float32Array(d*b),h.ib=new Uint16Array(c),e&&(h.iblines=new Uint16Array(e)),h.byteSize=h.vb.byteLength+h.ib.byteLength,h.iblines&&(h.byteSize+=h.iblines.byteLength),ya(a[0],h),xa(a[0],h);var i=new THREE.BufferAttribute(null,3);i.normalize=!0,i.bytesPerItem=1,h.addAttribute("id",i);var j=a[0];return va(h,ua(j)),j.isPoints&&(h=j.pointSize),j.isWideLines&&(h=j.lineWidth),h}function Aa(a,b){for(var c=0,d=0,e=0,f=0,g=0;g<a.length;g++){for(var h=a[g],i=Xd(h),j=0;j<h.ib.length;j++)b.ib[e+j]=h.ib[j]+d;if(h.iblines){for(var j=0;j<h.iblines.length;j++)b.iblines[f+j]=h.iblines[j]+d;f+=h.iblines.length}b.vb.set(h.vb,c),c+=h.vb.length,d+=i,e+=h.ib.length}}function Ba(a,b,c,d,e){var f=za(a);return f.boundingBox=d.clone(),Aa(a,f),e?e.addMergeTask(a,f,b,c):Yd(a,f,b,c),f}function Ca(a,b){if(a.vbstride!=b.vbstride)return!1;if(ua(a)!==ua(b))return!1;if(a.isPoints&&a.pointSize!==b.pointSize)return!1;if(a.isWideLines&&a.lineWidth!==b.lineWidth)return!1;if(a.attributesKeys.length!=b.attributesKeys.length)return!1;for(var c=0,d=a.attributesKeys.length;c<d;c++){var e=a.attributesKeys[c],f=a.attributes[e],g=b.attributes[e];if(!g)return!1;if(f===g)return!0;if(f.itemOffset!==g.itemOffset||f.normalize!==g.normalize||f.itemSize!==g.itemSize||f.bytesPerItem!==g.bytesPerItem||f.isPattern!==g.isPattern)return!1}return!0}function Da(a){this.meshes=[],this.fragId2MeshIndex=new Int32Array(a);for(var b=0;b<this.fragId2MeshIndex.length;b++)this.fragId2MeshIndex[b]=-1;this.byteSize=0,this.consolidationMap=null}function Ea(){this.buckets={},this.bucketCount=0,this.costs=0}function Fa(a,b){this.fragOrder=new Uint32Array(a),this.ranges=new Uint32Array(b),this.boxes=new Array(b),this.numConsolidated=-1}function Ga(a){Zd.createWorker=a}function Ha(){return!!Zd.createWorker}function Ia(a,b){function c(a,b,c,d){h.compose(b,c,d);for(var e=a.elements,f=h.elements,g=0;g<16;g++){var i=e[g],j=f[g];if(Math.abs(j-i)>1e-5)return!1}return!0}var d=H();d.ib=a.ib,d.vb=a.vb,d.iblines=a.iblines,xa(a,d),ya(a,d);this.offsets=new Float32Array(3*b),this.rotations=new Float32Array(4*b),this.scalings=new Float32Array(3*b),this.ids=new Uint8Array(3*b);var e=new THREE.Vector3,f=new THREE.Quaternion,g=new THREE.Vector3,h=new THREE.Matrix4,i=0,j=b;this.addInstance=function(a,b){return i>=j?(THREE.warn("Instance buffer is already full."),!1):(a.decompose(e,f,g),!!c(a,e,f,g)&&(this.offsets[3*i]=e.x,this.offsets[3*i+1]=e.y,this.offsets[3*i+2]=e.z,this.rotations[4*i]=f.x,this.rotations[4*i+1]=f.y,this.rotations[4*i+2]=f.z,this.rotations[4*i+3]=f.w,this.scalings[3*i]=g.x,this.scalings[3*i+1]=g.y,this.scalings[3*i+2]=g.z,N(b,this.ids,3*i),i++,!0))},this.finish=function(){if(0==i)return null;i<j&&(this.offsets=new Float32Array(this.offsets.buffer,0,3*i),this.rotations=new Float32Array(this.rotations.buffer,0,4*i),this.scalings=new Float32Array(this.scalings.buffer,0,3*i),this.ids=new Uint8Array(this.ids.buffer,0,3*i));var a=new THREE.BufferAttribute(this.offsets,3),b=new THREE.BufferAttribute(this.rotations,4),c=new THREE.BufferAttribute(this.scalings,3),e=new THREE.BufferAttribute(this.ids,3);return e.normalize=!0,e.bytesPerItem=1,a.divisor=1,b.divisor=1,c.divisor=1,e.divisor=1,d.addAttribute("instOffset",a),d.addAttribute("instRotation",b),d.addAttribute("instScaling",c),d.addAttribute("id",e),d.numInstances=i,d.byteSize=d.vb.byteLength+d.ib.byteLength+this.offsets.byteLength+this.rotations.byteLength+this.scalings.byteLength,d}}function Ja(a){var b=new THREE.PlaneBufferGeometry(1,1);if(b.attributes.index.array.reverse)b.attributes.index.array.reverse();else for(var c,d=b.attributes.index.array,e=Math.floor(d.length/2),f=0,g=d.length;f<e;++f)c=d[f],d[f]=d[g-1-f],d[g-1-f]=c;return new THREE.Mesh(b,a)}function Ka(){this.shadowMap=void 0,this.shadowMapSize=void 0,this.shadowMatrix=void 0,this.shadowLightDir=void 0,this.init=function(a){this.shadowMap=a,this.shadowMapSize=new THREE.Vector2(a.width,a.height),this.shadowMatrix=new THREE.Matrix4,this.shadowLightDir=new THREE.Vector3},this.apply=function(a){a.shadowMap=this.shadowMap,a.shadowMatrix=this.shadowMatrix,a.shadowLightDir=this.shadowLightDir,this.shadowMap?(pc.setMacro(a,"USE_SHADOWMAP"),re.UseHardShadows&&pc.setMacro(a,"USE_HARD_SHADOWS")):(pc.removeMacro(a,"USE_SHADOWMAP"),pc.removeMacro(a,"USE_HARD_SHADOWS"))}}function La(a){function b(a,b){a.forEach(function(a){b.apply(a)})}function c(a){var b=new THREE.WebGLRenderTarget(a,a,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,type:THREE.FloatType,stencilBuffer:!1,generateMipmaps:!1});return b.generateMipmaps=!1,b}function d(a){m.setRenderTarget(a),m.setClearColor(l,1),m.clear()}function e(a){var c=h.shadowMap;h.shadowMap=s,b(a,h),h.apply(n),h.shadowMap=c}function f(a){a.uniforms.shadowMapRangeMin.value=j.near,a.uniforms.shadowMapRangeSize.value=j.far-j.near,a.uniforms.shadowESMConstant.value=re.ShadowESMConstant,a.uniforms.shadowMinOpacity.value=re.ShadowMinOpacity}function g(a,b,c){var d=c||new THREE.Vector3;return d.x=1&b?a.max.x:a.min.x,d.y=2&b?a.max.y:a.min.y,d.z=4&b?a.max.z:a.min.z,d}var h=null,i=null,j=new THREE.OrthographicCamera,k=Math.exp(re.ShadowESMConstant),l=re.UseHardShadows?new THREE.Color(1,1,1):new THREE.Color(k,1,1),m=a,n=null,o=null,p=null,q=pc.createShaderMaterial(oe),r=new qe;q.getCustomOverrideMaterial=r.getCustomOverrideMaterial;var s=null,t=function(){var a=new THREE.Matrix4,b=new THREE.Matrix4,c=new THREE.Vector3(0,0,0),d=new THREE.Box3,e=new THREE.Vector3,f=new THREE.Vector3;return function(g,h,i){g.position.copy(i),g.lookAt(c),a.makeRotationFromQuaternion(g.quaternion),b.getInverse(a),d.copy(h).applyMatrix4(b),f=d.center(f),e.set(f.x,f.y,d.max.z),e.applyMatrix4(a),g.position.copy(e),f=d.size(f),g.left=-.5*f.x,g.right=.5*f.x,g.bottom=-.5*f.y,g.top=.5*f.y,g.near=0,g.far=f.z,g.updateMatrixWorld(),g.matrixWorldInverse.getInverse(g.matrixWorld),g.updateProjectionMatrix()}}();this.init=function(){h=new Ka,h.init(c(re.ShadowMapSize)),i=re.BlurShadowMap?new sc(re.ShadowMapSize,re.ShadowMapSize,re.ShadowMapBlurRadius,1,{type:h.shadowMap.type,format:h.shadowMap.format}):void 0,n=pc.createShaderMaterial(pe),n.depthWrite=!1,n.transparent=!0,o=ne.createGroundShape(n),p=new THREE.Scene,p.add(o),this.groundShapeBox=new THREE.Box3,s=c(1),d(s)},this.init(),this.state=se,this.startUpdate=function(a,b,c,d,e){var f=a.getVisibleBounds(!0);return this.beginShadowMapUpdate(c,f,d),a.reset(j,3,!0),this.state=te,b=this.continueUpdate(a,b,e)},this.continueUpdate=function(a,b,c){return b=a.renderSome(this.renderSceneIntoShadowMap,b),a.isDone()?(this.state=ue,this.finishShadowMapUpdate(c)):e(c),b},this.beginShadowMapUpdate=function(a,b,c){t(j,b,c),f(q),r.forEachMaterial(f),re.UseHardShadows&&(pc.setMacro(q,"USE_HARD_SHADOWS"),r.forEachMaterial(function(a){pc.setMacro(a,"USE_HARD_SHADOWS")})),d(h.shadowMap),this.renderSceneIntoShadowMap(p)},this.renderSceneIntoShadowMap=function(a){a.overrideMaterial=q,m.render(a,j,h.shadowMap),a.overrideMaterial=null},this.finishShadowMapUpdate=function(a){i&&!re.UseHardShadows&&i.render(m,h.shadowMap,h.shadowMap),h.shadowMatrix.multiplyMatrices(j.projectionMatrix,j.matrixWorldInverse),h.shadowMapRangeMin=j.near,h.shadowMapRangeSize=j.far-j.near,h.shadowLightDir.copy(j.position).normalize(),b(a,h),h.apply(n),this.isValid=!0},this.cleanup=function(a){i&&i.cleanup(),h.shadowMap&&h.shadowMap.dispose(),b(a,ve),q.dispose(),r.dispose(),n.dispose(),o.geometry.dispose()},this.setGroundShadowTransform=function(){return function(a,b,c,d){ne.setGroundShapeTransform(o,a,b,c,d),this.groundShapeBox.setFromObject(o)}}(),this.renderGroundShadow=function(a,b){m.render(p,a,b,!1)},this.expandByGroundShadow=function(){var a=new THREE.Plane,b=new THREE.Ray,c=new THREE.Vector3,d=new THREE.Vector3,e=new THREE.Box3;return function(f,h){a.normal.set(0,1,0),a.constant=-f.min.y,b.direction.copy(h).negate().normalize();var i=f.center(c),j=100*i.distanceToSquared(f.min)*100;e.makeEmpty();for(var k=0;k<8;k++){b.origin=g(f,k);var l=b.intersectPlane(a,d);l&&(l.distanceToSquared(i)>=j||e.expandByPoint(l))}f.union(e)}}(),this.getShadowParams=function(){return h},this.getShadowCamera=function(){return j}}function Ma(){}function Na(a,b,c,d){C.call(this,a,b,c,d),this.visibleStats=0}function Oa(a){function b(a){return a.matrix.elements[2]+a.matrix.elements[12]}for(var c,d=a.getFragmentList(),e=a,f=e.is2d()&&!d.onDemandLoadingEnabled(),g=d.getCount(),h=0,i=[new Int32Array(g)],j=0,k=!1,l=0;l<g;l++)i[0][l]=l;this.calculateFragOrder=function(){if(e.isvizCacheEnabled){var a,b=e.readbackTargetIdCallback(),d={},f=b.width*b.height,h=b.buffer;for(a=0;a<f;a++){var j=h[4*a+2]<<16|h[4*a+1]<<8|h[4*a];16777215!=j&&(d[j]=1+(0|d[j]))}var k=Object.keys(d).sort(function(a,b){return d[b]-d[a]}).map(Number);e.setFastLoadList(k,c);var l=i[0];l.set(k);var m=k.length;for(a=0;a<g;++a)d[a]||(l[m++]=a)}};var m=ye;a.is2d()&&(m/=3),wc()&&(m/=3,a.is2d()&&(m/=2)),m=Math.floor(m);var n=m>0?m:ye,o=Math.floor((g+n-1)/n),p=d.onDemandLoadingEnabled(),q=p?Na:C,r=new Array(o);for(l=0;l<o;l++){var s=l*n,t=r[l]=new q(d,i,s,n),u=s+n;u>g&&(u=g),t.lastItem=u,p&&t.calculateBounds()}this.addFragment=function(a){if(i[0].length<=a){var b=2*i[0].length;b<=a&&(b=a+1);var c=new Int32Array(b);c.set(i[0]),i[0]=c,this.visibleBoundsDirty=!0}i[0][a]=a;var e=Math.floor(a/n);if(r){var f=r[e];f||(r[e]=f=new q(d,i,e*n,n)),f&&f.onFragmentAdded(a)}},this.getFragmentCount=function(){if(!r)return 0;for(var a=r[r.length-1].lastItem;--a>=0&&!(d.geomids[a]>=0););return a+1},this.reset=function(a,d){j!=b(d)&&(k=!0),j=b(d),c=d,h=0,f&&r[0]&&(r[0].drawEnd=0)},this.getSceneCount=function(){return r.length},this.getGeomScenes=function(){return r},this.done=function(){if(f&&!e.isLoadDone())return!1;var a;return h>=r.length-1&&(!(a=r[h])||a.drawStart>=a.lastItem)},this.nextBatch=function(){if(e.isvizCacheEnabled&&k&&(90==h||400==h||h==this.getSceneCount()-1)&&(h==this.getSceneCount()-1&&e.isLoadDone()&&(k=!1),this.calculateFragOrder(h>=this.getSceneCount()-1)),h>=this.getSceneCount())return null;var a=r[h];if(f){if(a.lastItem>=a.start+a.count&&(++h,r[h]&&(r[h].drawEnd=r[h].start)),a.drawStart=a.drawEnd,a.drawEnd=a.lastItem,a.hasOwnProperty("drawStart")&&a.lastItem<=a.drawStart)return null}else++h;return a.renderImportance=0,a},this.getVisibleBounds=function(a,b){for(var c=this.getSceneCount(),d=0;d<c;d++)r[d].calculateBounds(),a.union(r[d].boundingBox),b.union(r[d].boundingBox),b.union(r[d].boundingBoxHidden)},this.rayCast=function(a,b,c){for(var d=this.getSceneCount(),e=0;e<d;e++)r[e].raycast(a,b,c)}}function Pa(a,b,c,d){for(var e=new THREE.Box3,f=new Ea,g=0;g<c.length&&!(f.costs>=d);g++){var h=c[g];a.getWorldBounds(h,e);var i=a.getGeometry(h),j=a.getMaterial(h);f.addGeom(i,j,e,h)}return f.createConsolidationMap(c,g)}function Qa(a,b,c,d,e){if(!(d>=c.length)){for(var f=d,g=-1,h=-1,i=d;i<c.length;i++){var j=c[i],k=a.getGeometryId(j),l=a.getMaterialId(j);k==g&&l==h||(i!=d&&Ae(a,b,c,f,i,e),f=i,g=k,h=l)}Ae(a,b,c,f,c.length,e)}}function Ra(a){for(var b=a.getCount(),c=[],d=0;d<b;d++){var e=a.getGeometryId(d),f=0|c[e];c[e]=f+1}return c}function Sa(a,b){function c(c,d){var e=a.getGeometry(c),f=a.getGeometry(d),g=b[e.id],h=b[f.id],i=g*e.byteSize,j=h*f.byteSize;return i!=j?i-j:e.id!=f.id?e.id-f.id:a.getMaterialId(c)-a.getMaterialId(d)}for(var d=0,e=a.getCount(),f=new Int32Array(e),g=0;g<e;g++)a.getGeometry(g)&&(f[d]=g,d++);if(d<e&&(f=new Int32Array(f.buffer,f.byteOffset,d)),f.sort)f.sort(c);else{var h=new Array(e);for(g=0;g<e;g++)h[g]=f[g];for(h.sort(c),g=0;g<f.length;g++)f[g]=h[g]}return f}function Ta(a,b,c,d){for(var e=a.geoms,f=[],g=0,h=0,i=0;i<b.meshes.length;i++){var j=b.meshes[i],k=j.geometry;k.byteSize||(k.byteSize=(k.vb.byteLength||0)+(k.ib.byteLength||0));var l=Number.isInteger(j.fragId);e.chooseMemoryType(k,k.numInstances,g,h),k.streamingDraw||(h+=k.byteSize,g+=1,l||(k.discardAfterUpload=!0)),l&&(f[k.id]=!0)}for(i=1;i<e.geoms.length;i++)if((k=e.geoms[i])&&!f[i]){var m=c[i];e.chooseMemoryType(k,m,g,h),k.streamingDraw&&d.deallocateGeometry(k),k.streamingDraw||(h+=k.byteSize,g+=1)}}function Ua(a,b,c,d,e){var f=d.supportsInstancedArrays();c=c||100<<20;var g=Ra(a);if(!e){e=Pa(a,b,Sa(a,g),c)}var h=e.buildConsolidation(a,b,a.model),i=e.fragOrder,j=e.numConsolidated;if(f)Qa(a,b,i,j,h);else for(var k=j;k<i.length;k++){var l=i[k];h.addSingleFragment(a,l)}Ta(a,h,g,d);var m=a.model.getModelId();for(k=0;k<h.meshes.length;k++){h.meshes[k].modelId=m}return h}function Va(a,b){function c(a){j[a]||(j[a]=new THREE.Scene);var b=j[a];return b.children.length=0,b}function d(a){return a.numInstances?m.Instanced:a.attributes.id?m.Merged:m.Original}function e(a){if(i)return m.Original;var b=g.fragId2MeshIndex[a];return d(g.meshes[b].geometry)}var f=a,g=b,h=[],i=!1,j=[],k=new THREE.Matrix4,l=new THREE.Box3;this.getConsolidation=function(){return g},this.reset=function(){h.length=null;var a=f.getCount();i=!1;for(var b=f.db2ThemingColor.length>0,c=0;c<a;c++){var d=f.vizflags[c],e=0==(d&Mc),g=0!=(d&Oc),j=0!=(d&Pc),k=!1;if(b){var l=f.fragments.fragId2dbId[c];k=!!f.db2ThemingColor[l]}if(e||g||k||j){i=!0;break}}},this.dispose=function(){for(var a=0;a<g.meshes.length;a++){var b=g.meshes[a],c=b.geometry;c&&(c.dispose(),c.needsUpdate=!0)}},this.consolidateNextBatch=function(a,b){var d=a.nodeIndex;if(i||void 0===d)return a;if(g.inProgress)return a;for(var e=c(d),j=a.start;j<a.lastItem;j++){var k=a.indices?a.indices[j]:j,m=g.fragId2MeshIndex[k],n=null;if(-1===m){if(!f.getGeometry(k))continue;return THREE.warn("Warning: Missing fragment in consolidation. Consolidation disabled."),a}h[m]||(f.getWorldBounds(k,l),b.intersectsBox(l)&&(n=g.meshes[m],h[m]=!0,e.children.push(n)))}return e.boundingBox=a.boundingBox,e.renderImportance=a.renderImportance,e.sortObjects=a.sortObjects,e};var m={Merged:1,Instanced:2,Original:3};this.updateRenderProxy=function(a,b){if(a.geometry&&a.geometry.attributes){var c=e(b);if(d(a.geometry)!=c){var h=f.getGeometry(b),i=g.fragId2MeshIndex[b],j=g.meshes[i];if(c===m.Original)a.geometry=h,a.material=f.getMaterial(b),f.getWorldMatrix(b,a.matrix);else if(c===m.Instanced){f.getWorldMatrix(b,k);var n=f.fragments.fragId2dbId[b],o=new Ia(h,1);o.addInstance(k,n),a.geometry=o.finish(),a.material=j.material,a.matrix.identity()}else f.getWorldMatrix(b,k),f.getWorldBounds(b,l),n=f.fragments.fragId2dbId[b],a.geometry=Ba([h],k.elements,[n],l),a.material=j.material,a.matrix.identity();a.dispatchEvent({type:"removed"})}}}}function Wa(){function a(a){var b=l[a],c=e;if(m)for(;c>d&&l[k[c-1]]>b;)k[c]=k[c-1],c--;else for(;c>d&&l[k[c-1]]<b;)k[c]=k[c-1],c--;k[c]=a,e++}function b(a){var c=g.getLeftChild(a);-1!==c&&(b(c),b(c+1)),q.makeEmpty(),-1!==c&&(g.getBoxThree(c,r),q.union(r),g.getBoxThree(c+1,r),q.union(r)),g.getPrimCount(a)&&(q.union(i[a].boundingBox),q.union(i[a].boundingBoxHidden)),g.setBoxThree(a,q)}var c,d,e,f,g=null,h=null,i=null,j=null,k=null,l=null,m=1,n=!0,o=!1,p=!1,q=new THREE.Box3,r=new THREE.Box3,s=!1;this.initialize=function(a,b,d,e){c=a.getFragmentList(),e&&e.hasOwnProperty("prioritize_screen_size")&&(n=e.prioritize_screen_size),h=d,i=new Array(b.nodeCount),j=new Int8Array(b.nodeCount),g=b,k=new Int32Array(b.nodeCount+1),l=new Float32Array(b.nodeCount);for(var f=c.onDemandLoadingEnabled()?Na:C,m=0;m<b.nodeCount;m++){var o=b.getPrimCount(m);o&&(i[m]=new f(c,h,b.getPrimStart(m),o),i[m].lastItem=i[m].start+o,i[m].numAdded=o,i[m].nodeIndex=m,8&b.getFlags(m)&&(i[m].sortObjects=!0),b.getBoxThree(m,i[m].boundingBox))}},this.addFragment=function(a,b){},this.reset=function(a){f=a,d=0,e=0,j[0]=j[1]=A.CONTAINMENT_UNKNOWN,k[e++]=0,o=!1,p=!1,s=!1},this.nextBatch=function(){for(p||o||d!==e||(k[e++]=1,o=!0);d!==e;){var b=m||o?k[--e]:k[d++],c=j[b];if(c!==A.CONTAINS&&(g.getBoxThree(b,q),c=f.intersectsBox(q)),c!==A.OUTSIDE){var h,r,t=g.getLeftChild(b),u=-1!==t;if(u){var v=g.getFlags(b),w=f.viewDir[3&v]<0?1:0,x=v>>2&1,y=v>>3&1,z=m||o?1:0,B=0,C=0;n&&!o?(h=t+x,r=t+1-x,g.getBoxThree(h,q),l[h]=B=f.projectedBoxArea(q,c===A.CONTAINS),g.getBoxThree(r,q),l[r]=C=f.projectedBoxArea(q,c===A.CONTAINS),j[h]=j[r]=c,B>0&&a(h),C>0&&a(r)):(w^z^y&&(x=1-x),h=t+x,r=t+1-x,k[e++]=h,l[h]=-1,k[e++]=r,l[r]=-1,j[h]=j[r]=c)}if(0!==g.getPrimCount(b)){var D=i[b];return D.renderImportance=f.projectedBoxArea(D.boundingBox,c===A.CONTAINS),D}}o||p||d!==e||(k[e++]=1,o=!0)}return s=!0,null},this.skipOpaqueShapes=function(){o||p||(d=0,e=0,k[e++]=1,p=!0)},this.getVisibleBounds=function(a,c){for(var d=0;d<i.length;d++){var e=i[d];e&&(e.calculateBounds(),a.union(e.boundingBox),c.union(e.boundingBox),c.union(e.boundingBoxHidden))}b(0),b(1)},this.rayCast=function(a,b,c){for(var d=[1,0],e=new THREE.Vector3;d.length;){var f=d.pop();g.getBoxThree(f,q),q.expandByScalar(.5);if(null!==a.ray.intersectBox(q,e)){var h=g.getLeftChild(f);-1!==h&&(d.push(h),d.push(h+1));if(0!==g.getPrimCount(f)){i[f].raycast(a,b,c)}}}},this.getSceneCount=function(){return i.length},this.getGeomScenes=function(){return i},this.done=function(){return s}}function Xa(){function a(a,b){void 0===a.avgFrameTime?a.avgFrameTime=b:a.avgFrameTime=.8*a.avgFrameTime+.2*b}function b(b,c,d){var e,f;for(e=0;e<b.length;e++)f=b[e],f.cameraDistance=f.boundingBox.distanceToPoint(c.position);var g=function(a,b){return b.cameraDistance-a.cameraDistance};b.sort(g);var h=performance.now();for(e=0;e<b.length;e++){f=b[e],d(f);var i=performance.now(),j=i-h;h=i,a(f,j)}}var c=!1,d=!1,e=0,f=[],g=[],h=[],i=new THREE.Box3,j=[],k=new A,l=new THREE.Raycaster,m=performance,n=Kc;this.enableNonResumableFrames=!1,this.budgetForTransparent=.1;var o=!1,p=[],q=null;this.frustum=function(){return k},this.addModel=function(a){f.push(a),g.length=f.length,h.length=f.length},this.removeModel=function(a){var b=f.indexOf(a);return b>=0&&f.splice(b,1),g.length=f.length,h.length=f.length,b>=0},this.isEmpty=function(){return 0===f.length},this.needsRender=function(){return c},this.resetNeedsRender=function(){c=!1},this.frameResumePossible=function(){return!o},this.renderSome=function(i,j,k){for(var l,r,s=m.now(),t=0===e,u=this.budgetForTransparent*j;;){for(var v=0,w=null,x=0;x<g.length;x++){var y=g[x];r=f[x],y||(g[x]=y=r.nextBatch());if(o&&j<u){y&&!y.sortObjects&&(r.skipOpaqueShapes(),y=r.nextBatch())}null!==y&&(w||(v=x,w=y),y.renderImportance>w.renderImportance&&(v=x,w=y))}if(!w){d=!0;for(var z=0;z<f.length;++z)if((r=f[z])&&r.is2d()&&!r.isLoadDone()&&!r.getFragmentList().onDemandLoadingEnabled()){d=!1;break}break}if(f[v].is2d()&&f[v].getFragmentList()&&f[v].getFragmentList().onDemandLoadingEnabled()){var A=h[v];w.drawOrderRender=A&&A.drawOrderRender<A.lastItem?w.start:w.lastItem,h[v]=w}if(g[v]=f[v].nextBatch(),e++,w.sortObjects&&o)p.push(w),j-=void 0===w.avgFrameTime?.05:w.avgFrameTime;else{i(w),w.hasOwnProperty("drawEnd")&&(w.drawEnd=w.lastItem),l=m.now();var B=l-s;s=l,a(w,B),j-=w.avgFrameTime}if(f[v].getFragmentList()&&f[v].getFragmentList().onDemandLoadingEnabled())for(var C,D=w.start,E=w.lastItem,F=f[v].getFragmentList().vizflags,G=w.getIndices();D<E;)C=G?G[D]:D,F[C]&Rc&&(F[C]=(F[C]|Qc)&~Rc),++D;if(j<=0)break}var H=f[0].frameUpdatePaging(t,k);return(n!=H||f[0].needResumeNextFrame())&&(c=!0,n=H),p.length>0&&(b(p,q,i),p.length=0),j},this.reset=function(a,b,c){if(d=!1,e=0,this.resetNeedsRender(),k.reset(a),k.areaCullThreshold=Ic,f.length){o=this.enableNonResumableFrames&&c==Vc&&b===Lc,q=a;for(var i=0;i<f.length;i++)f[i].resetIterator(a,k,b,c),g[i]=f[i].nextBatch(),h[i]=null}},this.isDone=function(){return d||this.isEmpty()},this.setAllVisibility=function(a){for(var b=0;b<f.length;b++)f[b].setAllVisibility(a)},this.hideLines=function(a){for(var b=0;b<f.length;b++)f[b].hideLines(a)},this.hidePoints=function(a){for(var b=0;b<f.length;b++)f[b].hidePoints(a)},this.hasHighlighted=function(){for(var a=0;a<f.length;a++)if(f[a].hasHighlighted())return!0;return!1},this.areAllVisible=function(){for(var a=0;a<f.length;a++)if(!f[a].areAllVisible())return!1;return!0},this.invalidateVisibleBounds=function(){for(var a=0;a<f.length;a++)f[a].visibleBoundsDirty=!0},this.getVisibleBounds=function(a){if(1===f.length)return f[0].getVisibleBounds(a);i.makeEmpty();for(var b=0;b<f.length;b++)i.union(f[b].getVisibleBounds(a));return i},this.findModel=function(a){for(var b=0;b<f.length;b++)if(f[b].getModelId()===a)return f[b];return null},this.rayIntersect=function(a,b,c,d,e,g){l.set(a,b);var h;if(f.length>1){var i=[];if(e)for(h=0;h<e.length;h++){var j=this.findModel(e[h]);j&&j.rayIntersect(l,c,[d[h]])}else for(h=0;h<f.length;h++)if(!f[h].is2d()){var k=f[h].rayIntersect(l,c,d,g);k&&i.push(k)}return i.length?(i.sort(function(a,b){return a.distance-b.distance}),i[0]):null}return!f.length||f[0].is2d()?null:f[0].rayIntersect(l,c,d,g)},this.getRenderProgress=function(){return f[0].getRenderProgress()},this.getModels=function(){return f},this.getHiddenModels=function(){return j},this.getFragmentList=function(){return f[0].getFragmentList()},this.getGeometryList=function(){return f[0].getGeometryList()},this.getSceneCount=function(){return f[0].getSceneCount()},this.getGeomScenes=function(){return f[0].getGeomScenes()},this.geomPacksMissingLastFrame=function(){return f[0].geomPacksMissingLastFrame()},this.explode=function(a){if(f.length){for(var b=new THREE.Vector3,c=0;c<f.length;c++){var d=f[c],e=d.getData().instanceTree,g=d.getFragmentList(),h=d.getVisibleBounds(!0).center();if(a*=2,e&&e.nodeAccess.nodeBoxes&&0!==a){var i=a*(e.maxDepth-1)+1,j=0|i,k=i-j,l=new Float32Array(6);!function c(d,f,h,i,m,n,o,p){var q=2*a;f==j&&(q*=k),e.getNodeBox(d,l);var r=.5*(l[0]+l[3]),s=.5*(l[1]+l[4]),t=.5*(l[2]+l[5]);if(f>0&&f<=j){var u=(r-h)*q,v=(s-i)*q,w=(t-m)*q;n+=u,o+=v,p+=w}e.enumNodeChildren(d,function(a){c(a,f+1,r,s,t,n,o,p)},!1),b.x=n,b.y=o,b.z=p,e.enumNodeFragments(d,function(a){g.updateAnimTransform(a,null,null,b)},!1)}(e.getRootId(),0,h.x,h.y,h.x,0,0,0)}else for(var m=g.fragments.boxes,n=0,o=g.getCount();n<o;n++)if(0==a)g.updateAnimTransform(n);else{var p=6*n,q=.5*(m[p]+m[p+3]),r=.5*(m[p+1]+m[p+4]),s=.5*(m[p+2]+m[p+5]);b.x=a*(q-h.x),b.y=a*(r-h.y),b.z=a*(s-h.z),g.updateAnimTransform(n,null,null,b)}}this.invalidateVisibleBounds()}},this.update=function(a){for(var b=!1,c=0;c<f.length;c++){var d=f[c];b=b||d.update(a)}return b},this.hideModel=function(a){for(var b=0;b<f.length;b++){var c=f[b];if(c&&c.id===a)return this.removeModel(c),j.push(c),!0}return!1},this.showModel=function(a){for(var b=0;b<j.length;++b){var c=j[b];if(c&&c.id===a)return this.addModel(c),j.splice(b,1),!0}return!1},this.getMemoryInfo=function(){function a(a){for(var d=0;d<a.length;++d){var e=a[d].getMemoryInfo();e&&(b=e,c.limit+=e.limit,c.effectiveLimit+=e.effectiveLimit,c.loaded+=e.loaded)}}var b,c={limit:0,effectiveLimit:0,loaded:0};return a(f),a(j),b?c:null}}function Ya(b,c){this.model=b,this.fragments=b.getData().fragments,this.geoms=b.getGeometryList(),this.pagingProxy=c,this.isFixedSize=this.fragments.length>0,this.isFixedSize?(this.boxes=this.fragments.boxes,this.transforms=this.fragments.transforms,this.useThreeMesh=!a.memoryOptimizedLoading):(this.boxes=null,this.transforms=null,this.useThreeMesh=!c||!c.onDemandLoadingEnabled());var d=this.fragments.length;this.vizflags=new Uint16Array(d),this.useThreeMesh&&(this.vizmeshes=new Array(d)),this.geomids=new Int32Array(d),this.materialids=new Int32Array(d),this.materialmap={},this.db2ThemingColor=[],this.originalColors=[],this.themingOrGhostingNeedsUpdate=[],this.dbIdIsHidden=[],this.dbIdIsGhosted=[],this.reachLimit=!1,this.animxforms=null;for(var e=0;e<d;e++)this.vizflags[e]=1,this.geomids[e]=-1;this.allVisible=!0,this.allVisibleDirty=!1,this.nextAvailableFragID=d,this.boxTransform=[],this.boxCount=0}function Za(a){var b=a.r;return a.r=a.b,a.b=b,a}function $a(a,b){var c=a.originalColors[b];if(a.themingOrGhostingNeedsUpdate[b]){var d=a.getGeometry(b),e=d?d.attributes:null,f=e?e.color4b:null,g=e?e.dbId4b:null,h=e?e.layerVp4b:null,i=e?e.flags4b:null;if(f&&g&&d.vb&&h&&i){for(var j=new Uint32Array(d.vb.buffer),k=d.vbstride,l=j.length/d.vbstride,m=!1,n=f.itemOffset,o=g.itemOffset,p=h.itemOffset,q=i.itemOffset,r=0;r<l;r++){var s=j[r*k+o],t=c?c[r]:j[r*k+n],u=j[r*k+p];s=s<<8>>8;var v=-1==s&&0==(u&parseInt("FFFF",16)),w=a.db2ThemingColor[s],x=a.dbIdIsHidden[s];if(w||x){if(!c){c=new Uint32Array(l);for(var y=0;y<l;y++)c[y]=j[y*k+n];a.originalColors[b]=c}t=x?0:Ce(t,w),m=!0}else c&&(t=c[r]);j[r*k+n]=t;var z=a.dbIdIsGhosted[s]&&!v,A=j[r*k+q];z?A|=255<<24:A&=16777215,j[r*k+q]=A}m||(a.originalColors[b]=null),d.vbNeedsUpdate=!0,a.themingOrGhostingNeedsUpdate[b]=!1}}}function _a(a,b){if(a.model.is2d()){var c=a.fragments.dbId2fragId[b];if(Array.isArray(c))for(var d=0;d<c.length;d++)a.themingOrGhostingNeedsUpdate[c[d]]=!0;else"number"==typeof c&&(a.themingOrGhostingNeedsUpdate[c]=!0)}}function ab(a,b){this.frags=a,this.fragId=b,this.scale=null,this.quaternion=null,this.position=null}function bb(a,b,c){if(a){if(a-3*b*2<=Gc&&c<Hc)return!1}return!0}function cb(a){function b(a){var b=c.getFragmentList().fragments.packIds[a];i.pagingProxy&&i.pagingProxy.addGeomPackMissingLastFrame(b)}var c=this,d=new THREE.Box3,e=new THREE.Box3,f=new THREE.Box3;this.visibleBoundsDirty=!1,this.enforceBvh=!1,this.isvizCacheEnabled=!1;var g=0;this.id=Ee++;var h=null,i=null,j=null,k=null,l=null,m=null,n=null,o=0,p=null,q=Lc,r=Fe[Lc],s=!1,t=Kc;this.getData=function(){return a},this.getGeometryList=function(){return h},this.getFragmentList=function(){return i},this.getModelId=function(){return this.id},this.initialize=function(a){var b=this.getData(),c=b.numGeoms||0,f=!bb(b.packFileTotalSize,b.primitiveCount,c);h=new z(c,this.is2d(),f),i=new Ya(this,a);var g=this.getBoundingBox();g&&(d.copy(g),e.copy(g)),l=j=new Oa(this)},this.initFromCustomIterator=function(a){l=a,this.visibleBoundsDirty=!0},this.dtor=function(a){i&&i.dispose(a),l&&l.dtor&&l.dtor(),m&&m.dispose()},this.activateFragment=function(a,b,c){i&&(i.setMesh(a,b,c),l.addFragment(a),i.getWorldBounds(a,f),d.union(f),e.union(f))},this.setFragment=function(a,b){return void 0===a&&(a=this.getFragmentList().getNextAvailableFragmentId()),i.setMesh(a,b,!0),j&&j.addFragment(a),k&&!i.fragmentsHaveBeenAdded()&&k.addFragment(a),i.getWorldBounds(a,f),d.union(f),e.union(f),a},this.setBVH=function(a,b,c){l=k=new Wa,l.initialize(this,a,b,c)},this.resetIterator=function(a,b,c,d){if(d=d||Tc,i&&i.pagingProxy&&i.pagingProxy.resetIterator(a,d),d!=Tc&&(d>=Uc&&i&&i.onDemandLoadingEnabled()&&i.setFlagGlobal(Qc,!1),d>=Vc&&i&&i.pageOutGeometryEnabled())){t=Kc,i.pagingProxy&&i.pagingProxy.reset();var e,f,g=l.getGeomScenes();for(f=g.length,e=0;e<f;e++){var h=g[e];h&&h.resetVisStatus&&h.resetVisStatus()}}return s=!1,k&&!i.fragmentsHaveBeenAdded()&&(s=!0),this.isvizCacheEnabled&&(s=!1),s?l=k:j&&(l=j),o=0,q=c,r=c<Fe.length?Fe[c]:Fe[Lc],p=b,l.reset(b,a),i&&i.resetBoxRun(),m&&m.reset(),l},this.nextBatch=function(){for(;;){var a=l.nextBatch();if(o++,!a)return null;if(m&&a instanceof C&&(a=m.consolidateNextBatch(a,p)),a instanceof THREE.Scene)return a;if(a.visibleStats&r)c=!(a.visibleStats&r<<16);else{var c=a.applyVisibility(q,p,this.getFragmentList().fragments.packIds?b:function(){});void 0!==a.visibleStats&&(a.visibleStats|=r,c||(a.visibleStats|=r<<16)),c||this.is2d()||(a.sortObjects&&!this.getFragmentList().useThreeMesh?a.sortByDepth(p):a.sortDone||a.sortByMaterial())}if(!c)return a}},this.getVisibleBounds=function(a){return this.visibleBoundsDirty&&(d.makeEmpty(),e.makeEmpty(),l.getVisibleBounds(d,e,a),this.visibleBoundsDirty=!1),a?e:d},this.rayIntersect=function(a,b,c,d){this.visibleBoundsDirty&&this.getVisibleBounds();var e,f=[];if(c&&c.length>0){var g=this.getFragmentMap(),h=[];if(g)for(e=0;e<c.length;e++)g.enumNodeFragments(c[e],function(a){h.push(a)},!0);else h=c;if(h.length>2)l.rayCast(a,f,c);else for(e=0;e<h.length;e++){var j=i.getVizmesh(h[e]);if(j){var k=vd.rayCast(j,a,f);k&&f.push(k)}}}else l.rayCast(a,f);if(!f.length)return null;f.sort(function(a,b){return a.distance-b.distance});var m=!!d;for(d=d||[],e=0;e<f.length;e++){var n=f[e].fragId;if(!this.is2d()){if(this.isFragVisible(n)){var o=i.getMaterial(n);if(b&&o.transparent)continue;var p=f[e],q=!1,r=p.point;if(o&&o.cutplanes)for(var s=0;s<o.cutplanes.length;s++)q=q||o.cutplanes[s].dot(new THREE.Vector4(r.x,r.y,r.z,1))>1e-6;if(q||d.push(p),p.model=this,!m&&d.length>0)break}}}var t=d[0]||null;return t&&(t.model=this),t},this.setHighlighted=function(a,b){if(!i)return!1;var c=i.setFlagFragment(a,Nc,b);return c&&(b?g++:g--),c},this.setVisibility=function(a,b){i&&(i.setVisibility(a,b),this.visibleBoundsDirty=!0)},this.setAllVisibility=function(a){i&&(i.setAllVisibility(a),this.visibleBoundsDirty=!0)},this.hideLines=function(a){i&&i.hideLines(a)},this.hidePoints=function(a){i&&i.hidePoints(a)},this.hasHighlighted=function(){return!!g},this.isFragVisible=function(a){return i.isFragVisible(a)},this.areAllVisible=function(){return!i||i.areAllVisible()},this.getGeomScenes=function(){return l.getGeomScenes()},this.getRenderProgress=function(){var a=o/l.getSceneCount();return a>1?1:a},this.pageOutIfNeeded=function(a,b,c){return i.pagingProxy?i.pagingProxy.pageOut(a,b,c):Kc},this.frameUpdatePaging=function(a,b){return i&&i.pageOutGeometryEnabled()?(t=this.pageOutIfNeeded(!1,!1,b),l.done()&&(t=this.pageOutIfNeeded(!0,!1,b))==Jc&&(t=this.pageOutIfNeeded(!0,!0,b)),t):t},this.geomPacksMissingLastFrame=function(){return i&&i.pagingProxy?i.pagingProxy.geomPacksMissingLastFrame():[]},this.addGeomPackMissingLastFrame=function(a){return!i||!i.pagingProxy||i.pagingProxy.addGeomPackMissingLastFrame(a)},this.needResumeNextFrame=function(){return!(!i||!i.pagingProxy)&&i.pagingProxy.needResumeNextFrame()},this.update=function(a){return!(!l||!l.update)&&l.update(a)},this.setThemingColor=function(a,b){i?i.setThemingColor(a,b):THREE.warn("Theming colors are not supported by this model type.")},this.clearThemingColors=function(){i&&i.clearThemingColors()},this.getLeaflet=function(){return l instanceof ModelIteratorTexQuad?l:null},this.consolidate=function(a,b,c){var d=Ua(i,a,b,c,n);m=new Va(i,d),n=d.consolidationMap},this.unconsolidate=function(){m&&(m.dispose(),m=null)},
this.isConsolidated=function(){return!!m},this.getConsolidation=function(){return m?m.getConsolidation():null},this.getFragmentMap=function(){return a?a.instanceTree||a.fragmentMap:null},this.getBoundingBox=function(){return a?a.bbox:null},this.is2d=function(){return!!(a&a.is2d)},this.updateRenderProxy=function(a,b){m&&m.updateRenderProxy(a,b)},this.skipOpaqueShapes=function(){l&&l.skipOpaqueShapes&&l.skipOpaqueShapes()},this.getMemoryInfo=function(){return i.getMemoryInfo()}}function db(a,b,c){this.level=a,this.x=b,this.y=c}function eb(a,b,c){var d=a.clone();return d.max(b),d.min(c),d.distanceToSquared(a)}function fb(a,b,c,d){var e=a.clone();return e.max(c),e.min(d),e.sub(a).dot(b)}function gb(){function a(a,b,c){var d=Math.ceil(Math.log2(a)),e=Math.ceil(Math.log2(b));return Math.max(d,e)-Math.log2(c)}function b(a,b,c){var d=b-c;d>0&&(a.texWidth>>=d,a.texHeight>>=d,a.maxLevel=c)}this.urlPattern=null,this.tileSize=null,this.maxLevel=null,this.textureLoader=null,this.texWidth=0,this.texHeight=0,this.maxActiveTiles=wc()?0:400,this.cacheSize=wc()?0:150,this.onRootLoaded=null,this.levelOffset=0,this.pixelRatio=1,this.getRootTileSize=function(){return 1*(this.tileSize<<this.maxLevel)},this.getQuadWidth=function(){return 1*this.texWidth/this.getRootTileSize()},this.getQuadHeight=function(){return 1*this.texHeight/this.getRootTileSize()},this.getPageToModelTransform=function(a,b){var c=a/this.getQuadWidth(),d=b/this.getQuadHeight();return new We(!0).set(c,0,0,0,0,d,0,0,0,0,1,0,0,0,0,1)},this.getBBox=function(){var a=this.getQuadWidth(),b=this.getQuadHeight(),c=1-b;return new THREE.Box3(new THREE.Vector3(0,c,0),new THREE.Vector3(a,1,0))},this.valid=function(){return"string"==typeof this.urlPattern&&this.urlPattern.length>0&&"number"==typeof this.tileSize&&this.tileSize>0&&"number"==typeof this.maxLevel&&this.maxLevel>0&&"number"==typeof this.texWidth&&this.texWidth>0&&"number"==typeof this.texHeight&&this.texHeight>0},this.initForSimpleImage=function(a,b){this.urlPattern=decodeURIComponent(a),this.maxLevel=0,this.levelOffset=0,this.tileSize=-1,this.texWidth=-1,this.texHeight=-1,this.onRootLoaded=b},this.initFromLoadOptions=function(c,d,e){this.urlPattern=decodeURIComponent(c),this.textureLoader=e,d&&(this.tileSize=d.tileSize,this.maxLevel=a(d.texWidth,d.texHeight,d.tileSize),this.texWidth=d.texWidth,this.texHeight=d.texHeight,this.levelOffset=d.levelOffset,"number"==typeof d.maxLevel&&b(this,this.maxLevel,d.maxLevel),this.maxActiveTiles=d.maxActiveTiles||this.maxActiveTiles,this.cacheSize=d.cacheSize||this.cacheSize)}}function hb(a,b){function c(a){var b=D.maxLevel-a;return D.texWidth>>b}function d(a){var b=D.maxLevel-a;return D.texHeight>>b}function e(a){var b=c(a.level),e=d(a.level),f=a.x*D.tileSize,g=a.y*D.tileSize;return f>=b||g>=e}function f(a){var b=c(a.level),e=d(a.level),f=a.x*D.tileSize,g=a.y*D.tileSize,h=1*Math.max(0,Math.min(D.tileSize,b-f)),i=1*Math.max(0,Math.min(D.tileSize,e-g)),j=1*D.tileSize;return new THREE.Vector2(1*h/j,i/j)}function g(a){return 1/(1<<a)}function h(){this.offsetX=0,this.offsetY=0,this.scaleX=1,this.scaleY=1}function i(a,b){var c=a.level-b.level,d=1<<c,e=1/d,g=e,i=f(b);e/=i.x,g/=i.y;var j=b.x*d,k=b.y*d,l=a.x-j,m=a.y-k,n=f(a);l*=e,m*=g,m=1-m-g*n.y;var o=new h;return o.offsetX=l,o.offsetY=m,o.scaleX=e*n.x,o.scaleY=g*n.y,o}function j(a){return g(a.level)*a.x}function k(a){return g(a.level)*((1<<a.level)-1-a.y)}function l(a){return I[Xe.tile2Index(a)]}function m(a){var b=l(a);return b instanceof _e&&b.state==$e}function n(a,b){for(var c=a.getParent();c;){var d=l(c),e=d&&d.state==$e;if(e&&b&&d.mesh.material.map.needsUpdate&&c.level>0&&(e=!1),e)break;c=c.getParent()}return c}function o(a,b){var c=b||S,d=[];d.push(new THREE.Vector2(c.offsetX,c.offsetY)),d.push(new THREE.Vector2(c.offsetX+c.scaleX,c.offsetY)),d.push(new THREE.Vector2(c.offsetX+c.scaleX,c.offsetY+c.scaleY)),d.push(new THREE.Vector2(c.offsetX,c.offsetY+c.scaleY)),a.faceVertexUvs[0].length=0,a.faceVertexUvs[0].push([d[0],d[1],d[2]]),a.faceVertexUvs[0].push([d[0],d[2],d[3]]),a.uvsNeedUpdate=!0}function p(a){var b=new THREE.Geometry;return b.vertices.push(new THREE.Vector3(0,0,0),new THREE.Vector3(1,0,0),new THREE.Vector3(1,1,0),new THREE.Vector3(0,1,0)),b.faces.push(new THREE.Face3(0,1,2)),b.faces.push(new THREE.Face3(0,2,3)),o(b,a),b.computeFaceNormals(),b}function q(a){var b=Q[R];return b?o(b,a):(b=p(a),Q[R]=b),R++,b}function r(a,b,c){var d;if(b)P||(P=p()),d=P;else{var e=n(a);b=u(e).material;d=q(i(a,e,c))}var h=new THREE.Mesh(d,b),l=g(a.level),m=f(a),o=(1-m.y)*l,r=j(a),s=k(a);return h.position.set(r,s+o,0),h.scale.set(l*m.x,l*m.y,1),h}function s(a){var b=D.levelOffset?D.levelOffset:0;return D.urlPattern.replace("{x}",a.x).replace("{y}",a.y).replace("{z}",a.level+b)}function t(b){var c=Xe.tile2Index(b),d=I[c];if(!d||d.state==Ye){d||(d=new _e(J),I[c]=d),d.state=Ze;var e=s(b),f=function(c){if(T){0==D.maxLevel&&(-1==D.texWidth&&(D.texWidth=c.image.width),-1==D.texHeight&&(D.texHeight=c.image.height),-1==D.tileSize&&(D.tileSize=Math.max(c.image.width,c.image.height)),E=a.getBBox()),c.minFilter=THREE.LinearFilter,c.magFilter=THREE.LinearFilter;var f=new THREE.MeshBasicMaterial({color:4294967295});f.map=c,f.name=e,f.disableEnvMap=!0,e.toLowerCase().indexOf(".png")&&(f.transparent=!0,f.alphaTest=.01),G.addMaterial(f.name,f,!0);var g=r(b,f);d.mesh=g,d.state=$e,M--,N=!0;var h=c&&c.image?c.image.src:null;h&&THREE.Cache&&THREE.Cache.get(h)&&THREE.Cache.remove(h),0==b.level&&D.onRootLoaded&&D.onRootLoaded()}};M++,D.textureLoader(e,function(a){f(a)},function(a){console.error(a)})}}function u(a){var b=Xe.tile2Index(a),c=I[b];return c&&c.state==$e?c.mesh:null}function v(a,b){var c=j(a),d=k(a);b.set(c,d,0)}function w(a,b){var c=g(a.level),d=j(a)+c,e=k(a)+c;b.set(d,e,0)}function x(a,b){this.tile=a,this.prio=b}function y(a,b){return a.prio>b.prio}function z(a){var b=I[Xe.tile2Index(a)];b&&b.timeStamp!=J&&(b.timeStamp=J,K++)}function A(a,b,c){a.sort(function(a,d){var e=V(a,b,c);return V(d,b,c)-e});for(var d=0,e=0;e<a.length;e++){var f=l(a[e]);if(!f||f.state!=Ze){if(M>=L)break;t(a[e]),d++}}return d}function B(a){if(a&&a.mesh&&a.mesh.material){var b=a.mesh.material;G.removeMaterial(b.name),b.map.dispose(),b.map.needsUpdate=!0;var c={type:"dispose"};b.dispatchEvent(c),b.needsUpdate=!0}}function C(a,b,c){var d=Object.keys(I),e=d.length,f=D.cacheSize-e,g=a-f;if(!(g<=0)){d.sort(function(a,d){var e=I[a].timeStamp,f=I[d].timeStamp;if(e!=f)return e-f;var g=Xe.index2Tile(a),h=Xe.index2Tile(d);return V(g,b,c)-V(h,b,c)});for(var h=Math.min(g,d.length),i=0;i<h;i++){var j=d[i];if(0!==Xe.index2Tile(j).level&&I[j].state==$e){if(I[j].timeStamp==J)break;B(I[j]),delete I[j]}}}}var D=a,E=a.getBBox(),F=new THREE.Scene,G=b,H=!0,I=[],J=0,K=0,L=5,M=0,N=!1,O=[],P=null,Q=[],R=0;this.nextBatch=function(){return H?null:(H=!0,F)},this.getSceneCount=function(){return 1},this.done=function(){return H},this.rayCast=function(a,b){return null},this.getVisibleBounds=function(a,b){a&&a.copy(E),b&&b.copy(E)};var S=new h,T=this;t(new Xe.TileCoords(0,0,0));var U=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Box3;return function(d,e){return v(d,a),w(d,b),c.set(a,b),e.intersectsBox(c)>0}}(),V=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){var f=g(c.level);v(c,a),w(c,b);var h=eb(e,a,b),i=U(c,d),j=i?100:1;return h=Math.max(h,1e-4),j*(f*f)/h}}(),W=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e,f,g){v(c,a),w(c,b);var h=fb(d,e,a,b);return(b.x-a.x)/(Math.tan(THREE.Math.degToRad(f/2))*h)*.5*g}}();this.dispose=function(){var a;for(a in I)B(I[a]);for(P&&(P.dispose(),P.needsUpdate=!0),a=0;a<Q.length;a++){var b=Q[a];b&&(b.dispose(),b.needsUpdate=!0)}},this.dtor=function(){this.dispose(),T=null,G=null},this.reset=function(a,b){var c,d;for(c=0;c<F.children.length;c++){F.children[c].dispatchEvent({type:"removed"})}if(F.children.length=0,J++,K=0,R=0,!m(new Xe.TileCoords(0,0,0)))return void(H=!0);var f=new Be(y),g=new Xe.TileCoords(0,0,0),h=V(g,a,b.position);f.add(new x(g,h));for(var i=b.getWorldDirection(),j=0|b.clientHeight*D.pixelRatio,k=[],l=[],n=[];f.size()>0;){if(d=f.get(0).tile,f.removeAt(0),!e(d)){var o=!0;d.level==D.maxLevel&&(o=!1);W(d,b.position,i,b.fov,j)<D.tileSize&&(o=!1);var p=U(d,a);if(p&&(m(d)||n.push(d),z(d)),!p&&k.length+l.length>D.maxActiveTiles&&(o=!1),o)for(var q=0;q<4;q++){var s=d.getChild(q);h=V(s,a,b.position),f.add(new x(s,h))}else p?k.push(d):l.push(d)}}var t=0;N=!1;var v=!0;for(c=0;c<k.length;++c){d=k[c];var w=u(d);w&&w.material.map.needsUpdate&&(t<5?t++:(w=r(d,null,!0),N=!0,v=!1)),w||(w=r(d,null),v=!1),F.add(w)}H=!1;var B=A(n,a,b.position);K+=M;var E=[];for(c=0;c<l.length&&!(K>=D.maxActiveTiles);c++)if(d=l[c],m(d))for(var G=0;G<=d.level;G++){var I=d.getParentAtLevel(G);if(z(I),K>D.maxActiveTiles)break}else E.push(d),K++;if(B+=A(E,a,b.position),C(B,a,b.position),v&&O.length>0){var L=O.splice(0,O.length);setTimeout(function(){for(var a=0;a<L.length;a++)L[a]()},1)}},this.callWhenRefined=function(a){O.push(a)},this.update=function(){return N}}function ib(a,b,c){this.nodeAccess=a,this.maxDepth=c,this.objectCount=b,this.numHidden=0,this.numOff=0}function jb(a){this.numOffs=0,this.numHidden=0;var b,c={};!function(a){function d(b){for(var c=0,d=a.length;c<d;c++){var e=a[c];Array.isArray(e)||(g[0]=e,e=g);for(var f=0;f<e.length;f++)b(c,e[f])}}var e=0,f=[],g=[0];d(function(a,b){var d=c[b];void 0===d&&(c[b]=d=f.length,f.push(0),f.push(0)),++f[d],++e}),b=new Uint32Array(e+f.length/2),b.fill(0);var h,i,j=0;for(h in c){i=c[h];var k=f[i],l=j+k+1;b[j]=k,f[i]=f[i+1]=j,j=l}var m=!1;d(function(a,d){var e=c[d],g=f[e+1]+1;g>b.length||b[g]?m||(console.error("DbidFragmentMap.buildMap: Internal error fragment overlap"),m=!0):(b[g]=a,f[e+1]=g)}),m=!1;for(h in c){i=c[h];var n=f[i+1]+1;n<b.length&&!b[n]&&(m||(console.error("DbidFragmentMap.buildMap: Internal error fragment underfilled"),m=!0))}for(h in c)i=c[h],c[h]=f[i]}(a),this.setFlagNode=function(a,d,e){if(!c.hasOwnProperty(a))return!1;var f=c[a];return!!(b[f]&d)!=e&&(e?b[f]|=d:b[f]&=~d,!0)},this.setNodeOff=function(a,b){var c=this.setFlagNode(a,cf,b);return c&&(b?this.numOff++:this.numOff--),c},this.isNodeOff=function(a){var d=c[a];return!!(b[d]&cf)},this.setNodeHidden=function(a,b){var c=this.setFlagNode(a,df,b);return c&&(b?this.numHidden++:this.numHidden--),c},this.isNodeHidden=function(a){var d=c[a];return!!(b[d]&df)},this.getRootId=function(){return ff},this.enumNodeFragments=function(a,d){var e;"number"==typeof a?e=a:a&&(e=a.dbId);for(var f=c[e],g=(b[f]&ef)+f+1;++f<g;)d(b[f],e)},this.enumNodeChildren=function(a,b,d){if(d&&b(a),a==ff)for(var e in c)b(Number(e))}}function kb(a,b){this.nodes=[],this.nextNode=0,this.children=[],this.nextChild=0,this.dbIdToIndex={},this.names=[],this.s2i={},this.strings=[],this.nameSuffixes=[],this.getIndex(0)}function lb(a){var b=new Int32Array(a.length);return b.set(a),b}function mb(a,b,c){this.nodes=a.nodes,this.children=a.children,this.dbIdToIndex=a.dbIdToIndex,this.names=a.names,this.nameSuffixes=a.nameSuffixes,this.strings=a.strings,this.rootId=b,this.numNodes=this.nodes.length/gf,this.visibleIds=null,this.nodeBoxes=c||new Float32Array(6*this.numNodes)}function nb(a,b){this.bytes_per_node=b?32:36;var c,d;a instanceof ArrayBuffer?(c=a.byteLength/this.bytes_per_node,d=a,this.nodeCount=c):(c=0|a,d=new ArrayBuffer(this.bytes_per_node*c),this.nodeCount=0),this.nodeCapacity=c,this.nodesRaw=d,this.is_lean_node=b,this.node_stride=this.bytes_per_node/4,this.node_stride_short=this.bytes_per_node/2,this.nodesF=new Float32Array(this.nodesRaw),this.nodesI=new Int32Array(this.nodesRaw),this.nodesS=new Uint16Array(this.nodesRaw)}function ob(a,b){this.boxes=a.boxes,this.polygonCounts=a.polygonCounts,this.hasPolygonCounts=!!this.polygonCounts,this.materials=a.materials,this.materialDefs=b,this.count=a.length,this.boxStride=6}function pb(a,b,c){this.finfo=c||new ob(a,b),this.prim_count=this.finfo.getCount(),this.frags_per_leaf_node=-1,this.frags_per_inner_node=-1,this.nodes=null,this.work_buf=new ArrayBuffer(4*this.prim_count),this.sort_prims=new Int32Array(this.work_buf),this.primitives=new Int32Array(this.prim_count),this.centroids=new Float32Array(hf*this.prim_count),this.boxv_o=new Float32Array(6),this.boxc_o=new Float32Array(6),this.boxv_t=new Float32Array(6),this.boxc_t=new Float32Array(6),this.recursion_stack=[]}ArrayBuffer.prototype.slice||(ArrayBuffer.prototype.slice=function(a,b){if(!b||b>this.byteLength?b=this.byteLength:b<0&&(b=this.byteLength+b)<0&&(b=0),a<0&&(a=this.byteLength+a)<0&&(a=0),b<=a)return new ArrayBuffer(0);for(var c=b-a,d=new Uint8Array(this,a,c),e=new Uint8Array(c),f=0;f<c;f++)e[f]=d[f];return e.buffer}),function(){Math.log2=Math.log2||function(a){return Math.log(a)/Math.LN2}}(),function(){var a=d();a.performance||(a.performance=Date)}(),Number.isInteger=Number.isInteger||function(a){return"number"==typeof a&&isFinite(a)&&Math.floor(a)===a},Array.prototype.fill=Array.prototype.fill||function(a,b,c){b=void 0===b?0:b,c=void 0===c?this.length:c;for(var d=b;d<c;++d)this[d]=a;return this},Int32Array.prototype.lastIndexOf=Int32Array.prototype.lastIndexOf||function(a,b){return Array.prototype.lastIndexOf.call(this,a,b)};var qb=function(){for(var a,b=this.length,c=Math.ceil(b/2),d=0,e=b;--e>=c;++d)a=this[d],this[d]=this[e],this[e]=a;return this};Uint32Array.prototype.reverse=Int32Array.prototype.reverse||qb,Uint16Array.prototype.reverse=Int16Array.prototype.reverse||qb;var rb={uniforms:{color1:{type:"v3",value:new THREE.Vector3(41/255,76/255,120/255)},color2:{type:"v3",value:new THREE.Vector3(1/255,2/255,3/255)},envMap:{type:"t",value:null},envRotationSin:{type:"f",value:0},envRotationCos:{type:"f",value:1},exposureBias:{type:"f",value:1},envMapExposure:{type:"f",value:1},uCamDir:{type:"v3",value:new THREE.Vector3},uCamUp:{type:"v3",value:new THREE.Vector3},uResolution:{type:"v2",value:new THREE.Vector2(600,400)},uHalfFovTan:{type:"f",value:.5},envMapBackground:{type:"i",value:0}},vertexShader:"uniform vec3 color1;\nuniform vec3 color2;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n    if (uv.y == 0.0)\n        vColor = color2;\n    else\n        vColor = color1;\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",fragmentShader:"varying vec3 vColor;\nvarying vec2 vUv;\nuniform samplerCube envMap;\nuniform vec3 uCamDir;\nuniform vec3 uCamUp;\nuniform vec2 uResolution;\nuniform float uHalfFovTan;\nuniform bool envMapBackground;\n#include<env_sample>\nconst int bloomRange = 4;\n#include<ordered_dither>\nuniform float envMapExposure;\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\n#include<tonemap>\n#endif\nvec3 rayDir(in vec2 vUv) {\n    vec3 A = (uResolution.x/uResolution.y)*normalize(cross(uCamDir,uCamUp)) * (uHalfFovTan * 2.0);\n    vec3 B = normalize(uCamUp) * (uHalfFovTan * 2.0);\n    vec3 C = normalize(uCamDir);\n    vec3 ray = normalize( C + (2.0*vUv.x-1.0)*A + (2.0*vUv.y-1.0)*B );\n    return ray;\n}\nvec3 getColor(in vec3 rd) {\n    return RGBMDecode(textureCube(envMap, adjustLookupVector(rd)), envMapExposure);\n}\nvoid main() {\n    vec3 rd = rayDir(vUv);\n    vec3 outColor;\n    if (envMapBackground) {\n        outColor = getColor(rd);\n#if TONEMAP_OUTPUT == 1\n        outColor = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * outColor);\n#elif TONEMAP_OUTPUT == 2\n        outColor = toneMapCanonFilmic_WithGamma(exposureBias * outColor);\n#endif\n    }\n    else {\n        outColor = vColor;\n    }\n    gl_FragColor = vec4(orderedDithering(outColor), 1.0);\n}\n"},sb={cutplanes:{type:"v4v",value:[]},hatchParams:{type:"v2",value:new THREE.Vector2(1,10)},hatchTintColor:{type:"c",value:new THREE.Color(16777215)},hatchTintIntensity:{type:"f",value:1}},tb={dbId:{type:"v3",value:new THREE.Vector3(0,0,0)},modelId:{type:"v3",value:new THREE.Vector3(0,0,0)}},ub={themingColor:{type:"v4",value:new THREE.Vector4(0,0,0,0)}},vb={shadowESMConstant:{type:"f",value:0}},wb=THREE.UniformsUtils.merge([{shadowMap:{type:"t",value:null},shadowMapSize:{type:"v2",value:new THREE.Vector2(0,0)},shadowBias:{type:"f",value:0},shadowDarkness:{type:"f",value:0},shadowMatrix:{type:"m4",value:new THREE.Matrix4},shadowLightDir:{type:"v3",value:new THREE.Vector3}},vb]),xb={point_size:{type:"f",value:1}},yb={view_size:{type:"v2",value:new THREE.Vector2(640,480)}},zb={tDepth:{type:"t",value:null},projInfo:{type:"v4",value:new THREE.Vector4},isOrtho:{type:"f",value:0},worldMatrix_mainPass:{type:"m4",value:THREE.Matrix4()}},Ab={};for(var Bb in THREE.ShaderChunk)Ab[Bb]=THREE.ShaderChunk[Bb];Ab.pack_depth="\nvec4 packDepth( const in float depth ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n",Ab.depth_texture="\nuniform sampler2D tDepth;\nuniform vec4 projInfo;\nuniform float isOrtho;\nuniform mat4 worldMatrix_mainPass;\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\n    float zCam = texture2D(tDepth, screenUv).z;\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\n}\n",Ab.tonemap="\nfloat luminance_post(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\n    vec3 rgb;\n    rgb.b = dot(xyz, B);\n    rgb.g = dot(xyz, G);\n    rgb.r = dot(xyz, R);\n    return rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\n    vec3 xyz;\n    xyz.x = dot(rgb, X);\n    xyz.y = dot(rgb, Y);\n    xyz.z = dot(rgb, Z);\n    return xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    sum = 1.0 / sum;\n    vec3 xyY;\n    xyY.z = xyz.y;\n    xyY.x = xyz.x * sum;\n    xyY.y = xyz.y * sum;\n    return xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\n    float x = xyY.x;\n    float y = xyY.y;\n    float Y = xyY.z;\n    vec3 xyz;\n    xyz.y = Y;\n    xyz.x = x * (Y / y);\n    xyz.z = (1.0 - x - y) * (Y / y);\n    return xyz;\n}\nfloat toneMapCanon_T(float x)\n{\n    float xpow = pow(x, 1.60525727);\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\n    return clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\n    x *= Shift;\n    const float A = 0.2;\n    const float B = 0.34;\n    const float C = 0.002;\n    const float D = 1.68;\n    const float E = 0.0005;\n    const float F = 0.252;\n    const float scale = 1.0/0.833837;\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\n    x *= Shift;\n    const float A = 0.27;\n    const float B = 0.29;\n    const float C = 0.052;\n    const float D = 0.2;\n    const float F = 0.18;\n    const float scale = 1.0/0.897105;\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\n    vec3 outColor = x.rgb;\n    outColor = min(outColor, vec3(3.0));\n    float inLum = luminance_pre(outColor);\n    if (inLum > 0.0) {\n        float outLum = toneMapCanon_T(inLum);\n        outColor = outColor * (outLum / inLum);\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\n    }\n    float gamma = 1.0/2.2;\n    outColor = pow(outColor, vec3(gamma));\n    return outColor;\n}\n",Ab.ordered_dither="vec3 orderedDithering(vec3 col) {\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\n    vec4 biasRow;\n    if      (i==0) biasRow = m0;\n    else if (i==1) biasRow = m1;\n    else if (i==2) biasRow = m2;\n    else           biasRow = m3;\n    float bias;\n    if      (j==0) bias = biasRow.x;\n    else if (j==1) bias = biasRow.y;\n    else if (j==2) bias = biasRow.z;\n    else           bias = biasRow.w;\n    return col + bias / 17.0 / 256.0;\n}\n",Ab.cutplanes="#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\nvoid checkCutPlanes(vec3 worldPosition) {\n    for (int i=0; i<NUM_CUTPLANES; i++) {\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\n            discard;\n        }\n    }\n}\n#endif\n",Ab.pack_normals="\n#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n) {\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc) {\n    vec2 ang = enc * 2.0 - 1.0;\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}\n",Ab.hatch_pattern="#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nuniform vec3 hatchTintColor;\nuniform float hatchTintIntensity;\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 3.5;\n    return exp(-exponent*exponent);\n}\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\n    float hatchSlope = hatchParams.x;\n    float hatchPeriod = hatchParams.y;\n    if (abs(hatchSlope) <= 1.0) {\n        float hatchPhase = coord.y - hatchSlope * coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    } else {\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    }\n    return fragColor;\n}\n#endif\n",Ab.env_sample="\nuniform float envRotationSin;\nuniform float envRotationCos;\nvec3 adjustLookupVector(in vec3 lookup) {\n    return vec3(\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\n            lookup.y,\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\n}\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    ret *= exposure;\n    return ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\n    return vRGBA.xyz * vRGBA.xyz * exposure;\n}\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\n#ifdef IRR_GAMMA\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\n#elif defined(IRR_RGBM)\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\n#else\n    vec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\n    return indirectDiffuse;\n}\n",Ab.id_decl_vert="#ifdef USE_VERTEX_ID\nattribute vec3 id;\nvarying   vec3 vId;\n#endif\n",Ab.id_vert="\n#ifdef USE_VERTEX_ID\nvId = id;\n#endif\n",Ab.id_decl_frag="#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\nvarying highp float depth;\n#define gl_FragColor gl_FragData[0]\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\n#ifdef USE_VERTEX_ID\nvarying vec3 vId;\n#else\nuniform vec3 dbId;\n#endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\nuniform vec3 modelId;\n#endif\n",Ab.id_frag="\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\nvec3 dbId = vId;\n#endif\n#ifdef MRT_ID_BUFFER\n#ifdef MRT_NORMALS\nconst int index = 2;\n#else\nconst int index = 1;\n#endif\n#ifndef ENABLE_ID_DISCARD\nconst float writeId = 1.0;\n#endif\ngl_FragData[index] = vec4(dbId.rgb, writeId);\n#ifdef MODEL_COLOR\ngl_FragData[index+1] = vec4(modelId.rgb, writeId);\n#endif\n#elif defined(ID_COLOR)\n#ifdef ENABLE_ID_DISCARD\nif (writeId==0.0) {\n    discard;\n}\n#endif\ngl_FragColor = vec4(dbId.rgb, 1.0);\n#elif defined(MODEL_COLOR)\n#ifdef ENABLE_ID_DISCARD\nif (writeId==0.0) {\n    discard;\n}\n#endif\ngl_FragColor = vec4(modelId.rgb, 1.0);\n#endif\n",Ab.final_frag="#ifdef HATCH_PATTERN\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\n#endif\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n#ifdef MRT_NORMALS\ngl_FragData[1] = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#include<id_frag>\n",Ab.theming_decl_frag="uniform vec4 themingColor;\n",Ab.theming_frag="gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\n",Ab.instancing_decl_vert="\n#ifdef USE_INSTANCING\nattribute vec3 instOffset;\nattribute vec4 instRotation;\nattribute vec3 instScaling;\nvec3 applyQuaternion(vec3 p, vec4 q) {\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec3 getInstancePos(vec3 pos) {\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\n}\nvec3 getInstanceNormal(vec3 normal) {\n    return applyQuaternion(normal/instScaling, instRotation);\n}\n#else\nvec3 getInstancePos(vec3 pos)       { return pos;    }\nvec3 getInstanceNormal(vec3 normal) { return normal; }\n#endif\n",Ab.shadowmap_decl_common="\nuniform float shadowESMConstant;\nuniform float shadowMapRangeMin;\nuniform float shadowMapRangeSize;\n",Ab.shadowmap_decl_vert="\n#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord;\nuniform mat4 shadowMatrix;\n#endif\n",Ab.shadowmap_vert="\n#ifdef USE_SHADOWMAP\n{\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vShadowCoord = shadowMatrix * worldPosition;\n}\n#endif\n",Ab.shadowmap_decl_frag="\n#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap;\nuniform vec2      shadowMapSize;\nuniform float     shadowDarkness;\nuniform float     shadowBias;\nuniform vec3      shadowLightDir;\nvarying vec4 vShadowCoord;\n#include<shadowmap_decl_common>\nfloat getShadowValue() {\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n    float shadowValue = 1.0;\n    if (inFrustum) {\n        shadowCoord.z = min(0.999, shadowCoord.z);\n        shadowCoord.z -= shadowBias;\n#ifdef USE_HARD_SHADOWS\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float fDepth = rgbaDepth.r;\n        if ( fDepth < shadowCoord.z ) {\n            shadowValue = 1.0 - shadowDarkness;\n        }\n#else\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float shadowMapValue = rgbaDepth.r;\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\n        shadowValue = min(shadowValue, 1.0);\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\n#endif\n    }\n    return shadowValue;\n}\n#else\nfloat getShadowValue() { return 1.0; }\n#endif\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\n#if defined(USE_SHADOWMAP)\n    float dp  = dot(shadowLightDir, worldNormal);\n    float dpValue = (dp + 1.0) / 2.0;\n    dpValue = min(1.0, dpValue * 1.5);\n    float sv = getShadowValue();\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\n    return result;\n#else\n    return colorWithoutShadow;\n#endif\n}\n",Ab.float3_average="float averageOfFloat3(in vec3 value) { \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n",Ab.line_decl_common="\n#define TAU     6.28318530718\n#define PI      3.14159265358979\n#define HALF_PI 1.57079632679\n#define PI_0_5  HALF_PI\n#define PI_1_5  4.71238898038\n#define ENABLE_ID_DISCARD\n#define VBB_GT_TRIANGLE_INDEXED  0.0\n#define VBB_GT_LINE_SEGMENT      1.0\n#define VBB_GT_ARC_CIRCULAR      2.0\n#define VBB_GT_ARC_ELLIPTICAL    3.0\n#define VBB_GT_TEX_QUAD          4.0\n#define VBB_GT_ONE_TRIANGLE      5.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  0.0\n#define VBB_SEG_START_LEFT   1.0\n#define VBB_SEG_END_RIGHT    2.0\n#define VBB_SEG_END_LEFT     3.0\nvarying vec4 fsColor;\nvarying vec4 dbId;\nvarying vec2 fsOffsetDirection;\nvarying vec4 fsMultipurpose;\nvarying float fsHalfWidth;\nvarying vec2 fsVpTC;\nvarying float fsGhosting;\n",
Ab.prism_wood="#if defined( PRISMWOOD )\nfloat GetIndexedValue(vec4 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else if (index == 2)\n        return array[2];\n    else if (index == 3)\n        return array[3];\n    else\n        return 0.0;\n}\nint GetIndexedValue(ivec2 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else\n        return 0;\n}\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nfloat SampleCurlyPattern(vec2 uv)\n{\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\n    return curlyDistortion.r;\n}\nvec3 DistortCurly(vec3 p)\n{\n    if (!wood_curly_distortion_enable) return p;\n    float r = length(p.xy);\n    if (r < 0.00001) return p;\n    const float INV_ANGLE_INTERVAL = 1.27323954;\n    const float NUM_INTERVAL = 8.0;\n    const float PI2 = 6.283185308;\n    float theta = atan(p.y, p.x);\n    if (theta < 0.0)\n        theta += PI2;\n    float intIdx = theta * INV_ANGLE_INTERVAL;\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\n    const float maxOffset = 100.0;\n    offset0 = (offset0 - 0.5) * maxOffset;\n    offset1 = (offset1 - 0.5) * maxOffset;\n    vec2 uv0 = vec2(p.z + offset0, r);\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\n    vec2 uv1 = vec2(p.z + offset1, r);\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\n    float interpWeight = fract(intIdx);\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\n    const float INV_MIN_RADIUS = 2.0;\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\n    float thetaNew = atan(p.y, p.x);\n    vec3 pNew = p;\n    pNew.x = r * cos(thetaNew);\n    pNew.y = r * sin(thetaNew);\n    return pNew;\n}\n#endif\nvec3 un2sn(vec3 range)\n{\n    return range * 2.0 - 1.0;\n}\nfloat inoise(vec3 p)\n{\n    vec3 modp = mod(floor(p), 256.0);\n    modp.xy = modp.xy * ONE;\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\n    AA = AA + modp.z;\n    AA = mod(floor(AA), 256.0);\n    AA *= ONE;\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\n    p -= floor(p);\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix( mix( mix( dot(gradx1, p ),\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\n}\nfloat inoise(float p)\n{\n    float modp = mod(floor(p), 256.0);\n    modp = (modp + 256.0) * ONE;\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\n    p -= floor(p);\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix(gradx * p, grady * (p - 1.0), fadep);\n}\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nvec3 Distort3DCosineRadialDir(vec3 p)\n{\n    float radius = length(p.xy);\n    if (radius < 0.00001) return p;\n    vec2 theta = p.xy / radius;\n    float radiusShift = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= wood_fiber_cosine_bands) break;\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_2PI * GetIndexedValue(wood_fiber_cosine_frequencies, i));\n    }\n    const float MIN_RADIUS = 1.5;\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\n    if(weight >= 0.5)\n        weight = weight * weight * (3.0 - (weight + weight));\n    p.xy += theta * radiusShift * weight;\n    return p;\n}\nvec3 Distort3DPerlin(vec3 p)\n{\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\n    return p;\n}\nvec3 Distort(vec3 p)\n{\n    if(wood_fiber_cosine_enable)\n        p = Distort3DCosineRadialDir(p);\n    if(wood_fiber_perlin_enable)\n        p = Distort3DPerlin(p);\n    return p;\n}\nfloat DistortRadiusLength(float radiusLength)\n{\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\n    if (radiusLength < 0.0) radiusLength = 0.0;\n    return radiusLength;\n}\nfloat ComputeEarlyWoodRatio(float radiusLength)\n{\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\n    if (fraction <= wood_ring_fraction.y)\n       return 1.0;\n    else if(fraction <= wood_ring_fraction.x)\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\n    else if(fraction <= wood_ring_fraction.w)\n       return 0.0;\n    else\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\n}\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\n    return earlyColor;\n}\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\n    lateColor = pow(abs(lateColor), vec3(expValue));\n    return lateColor;\n}\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\n{\n    p.z *= wood_diffuse_perlin_scale_z;\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\n    return diffAlbedo;\n}\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\n{\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\n}\nfloat hashword(vec2 k)\n{\n    k = mod(k, vec2(256.0)) * ONE;\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\n    return a*255.0;\n}\nfloat wyvillsq(float rsq)\n{\n    if (rsq >= 1.0) return 0.0;\n    float tmp = 1.0 - rsq;\n    return tmp*tmp*tmp;\n}\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\n{\n    if(woodWeight <= 0.0) return 0.0;\n    float poreRadius = wood_pore_radius * woodWeight;\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\n    float weight = 0.0;\n    float invRsq = 1.0 / (poreRadius * poreRadius);\n    const float norm =  1.0 / 15.0;\n    for (int j = 0; j <= 4; j++)\n    {\n        if (j > int(right.y - left.y)) continue;\n        for (int i = 0; i <= 4; i++)\n        {\n            if (i > int(right.x - left.x)) continue;\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\n            float hRNum = hashword(pij);\n            float impPosX = mod(hRNum, 16.0) * norm;\n            float impPosY = floor(hRNum / 16.0) * norm;\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\n            weight += wyvillsq(dsq * invRsq);\n        }\n    }\n    return weight;\n}\nfloat Weight3DRayImpulses(vec3 p)\n{\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\n    int segIdx1 = segIdx - 1;\n    if ( factor > 0.5 )\n        segIdx1 = segIdx + 1;\n    float theta = atan(p.y, p.x);\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_2PI) * wood_ray_num_slices);\n    if ( sliceIdx == wood_ray_num_slices)\n        sliceIdx-=1.0;\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\n    float weight = 0.0;\n    const float norm =  1.0 / 15.0;\n    float radialOffset = 5.0;\n    float radialLength = length(p.xy);\n    for (int seg = 0; seg < 2; seg++)\n    {\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\n        float rn1 = mod(hRNum,16.0) * norm;\n        if (radialLength < radialOffset * rn1)\n            continue;\n        float rayTheta = rn1;\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\n        float rayPosZ = (hRNum/16.0)* norm;\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\n        vec3 pt1 = vec3(0.0);\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\n        vec3 p1 = p;\n        p1.z -= rayPosZ;\n        p1.z /=  wood_ray_ellipse_z2x;\n        vec3 v1 = pt2 - pt1;\n        vec3 v2 = pt1 - p1;\n        v2 = cross(v1, v2);\n        float dist = length(v2) / length(v1);\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\n        weight += wyvillsq( (dist * dist) * invRsq );\n    }\n    return weight;\n}\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\n{\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float a = wood_pore_color_power - 1.0;\n    float b = 1.0;\n    float y = a * poresWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\n{\n    float raysWeight = Weight3DRayImpulses(p);\n    float a = wood_ray_color_power - 1.0;\n    float b = 1.0;\n    float y = a * raysWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nfloat ComputeWoodWeight(float earlyWoodRatio)\n{\n    float woodWeight = 0.0;\n    if (wood_pore_type == 0)\n        woodWeight = 1.0;\n    else if (wood_pore_type == 1)\n        woodWeight = earlyWoodRatio;\n    else if (wood_pore_type == 2)\n        woodWeight = 1.0 - earlyWoodRatio;\n    else\n        woodWeight = -1.0;\n    return woodWeight;\n}\n#if defined( PRISMWOODBUMP )\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\n    int samples = int(samplesf);\n    float inverseSamples = 1.0 / float(samples);\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\n    float earlywoodRatio = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= samples) break;\n        for (int j = 0; j < 4; ++j)\n        {\n            if (j >= samples) break;\n            float r = radiusLength + dot(vec2(i, j), rdelta);\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\n        }\n    }\n    return earlywoodRatio * (inverseSamples * inverseSamples);\n}\nfloat LatewoodDepthVariation(float invUnitExt) \n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt; \n    return clamp(transPixels * 0.5, 0.0, 1.0); \n}\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth, \n                              float depthVar) \n{\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar; \n}\nfloat PoreDepthVariation(float woodWeight, float invUnitExt) \n{\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt; \n    return clamp(porePixels, 0.0, 1.0); \n}\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth, \n                          float depthVar) \n{\n    return poresWeight * (-1.0 * poreDepth) * depthVar; \n}\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\n{\n    const float epsilon = 0.001;\n    float heightDeltaX = heightRight - heightLeft;\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\n    float heightDeltaY = heightFront - heightBack;\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\n    return cross(Tu, Tv);\n}\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\n{ \n    float bumpNdotV = dot(bumpN, V);\n    if(bumpNdotV > 0.0)\n        return bumpN;\n    else return N;\n}\nfloat MinInverseUnitExtent(vec3 p)\n{\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\n}\nfloat HeightVariation(vec3 pos)\n{\n    vec3 p = Distort(pos);\n    float radiusLength = length(p.xy);\n    if (wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n    float invUnitExt = MinInverseUnitExtent(p);\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\n    float latewoodHeightVariation = 0.0;\n    if (wood_use_latewood_bump)\n    {\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\n    }\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\n    return sumHeightVariation;\n}\n#endif\nvec3 NoiseWood(vec3 p, inout float roughness)\n{\n    p = Distort(p);\n    float radiusLength = length(p.xy);\n    if(wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n#if defined( PRISMWOODBUMP )\n    float invUnitExt = MinInverseUnitExtent( p );\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n#else\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\n#endif\n    vec3 earlyColor = wood_early_color;\n    if (wood_earlycolor_perlin_enable)\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\n    vec3 lateColor;\n    if (wood_use_manual_late_color)\n        lateColor = wood_manual_late_color;\n    else\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\n    if(wood_latecolor_perlin_enable)\n        lateColor = DistortLateColor(lateColor, radiusLength);\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\n    if(wood_diffuse_perlin_enable)\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\n    if (wood_use_pores)\n    {\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\n    }\n    if (wood_use_rays)\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\n    if(wood_use_groove_roughness)\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\n}\n#endif\n",Ab.decl_point_size="uniform float point_size;",Ab.point_size="gl_PointSize = point_size;",Ab.wide_lines_decl="\n#ifdef WIDE_LINES\nattribute vec3 prev;\nattribute vec3 next;\nattribute float side;\nuniform vec2 view_size;\nvec2 to2d(vec4 i) {\n  return i.xy / i.w;\n}\n#endif\n",Ab.wide_lines_vert="\n#ifdef WIDE_LINES\nvec4 mvpPosition = projectionMatrix * mvPosition; \nmat3 vectorMatrix = mat3(modelViewMatrix);\nvec2 _pos = to2d(mvpPosition) * view_size;\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\nvec2 dir1 = _pos - _next;\nvec2 dir2 = _prev - _pos;\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\nvec2 dir_sharp = normalize(dir1 + dir2);\nvec2 dir = normalize(dir1 + dir_sharp);\nvec2 offset = vec2(-dir.y, dir.x);\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\noffset *= len;\noffset /= view_size;\noffset *= side;\noffset *= mvpPosition.w;\nmvpPosition.xy += offset;\ngl_Position = mvpPosition;\n#endif\n";var Cb={};Cb.prism_check=e,Cb.prism_sample_texture=function(a,b,c,d){return f(a,b,"true"===c,"true"===d)},Cb.prism_uniforms=h,Cb.prism_bump_uniforms=i;var Db={};for(Bb in Cb)Db[Bb]=new RegExp("#"+Bb+" *<([\\w\\d., ]*)>","g");var Eb=function a(b){for(var c in Cb){var d=Db[c];b=b.replace(d,function(a,b){var d=b.split(",").map(function(a){return a.trim()});return Cb[c].apply(null,d)})}var e=/#include *<([\w\d.]+)>/g,f=function(b,c){if(!Ab[c])throw new Error("Cannot resolve #include<"+c+">");return a(Ab[c])};return b.replace(e,f)},Fb=Ab.pack_depth,Gb=Ab.tonemap,Hb=Ab.ordered_dither,Ib=Ab.cutplanes,Jb=Ab.pack_normals,Kb=Ab.hatch_pattern,Lb=Ab.env_sample,Mb=Ab.id_decl_vert,Nb=Ab.id_vert,Ob=Ab.id_decl_frag,Pb=Ab.id_frag,Qb=Ab.final_frag,Rb=Ab.theming_decl_frag,Sb=Ab.theming_frag,Tb=Ab.instancing_decl_vert,Ub=Ab.shadowmap_decl_common,Vb=Ab.shadowmap_decl_vert,Wb=Ab.shadowmap_vert,Xb=Ab.shadowmap_decl_frag,Yb=Ab.float3_average,Zb=Ab.decl_point_size,$b=Ab.point_size,_b={IdUniforms:tb,ThemingUniform:ub,CutPlanesUniforms:sb,ShadowMapCommonUniforms:vb,ShadowMapUniforms:wb,PointSizeUniforms:xb,WideLinesUniforms:yb,DepthTextureUniforms:zb,PackDepthShaderChunk:Fb,TonemapShaderChunk:Gb,OrderedDitheringShaderChunk:Hb,CutPlanesShaderChunk:Ib,PackNormalsShaderChunk:Jb,HatchPatternShaderChunk:Kb,EnvSamplingShaderChunk:Lb,IdVertexDeclaration:Mb,IdVertexShaderChunk:Nb,IdFragmentDeclaration:Ob,IdOutputShaderChunk:Pb,FinalOutputShaderChunk:Qb,ThemingFragmentDeclaration:Rb,ThemingFragmentShaderChunk:Sb,InstancingVertexDeclaration:Tb,ShadowMapDeclareCommonUniforms:Ub,ShadowMapVertexDeclaration:Vb,ShadowMapVertexShaderChunk:Wb,ShadowMapFragmentDeclaration:Xb,AverageOfFloat3:Yb,PointSizeDeclaration:Zb,PointSizeShaderChunk:$b,GetPrismMapSampleChunk:f,GetPrismMapUniformChunk:h,resolve:Eb},ac={uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap,_b.CutPlanesUniforms,_b.IdUniforms,_b.ThemingUniform,_b.PointSizeUniforms,_b.WideLinesUniforms]),vertexShader:"#include<id_decl_vert>\n#include<decl_point_size>\n#include<common>\n#include<map_pars_vertex>\n#include<lightmap_pars_vertex>\n#include<envmap_pars_vertex>\n#include<color_pars_vertex>\n#include<morphtarget_pars_vertex>\n#include<skinning_pars_vertex>\n#include<logdepthbuf_pars_vertex>\n#include<wide_lines_decl>\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\nvoid main() {\n#include<map_vertex>\n#include<lightmap_vertex>\n#include<color_vertex>\n#include<skinbase_vertex>\n#ifdef USE_ENVMAP\n#include<morphnormal_vertex>\n#include<skinnormal_vertex>\n#include<defaultnormal_vertex>\n#endif\n#include<morphtarget_vertex>\n#include<skinning_vertex>\n#include<default_vertex>\n#include<wide_lines_vert>\n#include<logdepthbuf_vertex>\n#include<worldpos_vertex>\n#if NUM_CUTPLANES > 0\n    vec4 _worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = _worldPosition.xyz;\n#endif\n#include<envmap_vertex>\n#include<id_vert>\n#include<point_size>\n}\n",fragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\n#include<common>\n#include<color_pars_fragment>\n#include<map_pars_fragment>\n#include<alphamap_pars_fragment>\n#include<lightmap_pars_fragment>\n#include<envmap_pars_fragment>\n#include<fog_pars_fragment>\n#include<specularmap_pars_fragment>\n#include<logdepthbuf_pars_fragment>\n#if NUM_CUTPLANES > 0\nvarying highp vec3 vWorldPosition;\n#endif\n#include<cutplanes>\n#include<id_decl_frag>\n#include<theming_decl_frag>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n#include<logdepthbuf_fragment>\n#include<map_fragment>\n#include<color_fragment>\n#include<alphamap_fragment>\n#include<alphatest_fragment>\n#include<specularmap_fragment>\n    outgoingLight = diffuseColor.rgb;\n#include<lightmap_fragment>\n#include<envmap_fragment>\n#include<linear_to_gamma_fragment>\n#include<fog_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#include<theming_frag>\n#include<final_frag>\n}\n"};THREE.ShaderLib.firefly_basic=ac;var bc="varying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",cc={uniforms:{tDiffuse:{type:"t",value:null},tAO:{type:"t",value:null},useAO:{type:"i",value:0},aoOpacity:{type:"f",value:1},tOverlay:{type:"t",value:null},useOverlay:{type:"i",value:0},tID:{type:"t",value:null},objID:{type:"i",value:0},objIDv3:{type:"v3",value:new THREE.Vector3(0,0,0)},highlightIntensity:{type:"f",value:1},resolution:{type:"v2",value:new THREE.Vector2(1/1024,1/512)},highlightRange:{type:"i",value:0},objIDStart:{type:"i",value:0},objIDEnd:{type:"i",value:0}},vertexShader:bc,fragmentShader:"uniform sampler2D tDiffuse;\nuniform sampler2D tAO;\nuniform int useAO;\nuniform float aoOpacity;\nuniform sampler2D tOverlay;\nuniform int useOverlay;\nuniform vec2 resolution;\nuniform int objID;\nuniform vec3 objIDv3;\nuniform sampler2D tID;\nuniform float highlightIntensity;\nuniform int highlightRange;\nuniform int objIDStart;\nuniform int objIDEnd;\nvarying vec2 vUv;\n#include<tonemap>\nvec4 overlayEdgeDetect(vec2 vUv) {\n#define IS_SELECTION(C) ( (C).b > (C).r && (C).b > (C).g )\n#define CHECK_EDGE_ALPHA(I, J)     { vec4 c = texture2D( tOverlay, vUv+resolution*vec2((I),(J)) ); maxAlpha = max(maxAlpha, c.a); if (c.a > 0.0 && IS_SELECTION(c)) { hasEdge++; selectionPixel = c; } }\n#define CHECK_EDGE_SELECTION(I, J) { vec4 c = texture2D( tOverlay, vUv+resolution*vec2((I),(J)) ); maxAlpha = max(maxAlpha, c.a); if (c.a <= 0.0) hasEdge++; }\n    int hasEdge = 0;\n    vec4 center = texture2D(tOverlay, vUv);\n    vec4 selectionPixel = vec4(0.0);\n    float maxAlpha = 0.0;\n    bool paintOutline = false;\n    if (center.a <= 0.0) {\n        CHECK_EDGE_ALPHA(-1.0,-1.0);\n        CHECK_EDGE_ALPHA( 0.0,-1.0);\n        CHECK_EDGE_ALPHA( 1.0,-1.0);\n        CHECK_EDGE_ALPHA(-1.0, 0.0);\n        CHECK_EDGE_ALPHA( 1.0, 0.0);\n        CHECK_EDGE_ALPHA(-1.0, 1.0);\n        CHECK_EDGE_ALPHA( 0.0, 1.0);\n        CHECK_EDGE_ALPHA( 1.0, 1.0);\n        if (hasEdge != 0) {\n            center = selectionPixel;\n            paintOutline = true;\n        }\n    }\n    else if (center.a > 0.0 && IS_SELECTION(center)) {\n        CHECK_EDGE_SELECTION(-1.0,-1.0);\n        CHECK_EDGE_SELECTION( 0.0,-1.0);\n        CHECK_EDGE_SELECTION( 1.0,-1.0);\n        CHECK_EDGE_SELECTION(-1.0, 0.0);\n        CHECK_EDGE_SELECTION( 1.0, 0.0);\n        CHECK_EDGE_SELECTION(-1.0, 1.0);\n        CHECK_EDGE_SELECTION( 0.0, 1.0);\n        CHECK_EDGE_SELECTION( 1.0, 1.0);\n        if (hasEdge != 0)\n            paintOutline = true;\n        else\n            center.a = -center.a;\n    }\n    if (paintOutline) {\n        float maxComponent = max(center.r, max(center.g, center.b));\n        center.rgb /= maxComponent;\n        center.rgb = sqrt(center.rgb);\n        center.a = 0.5 + 0.5 * maxAlpha * 0.125 * float(hasEdge);\n    }\n    return center;\n}\nvec4 sampleColor() {\n    return texture2D( tDiffuse, vUv );\n}\nfloat sampleAO() {\n    return (useAO != 0) ? sqrt(texture2D(tAO, vUv).r) : 1.0;\n}\nvoid applyHighlighting(inout vec3 rgb) {\n#ifdef IS_2D\n    rgb = mix(rgb, vec3(1.0,1.0,0.0), highlightIntensity * 0.25);\n#else\n    rgb += highlightIntensity * 0.20;\n#endif\n}\nvoid main() {\n    vec4 texel = sampleColor();\n    float ao = sampleAO();\n    ao = 1.0 - (1.0 - ao) * aoOpacity;\n    texel.rgb *= ao;\n    if (useOverlay != 0) {\n        vec4 overlay = overlayEdgeDetect(vUv);\n        if (overlay.a < 0.0) {\n            overlay.a = -overlay.a;\n            if (overlay.a >= 0.99) {\n                overlay.a = 0.75;\n                texel.rgb = vec3(luminance_post(texel.rgb));\n            }\n        }\n        texel.rgb = mix(texel.rgb, sqrt(overlay.rgb), overlay.a);\n    }\n    if (highlightRange == 0) {\n        if (objID != 0) {\n            vec4 idAtPixel = texture2D(tID, vUv);\n            vec3 idDelta = abs(idAtPixel.rgb - objIDv3.rgb);\n            if (max(max(idDelta.r, idDelta.g), idDelta.b) < 1e-3) {\n                applyHighlighting(texel.rgb);\n            }\n        }\n    } else {\n        vec4 idAtPixel = texture2D(tID, vUv);\n        int dbId = int(idAtPixel.r * 255.0 + idAtPixel.g * 255.0 * 256.0 + idAtPixel.b * 255.0 * 256.0 * 256.0);\n        if (dbId >= objIDStart && dbId <= objIDEnd) {\n            applyHighlighting(texel.rgb);\n        }\n    }\n    gl_FragColor = texel;\n}\n"},dc={uniforms:THREE.UniformsUtils.merge([_b.DepthTextureUniforms,{tDiffuse:{type:"t",value:null},tID:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(1/1024,1/512)},cameraNear:{type:"f",value:1},cameraFar:{type:"f",value:100}}]),vertexShader:bc,
fragmentShader:"#extension GL_OES_standard_derivatives : enable\n#include<depth_texture>\nuniform sampler2D tDiffuse;\nuniform sampler2D tID;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nvarying vec2 vUv;\nvec4 recoverNZ(vec4 nrmz) {\n    float z = sqrt(1.0 - dot(nrmz.xy, nrmz.xy));\n    nrmz.w = -(nrmz.z +cameraNear) / (cameraFar - cameraNear);\n    nrmz.z = z;\n    return nrmz;\n}\n#include<tonemap>\nvec4 quantize(vec4 c) {\n    c *= c;\n    float L = max(c.x, max(c.y, c.z));\n    c.xyz *= floor(L * 8.0 + 0.5) / (8.0 * L);\n    c.w = 1.0;\n    return sqrt(c);\n}\nvec4 quantizeRGB(vec4 c) {\n    c *= c;\n    c.xyz *= floor(c.xyz * 8.0 + 0.5) / 8.0;\n    c.w = 1.0;\n    return sqrt(c);\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\n    return normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 getPosition(ivec2 ssP, float depth) {\n    vec3 P;\n    P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\n    return P;\n}\nint isObjectEdge() {\n    vec4 MM = texture2D(tID, vUv + vec2( 0.0,  0.0));\n    vec4 LL = texture2D(tID, vUv + vec2(-1.0, -1.0) * resolution);\n    if (MM != LL) return 1;\n    vec4 LM = texture2D(tID, vUv + vec2( 0.0, -1.0) * resolution);\n    if (MM != LM) return 1;\n    vec4 LR = texture2D(tID, vUv + vec2( 1.0, -1.0) * resolution);\n    if (MM != LR) return 1;\n    vec4 ML = texture2D(tID, vUv + vec2(-1.0,  0.0) * resolution);\n    if (MM != ML) return 1;\n    vec4 MR = texture2D(tID, vUv + vec2( 1.0,  0.0) * resolution);\n    if (MM != MR) return 1;\n    vec4 UL = texture2D(tID, vUv + vec2(-1.0,  1.0) * resolution);\n    if (MM != UL) return 1;\n    vec4 UM = texture2D(tID, vUv + vec2( 0.0,  1.0) * resolution);\n    if (MM != UM) return 1;\n    vec4 UR = texture2D(tID, vUv + vec2( 1.0,  1.0) * resolution);\n    if (MM != UR) return 1;\n    return 0;\n}\nfloat normalDiff(vec3 n1, vec3 n2) {\n    float d = dot(n1.xyz, n2.xyz);\n    return acos(clamp(d, -1.0, 1.0));\n}\nconst float r = 1.0;\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    ivec2 ssC = ivec2(gl_FragCoord.xy);\n    if (isObjectEdge() == 1) {\n        gl_FragColor = vec4(0,0,0,1);\n        return;\n    }\n    vec4 MM = texture2D(tDepth, vUv + vec2( 0.0,  0.0));\n    if (MM.z == 0.0) {\n        gl_FragColor = quantize(color);\n        return;\n    }\n    vec4 LL = texture2D(tDepth, vUv + vec2(-r, -r) * resolution);\n    vec4 LM = texture2D(tDepth, vUv + vec2( 0.0, -r) * resolution);\n    vec4 LR = texture2D(tDepth, vUv + vec2( r, -r) * resolution);\n    vec4 ML = texture2D(tDepth, vUv + vec2(-r,  0.0) * resolution);\n    vec4 MR = texture2D(tDepth, vUv + vec2( r,  0.0) * resolution);\n    vec4 UL = texture2D(tDepth, vUv + vec2(-r, r) * resolution);\n    vec4 UM = texture2D(tDepth, vUv + vec2( 0.0,  r) * resolution);\n    vec4 UR = texture2D(tDepth, vUv + vec2( r,  r) * resolution);\n    vec3 C = getPosition(ssC + ivec2(-1, -1), LL.z);\n    vec3 LLz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2( 0, -1), LM.z);\n    vec3 LMz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2( 1, -1), LR.z);\n    vec3 LRz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2(-1, 0), ML.z);\n    vec3 MLz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2( 0, 0), MM.z);\n    vec3 MMz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2( 1, 0), MR.z);\n    vec3 MRz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2(-1, 1), UL.z);\n    vec3 ULz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2(0, 1), UM.z);\n    vec3 UMz = reconstructCSFaceNormal(C);\n    C = getPosition(ssC + ivec2(1, 1), UR.z);\n    vec3 URz = reconstructCSFaceNormal(C);\n    LL = recoverNZ(LL);\n    LM = recoverNZ(LM);\n    LR = recoverNZ(LR);\n    ML = recoverNZ(ML);\n    MM = recoverNZ(MM);\n    MR = recoverNZ(MR);\n    UL = recoverNZ(UL);\n    UM = recoverNZ(UM);\n    UR = recoverNZ(UR);\n    float pLL = normalDiff(LL.xyz, MM.xyz);\n    float pLM = normalDiff(LM.xyz, MM.xyz);\n    float pLR = normalDiff(LR.xyz, MM.xyz);\n    float pML = normalDiff(ML.xyz, MM.xyz);\n    float pMM = normalDiff(MM.xyz, MM.xyz);\n    float pMR = normalDiff(MR.xyz, MM.xyz);\n    float pUL = normalDiff(UL.xyz, MM.xyz);\n    float pUM = normalDiff(UM.xyz, MM.xyz);\n    float pUR = normalDiff(UR.xyz, MM.xyz);\n    float pLLz = normalDiff(LLz.xyz, MMz.xyz);\n    float pLMz = normalDiff(LMz.xyz, MMz.xyz);\n    float pLRz = normalDiff(LRz.xyz, MMz.xyz);\n    float pMLz = normalDiff(MLz.xyz, MMz.xyz);\n    float pMMz = normalDiff(MMz.xyz, MMz.xyz);\n    float pMRz = normalDiff(MRz.xyz, MMz.xyz);\n    float pULz = normalDiff(ULz.xyz, MMz.xyz);\n    float pUMz = normalDiff(UMz.xyz, MMz.xyz);\n    float pURz = normalDiff(URz.xyz, MMz.xyz);\n    float dGx = (dFdx(UL.w) + 2.0 * dFdx(UM.w) + dFdx(UR.w)) - (dFdx(LL.w) + 2.0 * dFdx(LM.w) + dFdx(LR.w)) + (dFdx(UR.w) + 2.0 * dFdx(MR.w) - dFdx(LR.w)) - (dFdx(UL.w) + 2.0 * dFdx(ML.w) - dFdx(LL.w));\n    float dGy = (dFdy(UL.w) + 2.0 * dFdy(UM.w) + dFdy(UR.w)) - (dFdy(LL.w) + 2.0 * dFdy(LM.w) + dFdy(LR.w)) + (dFdy(UR.w) + 2.0 * dFdy(MR.w) - dFdy(LR.w)) - (dFdy(UL.w) + 2.0 * dFdy(ML.w) - dFdy(LL.w));\n    float Gn = (abs(pUL - pMM) + 2.0 * abs(pUM - pMM) + abs(pUR - pMM) + 2.0 * abs(pML - pMM) + 2.0 * abs(pMR - pMM) + abs(pLL - pMM) + 2.0 * abs(pLM - pMM) + abs(pLR - pMM));\n    float Gnz = (abs(pULz - pMMz) + 2.0 * abs(pUMz - pMMz) + abs(pURz - pMMz) + 2.0 * abs(pMLz - pMMz) + 2.0 * abs(pMRz - pMMz) + abs(pLLz - pMMz) + 2.0 * abs(pLMz - pMMz) + abs(pLRz - pMMz));\n    float G = (abs(UL.w - MM.w) + 2.0 * abs(UM.w - MM.w) + abs(UR.w - MM.w) + 2.0 * abs(ML.w - MM.w) + 2.0 * abs(MR.w - MM.w) + abs(LL.w - MM.w) + 2.0 * abs(LM.w - MM.w) + abs(LR.w - MM.w));\n    float dd = abs(dFdx(G)) + abs(dFdy(G));\n    if (dd > 0.004 || abs(Gnz) > 2.2 || abs(Gn) > 2.0)\n        gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n    else\n        gl_FragColor =quantize(color);\n}\n"},ec={uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:bc,fragmentShader:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n    gl_FragColor = texture2D(tDiffuse, vUv);\n}\n"},fc={uniforms:{tDiffuse:{type:"t",value:null},uResolution:{type:"v2",value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"uniform vec2 uResolution;\nvarying vec2 vPos;\nvarying vec4 vPosPos;\nvoid main() {\n    vPos = uv;\n    vPosPos.xy = uv + vec2(-0.5, -0.5) * uResolution;\n    vPosPos.zw = uv + vec2( 0.5,  0.5) * uResolution;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",fragmentShader:"#define FXAA_EDGE_SHARPNESS (8.0)\n#define FXAA_EDGE_THRESHOLD (0.125)\n#define FXAA_EDGE_THRESHOLD_MIN (0.05)\n#define FXAA_RCP_FRAME_OPT (0.50)\n#define FXAA_RCP_FRAME_OPT2 (2.0)\nuniform sampler2D tDiffuse;\nuniform highp vec2 uResolution;\nvarying vec2 vPos;\nvarying vec4 vPosPos;\nfloat FxaaLuma(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nvoid main() {\n    float lumaNw = FxaaLuma(texture2D(tDiffuse, vPosPos.xy).rgb);\n    float lumaSw = FxaaLuma(texture2D(tDiffuse, vPosPos.xw).rgb);\n    float lumaNe = FxaaLuma(texture2D(tDiffuse, vPosPos.zy).rgb) + 1.0/384.0;\n    float lumaSe = FxaaLuma(texture2D(tDiffuse, vPosPos.zw).rgb);\n    vec3 rgbM = texture2D(tDiffuse, vPos.xy).rgb;\n    float lumaM = FxaaLuma(rgbM.rgb);\n    float lumaMax = max(max(lumaNe, lumaSe), max(lumaNw, lumaSw));\n    float lumaMin = min(min(lumaNe, lumaSe), min(lumaNw, lumaSw));\n    float lumaMaxSubMinM = max(lumaMax, lumaM) - min(lumaMin, lumaM);\n    float lumaMaxScaledClamped = max(FXAA_EDGE_THRESHOLD_MIN, lumaMax * FXAA_EDGE_THRESHOLD);\n    if (lumaMaxSubMinM < lumaMaxScaledClamped) {\n        gl_FragColor = vec4(rgbM, 1.0);\n        return;\n    }\n    float dirSwMinusNe = lumaSw - lumaNe;\n    float dirSeMinusNw = lumaSe - lumaNw;\n    vec2 dir1 = normalize(vec2(dirSwMinusNe + dirSeMinusNw, dirSwMinusNe - dirSeMinusNw));\n    vec3 rgbN1 = texture2D(tDiffuse, vPos.xy - dir1 * FXAA_RCP_FRAME_OPT*uResolution).rgb;\n    vec3 rgbP1 = texture2D(tDiffuse, vPos.xy + dir1 * FXAA_RCP_FRAME_OPT*uResolution).rgb;\n    float dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * FXAA_EDGE_SHARPNESS;\n    vec2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);\n    vec3 rgbN2 = texture2D(tDiffuse, vPos.xy - dir2 * FXAA_RCP_FRAME_OPT2*uResolution).rgb;\n    vec3 rgbP2 = texture2D(tDiffuse, vPos.xy + dir2 * FXAA_RCP_FRAME_OPT2*uResolution).rgb;\n    vec3 rgbA = rgbN1 + rgbP1;\n    vec3 rgbB = ((rgbN2 + rgbP2) * 0.25) + (rgbA * 0.25);\n    float lumaB = FxaaLuma(rgbB);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        gl_FragColor = vec4(rgbA * 0.5, 1.0);\n    else\n        gl_FragColor = vec4(rgbB, 1.0);\n}\n"},gc={uniforms:{tDiffuse:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(512,512)},resolution:{type:"v2",value:new THREE.Vector2(1/512,1/512)},axis:{type:"v2",value:new THREE.Vector2(1,0)},radius:{type:"f",value:50}},vertexShader:bc,fragmentShader:"\n#define EDGE_SHARPNESS     (3.0)\n#define SCALE               (2)\n#define R                   (4)\n#define VALUE_TYPE        float\n#define VALUE_COMPONENTS   r\n#define VALUE_IS_KEY       0\n#define KEY_COMPONENTS     gb\n#if __VERSION__ >= 330\nconst float gaussian[R + 1] =\nfloat[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);\n#endif\nuniform sampler2D   tDiffuse;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform vec2       axis;\nuniform float radius;\n#define  result         gl_FragColor.VALUE_COMPONENTS\n#define  keyPassThrough gl_FragColor.KEY_COMPONENTS\nfloat unpackKey(vec2 p) {\n    return p.x + p.y * (1.0 / 255.0);\n}\nvarying vec2 vUv;\nvoid main() {\n#   if __VERSION__ < 330\n    float gaussian[R + 1];\n#       if R == 3\n    gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;\n#       elif R == 4\n    gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;\n#       elif R == 6\n    gaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;\n#       endif\n#   endif\n    ivec2 axisi = ivec2(axis);\n    ivec2 ssC = ivec2(gl_FragCoord.xy);\n    vec4 temp = texture2D(tDiffuse, vUv);\n    gl_FragColor.gb = temp.KEY_COMPONENTS;\n    gl_FragColor.a = temp.a;\n    VALUE_TYPE sum = temp.VALUE_COMPONENTS;\n    if (temp.a == 0.0) {\n        result = sum;\n        return;\n    }\n    float key = unpackKey(keyPassThrough);\n    float BASE = gaussian[0];\n    float totalWeight = BASE;\n    sum *= totalWeight;\n    float scale = 1.5 / radius;\n    int r = -4; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[4];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r = -3; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[3];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r = -2; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[2];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r=-1; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[1];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r = 1; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[1];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r = 2; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[2];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r = 3; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[3];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    r = 4; {\n        vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\n        temp = texture2D(tDiffuse, ssUV);\n        float      tapKey = unpackKey(temp.KEY_COMPONENTS);\n        VALUE_TYPE value  = temp.VALUE_COMPONENTS;\n        float weight = 0.3 + gaussian[4];\n        float dz = tapKey - key;\n        weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz) * scale);\n        sum += value * weight;\n        totalWeight += weight;\n    }\n    const float epsilon = 0.0001;\n    result = sum / (totalWeight + epsilon);\n}\n"},hc={uniforms:THREE.UniformsUtils.merge([_b.DepthTextureUniforms,{size:{type:"v2",value:new THREE.Vector2(512,512)},resolution:{type:"v2",value:new THREE.Vector2(1/512,1/512)},cameraNear:{type:"f",value:1},cameraFar:{type:"f",value:100},radius:{type:"f",value:10},bias:{type:"f",value:.1},projScale:{type:"f",value:500},intensity:{type:"f",value:.4},tDepth_mip1:{type:"t",value:null},tDepth_mip2:{type:"t",value:null},tDepth_mip3:{type:"t",value:null},tDepth_mip4:{type:"t",value:null},tDepth_mip5:{type:"t",value:null}}]),vertexShader:bc,fragmentShader:"\n#include<depth_texture>\n#define USE_MIPMAP 1\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform float lumInfluence;\nvarying vec2 vUv;\n#define NUM_SAMPLES (17)\n#define LOG_MAX_OFFSET (3)\n#define MAX_MIP_LEVEL (5)\n#define NUM_SPIRAL_TURNS (5)\n#define MIN_RADIUS (3.0)\nuniform float           projScale;\n#ifdef USE_MIPMAP\nuniform sampler2D tDepth_mip1;\nuniform sampler2D tDepth_mip2;\nuniform sampler2D tDepth_mip3;\nuniform sampler2D tDepth_mip4;\nuniform sampler2D tDepth_mip5;\n#endif\nuniform float radius;\nuniform float bias;\nuniform float intensity;\nvec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){\n    float alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));\n    float angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;\n    ssR = alpha;\n    return vec2(cos(angle), sin(angle));\n}\nfloat CSZToKey(float z) {\n    return clamp( (z+cameraNear) / (cameraNear-cameraFar), 0.0, 1.0);\n}\nvoid packKey(float key, out vec2 p) {\n    float temp = floor(key * 255.0);\n    p.x = temp * (1.0 / 255.0);\n    p.y = key * 255.0 - temp;\n}\n#include<pack_depth>\nfloat unpackDepthNearFar( const in vec4 rgba_depth ) {\n    float depth = unpackDepth( rgba_depth );\n    if (depth == 0.0)\n        return -cameraFar * 1.0e10;\n    return depth * (cameraNear - cameraFar) - cameraNear;\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\n    return normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 reconstructNonUnitCSFaceNormal(vec3 C) {\n    return cross(dFdy(C), dFdx(C));\n}\nvec3 getPosition(ivec2 ssP, float depth) {\n    vec3 P;\n    P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\n    return P;\n}\nvec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {\n    ivec2 ssP = ivec2(ssR * unitOffset) + ssC;\n    vec3 P;\n    vec2 screenUV = (vec2(ssP) + vec2(0.5)) * resolution;\n#ifdef USE_MIPMAP\n    int mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));\n    if (mipLevel == 0) {\n        P.z = texture2D(tDepth, screenUV).z;\n        if (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n    }\n    else if (mipLevel == 1)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip1, screenUV));\n    else if (mipLevel == 2)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip2, screenUV));\n    else if (mipLevel == 3)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip3, screenUV));\n    else if (mipLevel == 4)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip4, screenUV));\n    else if (mipLevel == 5)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip5, screenUV));\n#else\n    P.z = texture2D(tDepth, screenUV).z;\n    if (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n#endif\n    P = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);\n    return P;\n}\nfloat sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {\n    float ssR;\n    vec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);\n    ssR = max(0.75, ssR * ssDiskRadius);\n    vec3 Q = getOffsetPosition(ssC, unitOffset, ssR);\n    vec3 v = Q - C;\n    float vv = dot(v, v);\n    float vn = dot(v, n_C);\n    const float epsilon = 0.001;\n    float angAdjust = mix(1.0, max(0.0, 1.5 * n_C.z), 0.35);\n#define HIGH_QUALITY\n#ifdef HIGH_QUALITY\n    float f = max(1.0 - vv / (radius * radius), 0.0); return angAdjust * f * max((vn - bias) / sqrt(epsilon + vv), 0.0);\n#else\n    float f = max(radius * radius - vv, 0.0); return angAdjust * f * f * f * max((vn - bias) / (epsilon + vv), 0.0);\n#endif\n}\nconst bool useNoise = true;\nfloat getRandomAngle(vec2 pos) {\n    float dt= dot(pos ,vec2(12.9898,78.233));\n    return 6.28318 * fract(sin(mod(dt,3.14)) * 43758.5453);\n}\nvoid main() {\n    ivec2 ssC = ivec2(gl_FragCoord.xy);\n    vec4 nrmz = texture2D(tDepth, vUv);\n    if (nrmz.z == 0.0) {\n        gl_FragColor.r = 1.0;\n        gl_FragColor.a = 0.0;\n        packKey(1.0, gl_FragColor.gb);\n        return;\n    }\n    vec3 C = getPosition(ssC, nrmz.z);\n    packKey(CSZToKey(C.z), gl_FragColor.gb);\n    float ssDiskRadius = -projScale * radius / mix(C.z, -1.0, isOrtho);\n    float A;\n    if (ssDiskRadius <= MIN_RADIUS) {\n        A = 1.0;\n    } else {\n        float sum = 0.0;\n        float randomPatternRotationAngle = getRandomAngle(vUv);\n        vec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 0, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 1, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 2, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 3, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 4, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 5, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 6, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 7, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 8, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 9, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 10, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 11, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 12, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 13, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 14, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 15, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 16, randomPatternRotationAngle);\n        float intensityDivR6 = intensity / pow(radius, 6.0);\n#ifdef HIGH_QUALITY\n        A = pow(max(0.0, 1.0 - sqrt(sum * (3.0 / float(NUM_SAMPLES)))), intensity);\n#else\n        A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));\n        A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n#endif\n        if (abs(dFdx(C.z)) < 0.02) {\n            A -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);\n        }\n        if (abs(dFdy(C.z)) < 0.02) {\n            A -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);\n        }\n        A = mix(1.0, A, clamp(ssDiskRadius - MIN_RADIUS,0.0,1.0));\n    }\n    gl_FragColor.r = A;\n    gl_FragColor.a = 1.0;\n}\n"},ic={uniforms:{cutplanes:{type:"v4v",value:[]}},vertexShader:"varying vec3 vNormal;\nvarying float depth;\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include<pack_normals>\n#include<instancing_decl_vert>\nvoid main() {\n#ifdef UNPACK_NORMALS\n    vec3 objectNormal = decodeNormal(normal);\n#else\n    vec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n    objectNormal = getInstanceNormal(objectNormal);\n    vec3 instPos = getInstancePos(position);\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    vNormal = normalize( transformedNormal );\n#if NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( instPos, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n    vec4 mvPosition = modelViewMatrix * vec4( instPos, 1.0 );\n    depth = mvPosition.z;\n    vec4 p_Position = projectionMatrix * mvPosition;\n    gl_Position = p_Position;\n}\n",fragmentShader:"varying highp vec3 vNormal;\nvarying highp float depth;\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include<cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    vec3 n = vNormal;\n    n = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    n = normalize( n );\n    gl_FragColor = vec4(n.x, n.y, depth, 1.0);\n}\n"},jc={uniforms:{color:{type:"v4",value:new THREE.Vector4(0,0,0,.3)},cutplanes:{type:"v4v",value:[]}},vertexShader:"\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include<instancing_decl_vert>\nvoid main() {\n    vec3 instPos = getInstancePos(position);\n#if NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( instPos, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n    vec4 mvPosition = modelViewMatrix * vec4( instPos, 1.0 );\n    vec4 p_Position = projectionMatrix * mvPosition;\n    gl_Position = p_Position;\n}",fragmentShader:"\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include<cutplanes>\nuniform vec4 color;\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    gl_FragColor = color;\n}"},kc={uniforms:{pixelsPerUnit:{type:"f",value:1},aaRange:{type:"f",value:.5},tLayerMask:{type:"t",value:null},tLineStyle:{type:"t",value:null},vLineStyleTexSize:{type:"v2",value:new THREE.Vector2(13,70)},tRaster:{type:"t",value:null},tSelectionTexture:{type:"t",value:null},vSelTexSize:{type:"v2",value:new THREE.Vector2(4096,1)},displayPixelRatio:{type:"f",value:1},opacity:{type:"f",value:1},selectionColor:{type:"v4",value:new THREE.Vector4(0,0,1,1)},modelId:{type:"v3",value:new THREE.Vector3(0,0,0)},viewportId:{type:"f",value:0},swap:{type:"f",value:0}},attributes:{fields1:0,fields2:0,color4b:0,dbId4b:0,flags4b:0,layerVp4b:0,extraParams:0,instFlags4b:0},defines:{},
vertexShader:"\n#include<line_decl_common>\nattribute vec3 fields1;\nattribute vec3 fields2;\nattribute vec4 color4b;\nattribute vec4 dbId4b;\nattribute vec4 flags4b;\nattribute vec4 layerVp4b;\n#ifdef HAS_ELLIPTICALS\nattribute vec3 extraParams;\n#endif\n#ifdef USE_INSTANCING\nattribute vec4 instFlags4b;\n#endif\nuniform mat4 mvpMatrix;\nuniform float pixelsPerUnit;\nuniform float aaRange;\nuniform float viewportId;\nuniform float swap;\n#ifdef HAS_LAYERS\nuniform sampler2D tLayerMask;\n#endif\n#ifdef SELECTION_RENDERER\nuniform sampler2D tSelectionTexture;\nuniform vec2 vSelTexSize;\n#endif\n#ifdef SELECTION_RENDERER\nuniform vec4 selectionColor;\n#endif\nvec2 centralVertex;\nvec2 offsetPosition;\nvec2 cos_sin(const float angle) { return vec2(cos(angle), sin(angle)); }\nvoid min_max(inout vec2 minPt, inout vec2 maxPt, const vec2 p) {\n    minPt = min(minPt, p);\n    maxPt = max(maxPt, p);\n}\n#if defined(USE_INSTANCING)\nfloat getVertexId() { return instFlags4b.x; }\n#else\nfloat getVertexId() { return flags4b.x; }\n#endif\nbool isStartVertex() { return (getVertexId() < VBB_SEG_END_RIGHT); }\nbool isLeftVertex()  { float id = getVertexId(); return ((id == VBB_SEG_END_LEFT || id == VBB_SEG_START_LEFT)); }\nstruct SegmentData { float angle, distAlong, distTotal, lineWidthHalf, lineType; };\nvoid decodeSegmentData(out SegmentData seg) {\n    seg.angle         = fields1.z;\n    seg.distAlong     = fields2.x;\n    seg.distTotal     = fields2.z;\n    seg.lineWidthHalf = fields2.y;\n    seg.lineType      = flags4b.z;\n}\nvoid strokeLineSegment() {\n    SegmentData seg; decodeSegmentData(seg);\n    float isStartCapVertex = isStartVertex() ? -1.0 :  1.0;\n    float isLeftSide       = isLeftVertex( ) ?  1.0 : -1.0;\n    float angleTransverse = seg.angle + isLeftSide * HALF_PI;\n    float lwAdjustment = fsHalfWidth + aaRange;\n    vec2 transverseOffset = cos_sin(angleTransverse) * lwAdjustment;\n    offsetPosition.xy += transverseOffset;\n    float distanceFromStart = max(isStartCapVertex, 0.0) * seg.distAlong;\n    vec2 along = distanceFromStart * cos_sin(seg.angle);\n    offsetPosition.xy += along;\n    centralVertex.xy  += along;\n    vec2 moveOffset = isStartCapVertex * isLeftSide * vec2(-transverseOffset.y, transverseOffset.x);\n    offsetPosition.xy -= moveOffset;\n    centralVertex.xy  -= moveOffset;\n    fsMultipurpose.x = (isStartCapVertex * lwAdjustment) + distanceFromStart;\n    fsMultipurpose.y = seg.distAlong;\n    fsMultipurpose.z = seg.distTotal;\n    fsMultipurpose.w = seg.lineType;\n    if (seg.lineWidthHalf < 0.0)\n        fsHalfWidth = -fsHalfWidth;\n}\n#ifdef HAS_TRIANGLE_GEOMS\nstruct TriangleData { vec2 p0, p1, p2; };\nvoid decodeTriangleData(out TriangleData tri) {\n    tri.p1 = vec2(fields1.z, fields2.x);\n    tri.p2 = fields2.yz;\n}\nvoid strokeOneTriangle() {\n    TriangleData tri; decodeTriangleData(tri);\n    fsHalfWidth = 0.0;\n    fsMultipurpose.z = 0.0;\n    float vertexId = getVertexId();\n    if (vertexId == VBB_SEG_END_RIGHT)\n        offsetPosition.xy = tri.p1;\n    else if (vertexId == VBB_SEG_END_LEFT)\n        offsetPosition.xy = tri.p2;\n}\n#endif\n#ifdef HAS_RASTER_QUADS\nstruct TexQuadData { float angle; vec2 size; };\nvoid decodeTexQuadData(out TexQuadData quad) {\n    quad.angle     = fields1.z;\n    quad.size   = fields2.xy;\n}\nvoid strokeTexQuad() {\n    TexQuadData quad; decodeTexQuadData(quad);\n    vec2 corner = vec2(isLeftVertex() ? -1.0 : 1.0, isStartVertex() ? -1.0 : 1.0);\n    vec2 p      = 0.5 * corner * quad.size;\n    vec2 rot    = cos_sin(quad.angle);\n    vec2 offset = vec2(p.x * rot.x - p.y * rot.y, p.x * rot.y + p.y * rot.x);\n    offsetPosition.xy += offset;\n    fsMultipurpose.xy = max(vec2(0.0), corner);\n    fsMultipurpose.z = 1.0;\n    fsHalfWidth = 0.0;\n}\n#endif\n#if defined(HAS_CIRCLES) || defined(HAS_ELLIPTICALS)\nstruct ArcData { vec2 c; float start, end, major, minor, tilt; };\nvoid decodeArcData(out ArcData arc) {\n    arc.c     = fields1.xy;\n    arc.start = fields1.z;\n    arc.end   = fields2.x;\n    arc.major = fields2.z;\n#if defined(HAS_ELLIPTICALS)\n    arc.minor = extraParams.x;\n    arc.tilt  = extraParams.y;\n#endif\n}\nvoid strokeArc(const ArcData arc) {\n    float isStart = isStartVertex() ? -1.0 : 1.0;\n    float isLeft  = isLeftVertex()  ? -1.0 : 1.0;\n    vec2 minPt;\n    vec2 maxPt;\n    vec2 angles = vec2(arc.start, arc.end);\n    vec2 endsX = vec2(arc.c.x) + arc.major * cos(angles);\n    vec2 endsY = vec2(arc.c.y) + arc.minor * sin(angles);\n    minPt = maxPt = vec2(endsX.x, endsY.x);\n    min_max(minPt, maxPt, vec2(endsX.y, endsY.y));\n    if (arc.end > arc.start) {\n        if (arc.start < PI_0_5 && arc.end > PI_0_5) {\n            min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y + arc.minor));\n        }\n        if (arc.start < PI && arc.end > PI) {\n            min_max(minPt, maxPt, vec2(arc.c.x - arc.major, arc.c.y));\n        }\n        if (arc.start < PI_1_5 && arc.end > PI_1_5) {\n            min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y - arc.minor));\n        }\n    } else {\n        min_max(minPt, maxPt, vec2(arc.c.x + arc.major, arc.c.y));\n        if (arc.start < PI_0_5 || arc.end > PI_0_5) {\n            min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y + arc.minor));\n        }\n        if (arc.start < PI || arc.end > PI) {\n            min_max(minPt, maxPt, vec2(arc.c.x - arc.major, arc.c.y));\n        }\n        if (arc.start < PI_1_5 || arc.end > PI_1_5) {\n            min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y - arc.minor));\n        }\n    }\n    minPt -= fsHalfWidth + aaRange;\n    maxPt += fsHalfWidth + aaRange;\n    offsetPosition.x = (isStart < 0.0) ? minPt.x : maxPt.x;\n    offsetPosition.y = (isLeft < 0.0)  ? minPt.y : maxPt.y;\n    fsMultipurpose.x = arc.start;\n    fsMultipurpose.y = -arc.major;\n    fsMultipurpose.z = arc.end;\n    fsMultipurpose.w = arc.minor;\n}\n#endif\n#if defined(HAS_CIRCLES)\nvoid strokeCircularArc() {\n    ArcData arc; decodeArcData(arc);\n    float r = arc.major;\n    if (r * pixelsPerUnit < 0.125)\n        r = 0.25 * aaRange;\n    arc.major = arc.minor = r;\n    strokeArc(arc);\n}\n#endif\n#if defined(HAS_ELLIPTICALS)\nvoid strokeEllipticalArc() {\n    ArcData arc; decodeArcData(arc);\n    strokeArc(arc);\n}\n#endif\nstruct CommonAttribs { vec2 pos; vec4 color; vec2 layerTC, vpTC; float lineWidthHalf, geomType, ghosting; };\nvoid decodeCommonAttribs(out CommonAttribs attribs) {\n    attribs.pos           = fields1.xy;\n    attribs.color         = color4b;\n    attribs.geomType      = flags4b.y;\n    attribs.layerTC       = layerVp4b.xy / 255.0;\n    attribs.vpTC          = layerVp4b.zw / 255.0;\n    attribs.lineWidthHalf = fields2.y;\n    attribs.ghosting      = flags4b.w;\n}\nvoid strokeIndexedTriangle() {\n    fsHalfWidth = 0.0;\n    fsMultipurpose.z = 0.0;\n}\n#ifdef SELECTION_RENDERER\nbool isSelected(const CommonAttribs attribs) {\n    vec3 oid = dbId4b.rgb;\n    float id01 = oid.r + oid.g * 256.0;\n    float t = (id01 + 0.5) * (1.0 / 4096.0);\n    float flrt = floor(t);\n    float texU = t - flrt;\n    float id23 = oid.b * (65536.0 / 4096.0) + flrt;\n    t = (id23 + 0.5) / vSelTexSize.y;\n    float texV = fract(t);\n    vec4 selBit = texture2D(tSelectionTexture, vec2(texU, texV));\n    return selBit.r == 1.0;\n}\n#endif\nbool isLayerOff(const CommonAttribs attribs) {\n#ifdef HAS_LAYERS\n    vec4 layerBit = texture2D(tLayerMask, attribs.layerTC);\n    return (layerBit.r == 0.0);\n#else\n    return false;\n#endif\n}\nvec4 getColor(const CommonAttribs attribs) {\n    if (isLayerOff(attribs)) { return vec4(0.0); }\n#ifdef SELECTION_RENDERER\n    if (isSelected(attribs)) { return selectionColor; }\n    return vec4(0.0);\n#else\n    return attribs.color;\n#endif\n}\nvoid main() {\n    CommonAttribs attribs; decodeCommonAttribs(attribs);\n    fsColor = getColor(attribs);\n    if (swap != 0.0 ) {\n        if ( fsColor.r == 0.0 && fsColor.g == 0.0 && fsColor.b == 0.0 )\n            fsColor.rgb = vec3(1.0,1.0,1.0);\n        else if ( fsColor.r == 1.0 && fsColor.g == 1.0 && fsColor.b == 1.0 )\n            fsColor.rgb = vec3(0.0,0.0,0.0);\n    }\n    centralVertex = offsetPosition = attribs.pos;\n    float lineWeight = attribs.lineWidthHalf;\n    if (lineWeight > 0.0) {\n        if(lineWeight < 0.5 / pixelsPerUnit) {\n            lineWeight = 0.5 / pixelsPerUnit;\n        }\n    }\n    else {\n        lineWeight = abs(lineWeight) / pixelsPerUnit;\n    }\n    fsHalfWidth = lineWeight;\n    dbId = dbId4b / 255.0;\n    fsVpTC     = attribs.vpTC;\n    fsGhosting = attribs.ghosting;\n    if      (attribs.geomType == VBB_GT_LINE_SEGMENT)     strokeLineSegment();\n#ifdef HAS_CIRCLES\n    else if (attribs.geomType == VBB_GT_ARC_CIRCULAR)     strokeCircularArc();\n#endif\n#ifdef HAS_ELLIPTICALS\n    else if (attribs.geomType == VBB_GT_ARC_ELLIPTICAL)   strokeEllipticalArc();\n#endif\n#ifdef HAS_RASTER_QUADS\n    else if (attribs.geomType == VBB_GT_TEX_QUAD)         strokeTexQuad();\n#endif\n#ifdef HAS_TRIANGLE_GEOMS\n    else if (attribs.geomType == VBB_GT_ONE_TRIANGLE)     strokeOneTriangle();\n#endif\n    else if (attribs.geomType == VBB_GT_TRIANGLE_INDEXED) strokeIndexedTriangle();\n    fsOffsetDirection = offsetPosition - centralVertex;\n    gl_Position = mvpMatrix * modelMatrix * vec4( offsetPosition.xy, 0.0, 1.0 );\n}\n",fragmentShader:"\n#include<line_decl_common>\nuniform highp float pixelsPerUnit;\nuniform highp float aaRange;\nuniform float opacity;\nuniform highp float viewportId;\nuniform highp float swap;\n#ifdef HAS_RASTER_QUADS\nuniform sampler2D tRaster;\n#endif\n#ifdef HAS_LINESTYLES\nuniform sampler2D tLineStyle;\nuniform vec2 vLineStyleTexSize;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\nuniform vec3 modelId;\n#endif\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 2.0;\n    return exp(-exponent*exponent);\n}\n#ifdef HAS_LINESTYLES\nfloat getLinePatternPixel(int i, int j) {\n    return texture2D(tLineStyle, (vec2(i, j) + 0.5) / vLineStyleTexSize).x * 255.0;\n}\nfloat getPatternLength(int whichPattern) {\n    float p1 = getLinePatternPixel(0, whichPattern);\n    float p2 = getLinePatternPixel(1, whichPattern);\n    return (p2 * 256.0 + p1);\n}\n#endif\nvoid fillLineSegment() {\n    float radius = abs(fsHalfWidth);\n    float parametricDistance = fsMultipurpose.x;\n    float segmentLength      = fsMultipurpose.y;\n    float totalDistance      = fsMultipurpose.z;\n#ifdef HAS_LINESTYLES\n    int whichPattern         = int(fsMultipurpose.w);\n    if (whichPattern > 0) {\n        const float TEX_TO_UNIT = 1.0 / 96.0;\n        float LTSCALE = 1.0;\n        float patternScale;\n        if (fsHalfWidth < 0.0) {\n            patternScale = LTSCALE;\n        } else {\n            patternScale = LTSCALE * TEX_TO_UNIT * pixelsPerUnit;\n        }\n        float patLen = patternScale * getPatternLength(whichPattern);\n        float phase = mod((totalDistance + parametricDistance) * pixelsPerUnit, patLen);\n        bool onPixel = true;\n        float radiusPixels = radius * pixelsPerUnit;\n        for (int i=2; i<MAX_LINESTYLE_LENGTH; i+=2) {\n            float on = getLinePatternPixel(i, whichPattern);\n            if (on == 1.0) on = 0.0;\n            on *= patternScale;\n            onPixel = true;\n            phase -= on;\n            if (phase < 0.0) {\n                break;\n            }\n            else if (phase <= radiusPixels) {\n                onPixel = false;\n                break;\n            }\n            float off = getLinePatternPixel(i+1, whichPattern);\n            if (off <= 1.0) off = 0.0;\n            off *= patternScale;\n            onPixel = false;\n            phase -= off;\n            if (phase < -radiusPixels)\n                discard;\n            if (phase <= 0.0)\n                break;\n        }\n        if (!onPixel && (abs(phase) <= radiusPixels)) {\n            segmentLength = 0.0;\n            parametricDistance = phase / pixelsPerUnit;\n        }\n    }\n#endif\n    float dist;\n    float offsetLength2 = dot(fsOffsetDirection, fsOffsetDirection);\n    float ltz = max(0.0, sign(-parametricDistance));\n    float gtsl = max(0.0, sign(parametricDistance - segmentLength));\n    float d = (ltz + gtsl) * (parametricDistance - gtsl * segmentLength);\n    dist = sqrt(max(0.0, offsetLength2 + d*d));\n    float range =  dist - radius;\n    if (range > aaRange) {\n        discard;\n    }\n    gl_FragColor = fsColor;\n    gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);\n}\n#ifdef HAS_CIRCLES\nvoid fillCircularArc() {\n    float dist   = length(fsOffsetDirection);\n    vec2 angles  = fsMultipurpose.xz;\n    float radius = abs(fsMultipurpose.y);\n    float range  =  abs(dist - radius);\n    range -= fsHalfWidth;\n    if (range > aaRange) {\n        discard;\n    }\n    vec2 direction = fsOffsetDirection;\n    float angle = atan(direction.y, direction.x);\n    if (angles.x > angles.y) {\n        if (angle > angles.x && angle < PI) {\n            angle -= TAU;\n        }\n        angles.x -= TAU;\n        if (angle < angles.x ) {\n            angle += TAU;\n        }\n    }\n    else if (angle < 0.0)\n        angle += TAU;\n    if (angle > angles.x && angle < angles.y) {\n        gl_FragColor = fsColor;\n        gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);\n    }\n    else {\n        discard;\n    }\n}\n#endif\n#ifdef HAS_ELLIPTICALS\nfloat EllipticalApprox(\n        const int iters,\n        inout float t0, inout float t1,\n        const vec2 y,   out   vec2 x,\n        const vec2 e,   const vec2 ey, const vec2 esqr\n        ) {\n    vec2 r;\n    for (int i = 0; i < 10; ++i) {\n        if(i >= iters) break;\n        float t = mix(t0, t1, 0.5);\n        r = ey / (vec2(t) + esqr);\n        vec2 rsq = r * r;\n        float f = rsq.x + rsq.y - 1.0;\n        if(f > 0.0) { t0 = t; } else { t1 = t; }\n    }\n    x = e * r;\n    return distance(x, y);\n}\nfloat DistancePointEllipseSpecial (vec2 e, vec2 y, out vec2 x, float width, float aaRange) {\n    float dist;\n    vec2 esqr = e * e;\n    vec2 ey   = e * y;\n    float t0 = -esqr[1] + ey[1];\n    float t1 = -esqr[1] + length(ey);\n    dist = EllipticalApprox(6, t0, t1, y, x, e, ey, esqr);\n    if (dist > max(2.0 * (width + aaRange), e[0] * 0.05))\n        return dist;\n    dist = EllipticalApprox(6, t0, t1, y, x, e, ey, esqr);\n    float ecc = 1.0 +  0.1 * e[0] / e[1];\n    if (dist > max(ecc * (width + aaRange), e[0] * 0.001))\n        return dist;\n    if (dist < (width - aaRange) / ecc)\n        return dist;\n    dist = EllipticalApprox(10, t0, t1, y, x, e, ey, esqr);\n    return dist;\n}\nfloat DistancePointEllipse(vec2 e, vec2 y, out vec2 locX, float width, float aaRange) {\n    vec2 locE, locY;\n    float diff = sign(e[0] - e[1]);\n    vec2 swizzle = vec2(max(diff, 0.0), -min(diff, 0.0));\n    locE.x = dot(e, swizzle.xy);\n    locE.y = dot(e, swizzle.yx);\n    locY.x = dot(y, swizzle.xy);\n    locY.y = dot(y, swizzle.yx);\n    vec2 refl = sign(locY);\n    locY *= refl;\n    vec2 x;\n    float distance = DistancePointEllipseSpecial(locE, locY, x, width, aaRange);\n    x *= refl;\n    locX.x = dot(x, swizzle.xy);\n    locX.y = dot(x, swizzle.yx);\n    return distance;\n}\nvoid fillEllipticalArc() {\n    vec2 angles = fsMultipurpose.xz;\n    vec2 radii  = abs(fsMultipurpose.yw);\n    vec2 dir    = fsOffsetDirection;\n    vec2 pos;\n    float range = DistancePointEllipse(radii, dir, pos, fsHalfWidth, aaRange);\n    range -= fsHalfWidth;\n    if (range > aaRange)\n        discard;\n    float ar = radii[0] / radii[1];\n    float angle = atan(ar * pos.y, pos.x);\n    if (angles.x > angles.y) {\n        if (angle > angles.x && angle < PI) {\n            angle -= TAU;\n        }\n        angles.x -= TAU;\n        if (angle < angles.x ) {\n            angle += TAU;\n        }\n    }\n    else if (angle < 0.0)\n        angle += TAU;\n    if (angle > angles.x && angle < angles.y) {\n        gl_FragColor = fsColor;\n        gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);\n    }\n    else {\n        discard;\n    }\n}\n#endif\n#ifdef HAS_RASTER_QUADS\nvoid fillTexQuad() { gl_FragColor = texture2D(tRaster, fsMultipurpose.xy); }\n#endif\nvoid fillTriangle() { gl_FragColor = fsColor; }\nvoid main() {\n    if (fsColor == vec4(0.0)) {\n        discard;\n    }\n    if (fsHalfWidth == 0.0) {\n#ifdef HAS_RASTER_QUADS\n        if (fsMultipurpose.z != 0.0)\n            fillTexQuad();\n        else\n#endif\n            fillTriangle();\n    }\n    else if (fsMultipurpose.y < 0.0) {\n#ifdef HAS_CIRCLES\n#ifdef HAS_ELLIPTICALS\n        if (abs(fsMultipurpose.y) == fsMultipurpose.w)\n#endif\n            fillCircularArc();\n#endif\n#ifdef HAS_ELLIPTICALS\n#ifdef HAS_CIRCLES\n        else\n#endif\n            fillEllipticalArc();\n#endif\n    }\n    else\n        fillLineSegment();\n#ifdef MRT_NORMALS\n    gl_FragData[1] = vec4(0.0);\n#endif\n    float writeId = 1.0;\n    if (fsGhosting != 0.0 || \n            ((viewportId != 0.0) && (abs(fsVpTC.x * 255.0 + fsVpTC.y) >= 0.5 && abs(fsVpTC.x * 255.0 + fsVpTC.y - viewportId) >= 0.5))) {\n        writeId = 0.0;\n        gl_FragColor.a *= opacity * ((swap == 1.0) ? 0.21 : 0.1);\n    } else {\n        gl_FragColor.a *= opacity;\n    }\n#include<id_frag>\n}\n"},lc={uniforms:{color:{type:"v3",value:new THREE.Vector3(0,0,0)},opacity:{type:"f",value:1}},rawShader:!0,vertexShader:"\n#include<instancing_decl_vert>\nvarying vec4 finalColor;\nuniform vec3 color;\nuniform float opacity;\nvoid main() {\n    gl_Position = projectionMatrix * (viewMatrix * vec4(getInstancePos(position), 1.0));\n    finalColor = vec4(color, opacity);\n}\n",fragmentShader:"precision lowp float;\nvarying vec4 finalColor;\nvoid main() {\n    gl_FragColor = finalColor;\n}\n"},mc=function(a){var b={vertexShader:a.vertexShader,fragmentShader:a.fragmentShader};return a.uniforms&&(b.uniforms=THREE.UniformsUtils.clone(a.uniforms)),a.defines&&(b.defines=THREE.UniformsUtils.clone(a.defines)),a.attributes&&(b.attributes=a.attributes),new THREE.ShaderMaterial(b)},nc=function(a,b,c){c=c||"",a.defines||(a.defines={}),a.defines[b]!=c&&(a.defines[b]=c,a.needsUpdate=!0)},oc=function(a,b){(a.defines||a.defines[b])&&(delete a.defines[b],a.needsUpdate=!0)},pc={createShaderMaterial:mc,setMacro:nc,removeMacro:oc},qc=function(a,b){this.textureID=void 0!==b?b:"tDiffuse",this.material=pc.createShaderMaterial(a),this.uniforms=this.material.uniforms,this.renderToScreen=!1,this.enabled=!0,this.clear=!1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);var c=new THREE.BufferGeometry,d=new Float32Array(9);d[0]=-1,d[1]=-1,d[2]=0,d[3]=3,d[4]=-1,d[5]=0,d[6]=-1,d[7]=3,d[8]=0;var e=new Float32Array(6);e[0]=0,e[1]=0,e[2]=2,e[3]=0,e[4]=0,e[5]=2;var f=new Float32Array(9);f[0]=0,f[1]=0,f[2]=1,f[3]=0,f[4]=0,f[5]=1,f[6]=0,f[7]=0,f[8]=1,c.addAttribute("position",new THREE.BufferAttribute(d,3)),c.addAttribute("normal",new THREE.BufferAttribute(f,3)),c.addAttribute("uv",new THREE.BufferAttribute(e,2)),this.quad=new THREE.Mesh(c,this.material),this.scene=new THREE.Scene,this.scene.add(this.quad)};qc.prototype={render:function(a,b,c,d){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=c),this.renderToScreen||!b?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,this.clear)}};var rc={uniforms:{tDiffuse:{type:"t",value:null},uColor:{type:"v4",value:new THREE.Vector4(1,1,1,1)}},vertexShader:"varying vec2 vUv;\nvoid main() {\n#if defined(HORIZONTAL) && defined(FLIP_UV)\n    vUv = vec2(uv.x, 1.0-uv.y);\n#else\n    vUv = vec2(uv.x, uv.y);\n#endif\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec4 uColor;\nvarying vec2 vUv;\n#ifdef HORIZONTAL\n#define GET_UV(X) vec2(vUv.x + KERNEL_SCALE_H*(X), vUv.y)\n#else\n#define GET_UV(Y) vec2(vUv.x, vUv.y + KERNEL_SCALE_V*(Y))\n#endif\n#define PI 3.14159265358979\n#define SIGMA ((KERNEL_RADIUS+KERNEL_RADIUS+1.0) / 6.0)\n#define SIGMASQ2 (2.0 * SIGMA * SIGMA)\n#define GAUSSIAN(X) ( (1.0 / sqrt(PI * SIGMASQ2)) * exp(-(X)*(X)/SIGMASQ2) )\nvoid main() {\n    vec4 texColSum = vec4(0.0);\n    float gaussSum = 0.0;\n    for (float x=-KERNEL_RADIUS; x<=KERNEL_RADIUS; x+=1.0) {\n        float gauss = GAUSSIAN(x);\n        vec4 texCol = texture2D(tDiffuse, GET_UV(x));\n#ifdef HAS_ALPHA\n        texCol.rgb *= texCol.a;\n#endif\n        texColSum += texCol * gauss;\n        gaussSum += gauss;\n    }\n#ifdef HAS_ALPHA\n    texColSum.rgb /= (texColSum.a == 0.0 ? 0.0001 : texColSum.a);\n#endif\n#ifdef HORIZONTAL\n    gl_FragColor = texColSum/gaussSum;\n#else\n    gl_FragColor = texColSum/gaussSum * uColor;\n#endif\n}\n"},sc=function(a,b,c,d,e){var f,g,h,i=a,j=b,k=c||3,l=d||1,m={hasAlpha:e.hasAlpha||!1,blending:e.blending||!1,flipUV:e.flipUV||!1};this.render=function(a,b,c){f.render(a,h,c),g.render(a,b,h)},this.setSize=function(a,b){this.cleanup(),i=a,j=b,h=new THREE.WebGLRenderTarget(a,b,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:void 0!==e.format?e.format:THREE.RGBAFormat,type:void 0!==e.type?e.type:THREE.UnsignedByteType,stencilBuffer:!1}),h.generateMipmaps=!1,f.material.defines.KERNEL_SCALE_H=g.material.defines.KERNEL_SCALE_H=(l/i).toFixed(4),f.material.defines.KERNEL_SCALE_V=g.material.defines.KERNEL_SCALE_V=(l/j).toFixed(4),f.material.needsUpdate=g.material.needsUpdate=!0},this.cleanup=function(){h&&h.dispose()},this.setColor=function(a){g.material.uniforms.uColor.value.x=a.r,g.material.uniforms.uColor.value.y=a.g,g.material.uniforms.uColor.value.z=a.b},this.setAlpha=function(a){g.material.uniforms.uColor.value.w=a},f=new qc(rc),g=new qc(rc),this.setSize(a,b),f.material.blending=g.material.blending=THREE.NoBlending,f.material.depthWrite=g.material.depthWrite=!1,f.material.depthTest=g.material.depthTest=!1,f.material.defines.HORIZONTAL=1,f.material.defines.KERNEL_RADIUS=g.material.defines.KERNEL_RADIUS=k.toFixed(1),m.blending&&(g.material.transparent=!0,g.material.blending=THREE.NormalBlending),m.hasAlpha&&(f.material.defines.HAS_ALPHA=g.material.defines.HAS_ALPHA=""),m.flipUV&&(f.material.defines.FLIP_UV="")},tc="undefined"!=typeof navigator?navigator.userAgent.toLowerCase():"",uc=function(){return tc.match(/ip(ad|hone|od)/)},vc=function(){return-1!==tc.indexOf("android")},wc=function(){return uc()||vc()},xc=function(){return-1!==tc.indexOf("safari")&&-1===tc.indexOf("chrome")},yc=function(){return-1!==tc.indexOf("firefox")},zc=function(){return-1!==tc.indexOf("mac os")},Ac=function(){return-1!==tc.indexOf("win32")||-1!==tc.indexOf("windows")},Bc=function(){return"undefined"==typeof navigator},Cc=function(){return xc()?function(a){if(!window.Polymer)return a;for(var b in a)if(-1!==b.indexOf("__impl"))return a[b];return a}:function(a){return a}}(),Dc=function(a){if(-1!==a.indexOf("://")||0===a.indexOf("urn:"))return a;if("undefined"==typeof window)return a;var b=window.location.pathname,c=b.lastIndexOf("/");return b=b.substr(0,c+1),window.location.protocol+"//"+window.location.host+b+a};a.assets=[];var Ec=function(){a.assets=null};a.memoryOptimizedLoading=!0;var Fc=function(b){a.memoryOptimizedLoading=b},Gc=1024*(wc()?64:256)*1024,Hc=wc()?2500:1e4,Ic=1,Jc=1,Kc=2,Lc=0,Mc=1,Nc=2,Oc=4,Pc=16,Qc=32,Rc=64,Sc=128,Tc=0,Uc=1,Vc=2,Wc={uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:bc,fragmentShader:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n    vec4 texel = texture2D( tDiffuse, vUv );\n    gl_FragColor = texel;\n}\n"},Xc=function(a,b,c,d){var e,f,g,h,i,j,k=a,l=k.getContext(),m=b||512,n=c||512,o=!1,p=new THREE.Color(0,0,0),q=!1,r=!1;this.inTarget=void 0,this.outTarget=void 0;var s=!0,t=0,u={color:new THREE.Color(1,1,1),alpha:.3,texScale:.5,blurRadius:2,blurTexScale:.5,fadeAngle:Math.PI/18},v=function(a){var b=a.normal,c=a.constant;return(new THREE.Matrix4).set(1-2*b.x*b.x,-2*b.y*b.x,-2*b.x*b.z,-2*c*b.x,-2*b.x*b.y,1-2*b.y*b.y,-2*b.y*b.z,-2*c*b.y,-2*b.x*b.z,-2*b.y*b.z,1-2*b.z*b.z,-2*c*b.z,0,0,0,1)};if(this.setTransform=function(a,b,c){h=a,g.normal=b,g.constant=-a.dot(b)},this.cleanup=function(){e&&e.cleanup(),this.inTarget&&this.inTarget.dispose(),this.outTarget&&this.outTarget.dispose()},this.setSize=function(a,b){m=a,n=b,this.cleanup(),this.inTarget=new THREE.WebGLRenderTarget(m*u.texScale,n*u.texScale,{magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1}),this.inTarget.generateMipmaps=!1,this.outTarget=new THREE.WebGLRenderTarget(m*u.texScale,n*u.texScale,{magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1}),this.outTarget.generateMipmaps=!1,e?e.setSize(m*u.texScale*u.blurTexScale,n*u.texScale*u.blurTexScale):e=new sc(m*u.texScale*u.blurTexScale,n*u.texScale*u.blurTexScale,u.blurRadius,1,{hasAlpha:!0,blending:!0,flipUV:!0})},this.updateCamera=function(a){var b;b=a.isPerspective?h.clone():a.target.clone();var c=a.position.clone().sub(b).normalize(),d=Math.PI/2-c.angleTo(g.normal);if(!(o=d<0)){if(u.fadeAngle>0){var f=Math.min(u.fadeAngle,d)/u.fadeAngle;e.setAlpha(f*u.alpha)}var j=v(g);i=a.clone(),i.applyMatrix(j),i.projectionMatrix.elements[5]*=-1,i.matrixWorldNeedsUpdate=!0,a.worldUpTransform?i.worldUpTransform=a.worldUpTransform.clone():i.worldUpTransform=new THREE.Matrix4}},this.renderIntoReflection=function(a){o||k.render(a,i,this.inTarget)},this.prepareGroundReflection=function(){var a,b=0,c=0,d=0;return function(e,f,g,h,i,j){var k=f.modelQueue();if(0!==t||k.isEmpty())return t=1,i;if(a!=k.getGeomScenes()&&(s=!0),s){if(s=!1,this.updateCamera(f.camera),this.isGroundCulled())return t=1,i;this.clear(),a=k.getGeomScenes(),b=a.length,c=0,d=h?Math.max(Math.ceil(b/100),h):b,t=0}else{if(0!==t)return t=1,i;0===h&&(d=b)}var l,m;i&&(l=performance.now(),j=void 0===j?1:j,m=j*i);for(var n,o=0;o<d&&c<b;){var p=a[c++];if(p&&(o++,p.forceVisible=!0,this.renderIntoReflection(p),p.forceVisible=!1,i)){var q=performance.now()-l;if(m<q&&c<b){t=0,n=i-q;break}}}return c<b&&(t=0,n=i?i-performance.now()+l:1),void 0===n||g?(this.postprocess(f.camera,f.matman()),e&&e.enabled&&f.renderGroundShadow(this.outTarget),this.renderReflection(f.camera,f.renderer().getColorTarget()),void 0===n&&(t=2),i?i-performance.now()+l:1):n}}(),this.renderReflection=function(a,b){o||(l.depthRange(.999999,1),f.render(k,b,this.outTarget),l.depthRange(0,1))},this.toggleEnvMapBackground=function(a){r=a,j.uniforms.envMapBackground.value=a},this.postprocess=function(a){o||(q||r?(j.uniforms.uCamDir.value=a.worldUpTransform?a.getWorldDirection().clone().applyMatrix4(a.worldUpTransform):a.getWorldDirection(),j.uniforms.uCamUp.value=a.worldUpTransform?a.up.clone().applyMatrix4(a.worldUpTransform):a.up,j.uniforms.uResolution.value.set(m,n),j.uniforms.uHalfFovTan.value=Math.tan(THREE.Math.degToRad(.5*a.fov)),j.render(k,this.outTarget),k.clearTarget(this.outTarget,!1,!0,!1)):(k.setClearColor(p,1),k.clearTarget(this.outTarget,!0,!0,!1)),e.render(k,this.outTarget,this.inTarget))},this.clear=function(){k.setClearColor(p,0),k.clearTarget(this.inTarget,!0,!0,!1),k.clearBlend()},this.setClearColors=function(a,b,c){b?(p.setRGB(.5*(a.x+b.x),.5*(a.y+b.y),.5*(a.z+b.z)),q=!a.equals(b)&&!c):(p.copy(a),q=!1),q&&(j.uniforms.color1.value.copy(a),j.uniforms.color2.value.copy(b))},this.setEnvRotation=function(a){j.material.envRotationSin=Math.sin(a),j.material.envRotationCos=Math.cos(a)},this.isGroundCulled=function(){return o},this.getStatus=function(){return t},this.setDirty=function(){s=!0,t=0},this.setColor=function(a){e.setColor(u.color),u.color.set(a)},this.setAlpha=function(a){e.setAlpha(u.alpha),u.alpha=a},d)for(var w in u)u[w]=void 0!==d[w]?d[w]:u[w];f=new qc(Wc),f.material.blending=THREE.NoBlending,f.material.depthTest=!0,f.material.depthWrite=!1,f.scene.position.z=-.999999,d.clearPass?j=d.clearPass:(j=new qc(rb),j.material.blending=THREE.NoBlending,j.material.depthWrite=!1,j.material.depthTest=!1),this.setSize(m,n),e.setAlpha(u.color),e.setAlpha(u.alpha),g=new THREE.Plane(new THREE.Vector3(0,1,0),0),h=new THREE.Vector3(0,0,0)},Yc=function(a,b,c){var d=a.createShader(b);return a.shaderSource(d,c),a.compileShader(d),d},Zc={uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.lights,THREE.UniformsLib.fog,_b.CutPlanesUniforms,_b.IdUniforms,_b.ThemingUniform,_b.ShadowMapUniforms,_b.WideLinesUniforms,{emissive:{type:"c",value:new THREE.Color(0)},specular:{type:"c",value:new THREE.Color(1118481)},shininess:{type:"f",value:30},reflMipIndex:{type:"f",value:0},texMatrix:{type:"m3",value:new THREE.Matrix3},texMatrixBump:{type:"m3",value:new THREE.Matrix3},texMatrixAlpha:{type:"m3",value:new THREE.Matrix3},irradianceMap:{type:"t",value:null},exposureBias:{type:"f",value:1},envMapExposure:{type:"f",value:1},envRotationSin:{type:"f",value:0},envRotationCos:{type:"f",value:1}}]),vertexShader:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform mat3 texMatrix;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec2 vUvBump;\nuniform mat3 texMatrixBump;\n#endif\n#if defined( USE_ALPHAMAP )\nvarying vec2 vUvAlpha;\nuniform mat3 texMatrixAlpha;\n#endif\n#if defined( USE_ENVMAP )\n#if ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nuniform float refractionRatio;\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\n#endif\nuniform float logDepthBufFC;\n#endif\n#ifdef MRT_NORMALS\nvarying float depth;\n#endif\n#include<pack_normals>\n#include<instancing_decl_vert>\n#include<id_decl_vert>\n#include<wide_lines_decl>\n#include<shadowmap_decl_vert>\nvoid main() {\n#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\n    vUv = (texMatrix * vec3(uv, 1.0)).xy;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n    vUvBump = (texMatrixBump * vec3(uv, 1.0)).xy;\n#endif\n#if defined( USE_ALPHAMAP )\n    vUvAlpha = (texMatrixAlpha * vec3(uv, 1.0)).xy;\n#endif\n#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\n    vColor = color * color;\n#else\n    vColor = color;\n#endif\n#endif\n#ifdef UNPACK_NORMALS\n    vec3 objectNormal = decodeNormal(normal);\n#else\n    vec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n    objectNormal = getInstanceNormal(objectNormal);\n    vec3 instPos = getInstancePos(position);\n    vec3 transformedNormal = normalMatrix * objectNormal;\n#ifndef FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n#endif\n    vec4 mvPosition = modelViewMatrix * vec4( instPos, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n#include<wide_lines_vert>\n    vViewPosition = -mvPosition.xyz;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( instPos, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#ifdef USE_LOGDEPTHBUF\n    if (projectionMatrix[3][3] == 0.0) {\n        gl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + gl_Position.w;\n#else\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n#endif\n    } else {\n#ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + vViewPosition.z;\n#else\n#endif\n    }\n#endif\n#ifdef MRT_NORMALS\n    depth = mvPosition.z;\n#endif\n#include<shadowmap_vert>\n#include<id_vert>\n}\n",
fragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\n#include<env_sample>\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n#ifdef GAMMA_INPUT\nvec3 InputToLinear(vec3 c) {\n    return c * c;\n}\nfloat InputToLinear(float c) {\n    return c * c;\n}\n#else\nvec3 InputToLinear(vec3 c) {\n    return c;\n}\nfloat InputToLinear(float c) {\n    return c;\n}\n#endif\n#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec2 vUvBump;\n#endif\n#if defined( USE_ALPHAMAP )\nvarying vec2 vUvAlpha;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\n#include<tonemap>\n#endif\n#if defined(IRR_RGBM) || defined(ENV_RGBM) || defined(ENV_GAMMA) || defined(IRR_GAMMA)\nuniform float envMapExposure;\n#endif\n#ifdef USE_FOG\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#include<id_decl_frag>\n#include<theming_decl_frag>\n#include<shadowmap_decl_frag>\n#ifdef USE_ENVMAP\nuniform float reflMipIndex;\nuniform float reflectivity;\nuniform samplerCube envMap;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform float refractionRatio;\n#endif\nvec3 sampleReflection(vec3 dir, float mipIndex) {\n    vec3 adjDir = adjustLookupVector(dir);\n#ifdef ENV_GAMMA\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, adjDir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, adjDir, mipIndex );\n#endif\n    return GammaDecode(envTexColor, envMapExposure);\n#elif defined(ENV_RGBM)\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, adjDir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, adjDir, mipIndex );\n#endif\n    return RGBMDecode(envTexColor, envMapExposure);\n#else\n    vec4 envTexColor = textureCube( envMap, adjDir );\n    vec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\n    cubeColor *= cubeColor;\n#endif\n    return cubeColor;\n#endif\n}\n#endif\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef USE_IRRADIANCEMAP\nuniform samplerCube irradianceMap;\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying highp vec3 vWorldPosition;\n#endif\nvarying highp vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying highp vec3 vNormal;\n#endif\n#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\n    vec2 dSTdx = dFdx( vUvBump );\n    vec2 dSTdy = dFdy( vUvBump );\n    float Hll = bumpScale * GET_BUMPMAP(vUvBump).x;\n    float dBx = bumpScale * GET_BUMPMAP(vUvBump + dSTdx).x - Hll;\n    float dBy = bumpScale * GET_BUMPMAP(vUvBump + dSTdy).x - Hll;\n    return vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n    vec3 vSigmaX = dFdx( surf_pos );\n    vec3 vSigmaY = dFdy( surf_pos );\n    vec3 vN = surf_norm;\n    vec3 R1 = cross( vSigmaY, vN );\n    vec3 R2 = cross( vN, vSigmaX );\n    float fDet = dot( vSigmaX, R1 );\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif\n#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n    vec3 q0 = dFdx( eye_pos.xyz );\n    vec3 q1 = dFdy( eye_pos.xyz );\n    vec2 st0 = dFdx( vUvBump.st );\n    vec2 st1 = dFdy( vUvBump.st );\n    vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n    vec3 N = normalize( surf_norm );\n    vec3 mapN = GET_NORMALMAP(vUvBump).xyz * 2.0 - 1.0;\n    mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n    return normalize( tsn * mapN );\n}\n#endif\n#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif\n#include<hatch_pattern>\n#ifdef USE_LOGDEPTHBUF\nuniform float logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n#extension GL_EXT_frag_depth : enable\nvarying highp float vFragDepth;\n#endif\n#endif\nvec3 Schlick_v3(vec3 v, float cosHV) {\n    float facing = max(1.0 - cosHV, 0.0);\n    float facing2 = facing * facing;\n    return v + (1.0 - v) * facing * facing2 * facing2;\n}\nfloat Schlick_f(float v, float cosHV) {\n    float facing = max(1.0 - cosHV, 0.0);\n    float facing2 = facing * facing;\n    return v + ( 1.0 - v ) * facing2 * facing2 * facing;\n}\n#include<cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n#ifdef USE_MAP\n    vec4 texelColor = GET_MAP(vUv);\n#ifdef MAP_INVERT\n    texelColor.xyz = 1.0-texelColor.xyz;\n#endif\n#ifdef GAMMA_INPUT\n    texelColor.xyz *= texelColor.xyz;\n#endif\n    gl_FragColor = gl_FragColor * texelColor;\n#endif\n#ifdef USE_ALPHAMAP\n    vec4 texelAlpha = GET_ALPHAMAP(vUvAlpha);\n    gl_FragColor.a *= texelAlpha.r;\n#endif\n#ifdef ALPHATEST\n    if ( gl_FragColor.a < ALPHATEST ) discard;\n#endif\n    float specularStrength;\n#ifdef USE_SPECULARMAP\n    vec4 texelSpecular = GET_SPECULARMAP(vUv);\n    specularStrength = texelSpecular.r;\n#else\n    specularStrength = 1.0;\n#endif\n#ifndef FLAT_SHADED\n    vec3 normal = normalize( vNormal );\n#ifdef DOUBLE_SIDED\n    normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#else\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n#endif\n    vec3 geomNormal = normal;\n#ifdef USE_NORMALMAP\n    normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n    normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n    vec3 viewDirection;\n    if (projectionMatrix[3][3] == 0.0) {\n        viewDirection = normalize( vViewPosition );\n    } else {\n        viewDirection = vec3(0.0, 0.0, 1.0);\n    }\n    vec3 totalDiffuse = vec3( 0.0 );\n    vec3 totalSpecular = vec3( 0.0 );\n    float shininessB = shininess * 4.0;\n#if MAX_POINT_LIGHTS > 0\n    vec3 pointDiffuse  = vec3( 0.0 );\n    vec3 pointSpecular = vec3( 0.0 );\n    for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        float lDistance = 1.0;\n        if ( pointLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n        lVector = normalize( lVector );\n        float dotProduct = dot( normal, lVector );\n        float pointDiffuseWeight = max( dotProduct, 0.0 );\n        pointDiffuse  += InputToLinear(diffuse) * InputToLinear(pointLightColor[ i ]) * pointDiffuseWeight * lDistance;\n        vec3 pointHalfVector = normalize( lVector + viewDirection );\n        float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n        float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininessB ), 0.0 );\n        float specularNormalization = shininessB * 0.125 + 0.25;\n        vec3 schlick = Schlick_v3(InputToLinear(specular), dot( lVector, pointHalfVector ) );\n        pointSpecular += schlick * InputToLinear(pointLightColor[ i ]) * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;\n    }\n    totalDiffuse += pointDiffuse;\n    totalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\n    vec3 spotDiffuse  = vec3( 0.0 );\n    vec3 spotSpecular = vec3( 0.0 );\n    for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        float lDistance = 1.0;\n        if ( spotLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n        lVector = normalize( lVector );\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n        if ( spotEffect > spotLightAngleCos[ i ] ) {\n            spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n            float dotProduct = dot( normal, lVector );\n            float spotDiffuseWeight = max( dotProduct, 0.0 );\n            spotDiffuse += InputToLinear(diffuse) * InputToLinear(spotLightColor[ i ]) * spotDiffuseWeight * lDistance * spotEffect;\n            vec3 spotHalfVector = normalize( lVector + viewDirection );\n            float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n            float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininessB ), 0.0 );\n            float specularNormalization = shininessB * 0.125 + 0.25;\n            vec3 schlick = Schlick_v3(InputToLinear(specular), dot( lVector, spotHalfVector ) );\n            spotSpecular += schlick * InputToLinear(spotLightColor[ i ]) * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n        }\n    }\n    totalDiffuse += spotDiffuse;\n    totalSpecular += spotSpecular;\n#endif\n#if MAX_DIR_LIGHTS > 0\n    vec3 dirDiffuse  = vec3( 0.0 );\n    vec3 dirSpecular = vec3( 0.0 );\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n        vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n        vec3 dirVector = normalize( lDirection.xyz );\n        float dotProduct = dot( normal, dirVector );\n        float dirDiffuseWeight = max( dotProduct, 0.0 );\n        dirDiffuse  += InputToLinear(diffuse) * InputToLinear(directionalLightColor[ i ]) * dirDiffuseWeight;\n        vec3 dirHalfVector = normalize( dirVector + viewDirection );\n        float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininessB ), 0.0 );\n        float specularNormalization = shininessB * 0.125 + 0.25;\n        vec3 schlick = Schlick_v3(InputToLinear(specular), dot( dirVector, dirHalfVector ));\n        dirSpecular += schlick * InputToLinear(directionalLightColor[ i ]) * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n    }\n    totalDiffuse += dirDiffuse;\n    totalSpecular += dirSpecular;\n#endif\n#ifdef USE_IRRADIANCEMAP\n    vec3 worldNormal = mat3(viewMatrixInverse) * normal;\n    vec3 indirectDiffuse = sampleIrradianceMap(worldNormal, irradianceMap, envMapExposure);\n    indirectDiffuse = applyEnvShadow(indirectDiffuse, worldNormal);\n    totalDiffuse += InputToLinear(diffuse) * indirectDiffuse;\n#endif\n#ifdef METAL\n    gl_FragColor.xyz = gl_FragColor.xyz * ( InputToLinear(emissive) + totalDiffuse + ambientLightColor * InputToLinear(diffuse) + totalSpecular );\n#else\n    gl_FragColor.xyz = gl_FragColor.xyz * ( InputToLinear(emissive) + totalDiffuse + ambientLightColor * InputToLinear(diffuse) ) + totalSpecular;\n#endif\n#ifdef USE_COLOR\n    gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif\n#if defined(USE_ENVMAP)\n    vec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n#ifdef ENVMAP_MODE_REFLECTION\n    reflectVec = reflect( -viewDirection, normal );\n#else \n    reflectVec = refract( -viewDirection, normal, refractionRatio );\n#endif\n#else\n    reflectVec = reflect( -viewDirection, normal );\n#endif\n    reflectVec = mat3(viewMatrixInverse) * reflectVec;\n    float reflectScale = 1.0;\n    vec3 cubeColor = sampleReflection(reflectVec, reflMipIndex);\n    cubeColor *= reflectScale;\n    float facing = dot( viewDirection, geomNormal );\n    if (facing < -1e-2)\n        facing = 1.0;\n    else\n        facing = max(1e-6, facing);\n    vec3 schlickRefl;\n#ifdef METAL\n    schlickRefl = InputToLinear(specular);\n#else\n    schlickRefl = Schlick_v3(InputToLinear(specular), facing);\n    gl_FragColor.a = mix(gl_FragColor.a, Schlick_f(gl_FragColor.a, facing), reflectivity);\n    float invSchlick = (1.0 - facing * 0.5);\n    float invSchlick2 = invSchlick * invSchlick;\n    float norm_factor = 1.0 - invSchlick * invSchlick2 * invSchlick2;\n    norm_factor = (28.0 / 23.0) * norm_factor;\n    gl_FragColor.xyz *= norm_factor * (1.0 - InputToLinear(specular));\n#endif\n    gl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;\n#ifdef CLEARCOAT\n    vec3 reflectVecClearcoat = reflect( -viewDirection, geomNormal );\n    reflectVecClearcoat = mat3(viewMatrixInverse) * reflectVecClearcoat;\n    vec3 cubeColorClearcoat = sampleReflection(reflectVecClearcoat, 0.0);\n    float schlickClearcoat = Schlick_f(InputToLinear(reflectivity), facing);\n    gl_FragColor.xyz = mix(gl_FragColor.xyz, cubeColorClearcoat * schlickClearcoat, 0.5);\n#endif\n#endif\n#if TONEMAP_OUTPUT == 1\n    gl_FragColor.xyz = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.xyz);\n#elif TONEMAP_OUTPUT == 2\n    gl_FragColor.xyz = toneMapCanonFilmic_WithGamma( exposureBias * gl_FragColor.xyz );\n#endif\n#ifdef USE_FOG\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif\n#include<theming_frag>\n#include<final_frag>\n}\n"};THREE.ShaderLib.firefly_phong=Zc;var $c,_c,ad,bd,cd,dd,ed,fd,gd,hd="undefined"!=typeof self&&self.LmvVector3?self.LmvVector3:THREE.Vector3,id={getVertexCount:j,enumMeshVertices:k,enumMeshTriangles:l,enumMeshLines:m},jd=function(a,b,c){this.x=a||0,this.y=b||0,this.z=c||0};jd.prototype={constructor:jd,set:function(a,b,c){return this.x=a,this.y=b,this.z=c,this},setX:function(a){return this.x=a,this},setY:function(a){return this.y=a,this},setZ:function(a){return this.z=a,this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw new Error("index is out of range: "+a)}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+a)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(a){return this.x=a.x,this.y=a.y,this.z=a.z,this},add:function(a,b){return void 0!==b?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b)):(this.x+=a.x,this.y+=a.y,this.z+=a.z,this)},addScalar:function(a){return this.x+=a,this.y+=a,this.z+=a,this},addVectors:function(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z,this},addScaledVector:function(a,b){return this.x+=a.x*b,this.y+=a.y*b,this.z+=a.z*b,this},sub:function(a,b){return void 0!==b?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b)):(this.x-=a.x,this.y-=a.y,this.z-=a.z,this)},subScalar:function(a){return this.x-=a,this.y-=a,this.z-=a,this},subVectors:function(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z,this},multiply:function(a,b){return void 0!==b?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b)):(this.x*=a.x,this.y*=a.y,this.z*=a.z,this)},multiplyScalar:function(a){return this.x*=a,this.y*=a,this.z*=a,this},multiplyVectors:function(a,b){return this.x=a.x*b.x,this.y=a.y*b.y,this.z=a.z*b.z,this},applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements;return this.x=e[0]*b+e[3]*c+e[6]*d,this.y=e[1]*b+e[4]*c+e[7]*d,this.z=e[2]*b+e[5]*c+e[8]*d,this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements;return this.x=e[0]*b+e[4]*c+e[8]*d+e[12],this.y=e[1]*b+e[5]*c+e[9]*d+e[13],this.z=e[2]*b+e[6]*c+e[10]*d+e[14],this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements,f=1/(e[3]*b+e[7]*c+e[11]*d+e[15]);return this.x=(e[0]*b+e[4]*c+e[8]*d+e[12])*f,this.y=(e[1]*b+e[5]*c+e[9]*d+e[13])*f,this.z=(e[2]*b+e[6]*c+e[10]*d+e[14])*f,this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z,h=a.w,i=h*b+f*d-g*c,j=h*c+g*b-e*d,k=h*d+e*c-f*b,l=-e*b-f*c-g*d;return this.x=i*h+l*-e+j*-g-k*-f,this.y=j*h+l*-f+k*-e-i*-g,this.z=k*h+l*-g+i*-f-j*-e,this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z,e=a.elements;return this.x=e[0]*b+e[4]*c+e[8]*d,this.y=e[1]*b+e[5]*c+e[9]*d,this.z=e[2]*b+e[6]*c+e[10]*d,this.normalize(),this},divide:function(a){return this.x/=a.x,this.y/=a.y,this.z/=a.z,this},divideScalar:function(a){if(0!==a){var b=1/a;this.x*=b,this.y*=b,this.z*=b}else this.x=0,this.y=0,this.z=0;return this},min:function(a){return this.x>a.x&&(this.x=a.x),this.y>a.y&&(this.y=a.y),this.z>a.z&&(this.z=a.z),this},max:function(a){return this.x<a.x&&(this.x=a.x),this.y<a.y&&(this.y=a.y),this.z<a.z&&(this.z=a.z),this},clamp:function(a,b){return this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x),this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y),this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z),this},clampScalar:function(){var a,b;return function(c,d){return void 0===a&&(a=new jd,b=new jd),a.set(c,c,c),b.set(d,d,d),this.clamp(a,b)}}(),floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();return 0!==b&&a!==b&&this.multiplyScalar(a/b),this},lerp:function(a,b){return this.x+=(a.x-this.x)*b,this.y+=(a.y-this.y)*b,this.z+=(a.z-this.z)*b,this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a),this},cross:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;return this.x=d*a.z-e*a.y,this.y=e*a.x-c*a.z,this.z=c*a.y-d*a.x,this},crossVectors:function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;return this.x=d*h-e*g,this.y=e*f-c*h,this.z=c*g-d*f,this},projectOnVector:function(){var a,b;return function(c){return void 0===a&&(a=new jd),a.copy(c).normalize(),b=this.dot(a),this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a;return function(b){return void 0===a&&(a=new jd),a.copy(this).projectOnVector(b),this.sub(a)}}(),reflect:function(){var a;return function(b){return void 0===a&&(a=new jd),this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y,d=this.z-a.z;return b*b+c*c+d*d},setEulerFromRotationMatrix:function(a,b){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(a,b){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(a){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){return this.x=a.elements[12],this.y=a.elements[13],this.z=a.elements[14],this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length(),d=this.set(a.elements[8],a.elements[9],a.elements[10]).length();return this.x=b,this.y=c,this.z=d,this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;return this.x=d[c],this.y=d[c+1],this.z=d[c+2],this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a,b){return void 0===b&&(b=0),this.x=a[b],this.y=a[b+1],this.z=a[b+2],this},toArray:function(a,b){return void 0===a&&(a=[]),void 0===b&&(b=0),a[b]=this.x,a[b+1]=this.y,a[b+2]=this.z,a},fromAttribute:function(a,b,c){return void 0===c&&(c=0),b=b*a.itemSize+c,this.x=a.array[b],this.y=a.array[b+1],this.z=a.array[b+2],this}};var kd=function(a,b){this.min=void 0!==a?a:new jd(1/0,1/0,1/0),this.max=void 0!==b?b:new jd(-1/0,-1/0,-1/0)};kd.prototype={constructor:kd,set:function(a,b){return this.min.copy(a),this.max.copy(b),this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromArray:function(a,b){return this.min.x=a[b],this.min.y=a[b+1],this.min.z=a[b+2],this.max.x=a[b+3],this.max.y=a[b+4],this.max.z=a[b+5],this},copyToArray:function(a,b){a[b]=this.min.x,a[b+1]=this.min.y,a[b+2]=this.min.z,a[b+3]=this.max.x,a[b+4]=this.max.y,a[b+5]=this.max.z},setFromCenterAndSize:function(){var a=new jd;return function(b,c){var d=a.copy(c).multiplyScalar(.5);return this.min.copy(b).sub(d),this.max.copy(b).add(d),this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){return this.min.copy(a.min),this.max.copy(a.max),this},makeEmpty:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},center:function(a){return(a||new jd).addVectors(this.min,this.max).multiplyScalar(.5)},size:function(a){return(a||new jd).subVectors(this.max,this.min)},expandByPoint:function(a){return this.min.min(a),this.max.max(a),this},expandByVector:function(a){return this.min.sub(a),this.max.add(a),this},expandByScalar:function(a){return this.min.addScalar(-a),this.max.addScalar(a),this},containsPoint:function(a){return!(a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z)},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z},getParameter:function(a,b){return(b||new jd).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return!(a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z)},clampPoint:function(a,b){return(b||new jd).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new jd;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){return this.min.max(a.min),this.max.min(a.max),this},union:function(a){return this.min.min(a.min),this.max.max(a.max),this},applyMatrix4:function(){var a=[new jd,new jd,new jd,new jd,new jd,new jd,new jd,new jd];return function(b){return a[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(b),a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b),a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b),a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b),a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b),a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b),a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b),a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b),this.makeEmpty(),this.setFromPoints(a),this}}(),translate:function(a){return this.min.add(a),this.max.add(a),this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}};var ld,md,nd,od,pd,qd=id.getVertexCount,rd=id.enumMeshTriangles,sd=id.enumMeshVertices,td={createWireframe:p},ud=function(a,b){return a.distance-b.distance},vd={meshRayCast:r,lineRayCast:s,rayCast:u,intersectObject:w};z.prototype.getGeometry=function(a){return this.geoms[a]},z.prototype.chooseMemoryType=function(a,b,c,d){var e=Gc,f=2*e,g=Hc;if(this.isf2d&&(f*=2),this.disableStreaming||d<e&&c<g)a.streamingDraw=!1,a.streamingIndex=!1;else if(d>=f)a.streamingDraw=!0,a.streamingIndex=!0;else{var h;h=this.is2d?100001:a.byteSize*(b||1),h<1e5&&(a.streamingDraw=!0,a.streamingIndex=!0)}},z.prototype.addGeometry=function(b,c,d){this.chooseMemoryType(b,c,this.gpuNumMeshes,this.gpuMeshMemory);var e=b.byteSize+464;b.streamingDraw||(wc()&&(e+=b.byteSize),this.gpuMeshMemory+=b.byteSize,this.gpuNumMeshes+=1),this.numGeomsInMemory++,(void 0===d||d<=0)&&(d=this.geoms.length),this.geoms[d]=b;var f=this.geomBoxes.length/6|0;if(f<this.geoms.length){var g=3*this.geoms.length/2|0,h=new Float32Array(6*g);h.set(this.geomBoxes);var i=new THREE.Box3;for(i.makeEmpty();f<g;)h[6*f]=i.min.x,h[6*f+1]=i.min.y,h[6*f+2]=i.min.z,h[6*f+3]=i.max.x,h[6*f+4]=i.max.y,h[6*f+++5]=i.max.z;this.geomBoxes=h}var j=b.boundingBox;this.geomBoxes[6*d]=j.min.x,this.geomBoxes[6*d+1]=j.min.y,this.geomBoxes[6*d+2]=j.min.z,this.geomBoxes[6*d+3]=j.max.x,this.geomBoxes[6*d+4]=j.max.y,this.geomBoxes[6*d+5]=j.max.z,a.memoryOptimizedLoading&&!this.is2d&&(b.boundingBox=null,b.boundingSphere=null),this.geomMemory+=e;var k=b.attributes.index.array||b.ib,l=b.isLines?k.length/2:k.length/3;return this.geomPolyCount+=l,this.instancePolyCount+=l*(c||1),b.polyCount=l,b.instanceCount=c||1,b.svfid=d,b.lockCount=0,d},z.prototype.removeGeometry=function(a,b){var c=this.getGeometry(a);if(!c||c.lockCount>0)return 0;var d=c.byteSize+464;return b&&b.deallocateGeometry(c),c.streamingDraw||(wc()&&(d+=c.byteSize),this.gpuMeshMemory-=c.byteSize,this.gpuNumMeshes-=1),this.geoms[a]=null,this.geomMemory-=d,this.numGeomsInMemory--,this.geomPolyCount-=c.polyCount,this.instancePolyCount-=c.instanceCount*c.polyCount,d},z.prototype.lockGeometry=function(a){var b=this.getGeometry(a);return!!b&&(++b.lockCount,!0)},z.prototype.unlockGeometry=function(a){var b=this.getGeometry(a);return!(!b||b.lockCount<=0)&&(--b.lockCount,!0)},z.prototype.getLockCount=function(a){var b=this.getGeometry(a);return b?b.lockCount:-1},z.prototype.getModelBox=function(a,b){if(this.geomBoxes.length/6<=a)return void b.makeEmpty();var c=6*a,d=this.geomBoxes;b.min.x=d[c],b.min.y=d[c+1],b.min.z=d[c+2],b.max.x=d[c+3],b.max.y=d[c+4],b.max.z=d[c+5]},z.prototype.dispose=function(a){if(a)for(var b=0,c=this.geoms.length;b<c;b++)this.geoms[b]&&a.deallocateGeometry(this.geoms[b])},z.prototype.printStats=function(){THREE.log("Total geometry size: "+this.geomMemory/1048576+" MB"),THREE.log("Number of meshes: "+this.geoms.length),THREE.log("Num Meshes on GPU: "+this.gpuNumMeshes),THREE.log("Net GPU geom memory used: "+this.gpuMeshMemory)};var wd=[[1,5,4,7,3,2,6],[0,3,2,1,5,4,6],[0,3,2,6,5,4,6],[0,4,7,3,2,1,6],[0,3,2,1,-1,-1,4],[0,3,2,6,5,1,6],[0,4,7,6,2,1,6],[0,3,7,6,2,1,6],[0,3,7,6,5,1,6],[0,1,5,4,7,3,6],[0,1,5,4,-1,-1,4],[0,1,2,6,5,4,6],[0,4,7,3,-1,-1,4],[-1,-1,-1,-1,-1,-1,0],[1,2,6,5,-1,-1,4],[0,4,7,6,2,3,6],[2,3,7,6,-1,-1,4],[1,2,3,7,6,5,6],[0,1,5,6,7,3,6],[0,1,5,6,7,4,6],[0,1,2,6,7,4,6],[0,4,5,6,7,3,6],[4,5,6,7,-1,-1,4],[1,2,6,7,4,5,6],[0,4,5,6,2,3,6],[2,3,7,4,5,6,6],[1,2,3,7,4,5,6]];Object.defineProperty(A,"OUTSIDE",{value:0}),Object.defineProperty(A,"INTERSECTS",{value:1}),Object.defineProperty(A,"CONTAINS",{value:2}),Object.defineProperty(A,"CONTAINMENT_UNKNOWN",{value:-1}),A.prototype.reset=function(a){this.viewProj.multiplyMatrices(a.projectionMatrix,a.matrixWorldInverse),this.frustum.setFromMatrix(this.viewProj);var b=a.matrixWorldInverse.elements;this.ar=a.aspect,this.viewDir[0]=-b[2],this.viewDir[1]=-b[6],this.viewDir[2]=-b[10],this.eye.x=a.position.x,this.eye.y=a.position.y,this.eye.z=a.position.z,this.areaConv=a.clientWidth*a.clientHeight/4},A.prototype.projectedArea=function(){function a(){c||(c=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],d=new THREE.Box2)}function b(a,b){var c=a.x,d=a.y,e=a.z,f=b.elements,g=f[3]*c+f[7]*d+f[11]*e+f[15];g<0&&(g=-g);var h=1/g;a.x=(f[0]*c+f[4]*d+f[8]*e+f[12])*h,a.y=(f[1]*c+f[5]*d+f[9]*e+f[13])*h}var c,d;return function(e){if(e.empty())return 0;a();var f=this.viewProj;c[0].set(e.min.x,e.min.y,e.min.z),c[1].set(e.min.x,e.min.y,e.max.z),c[2].set(e.min.x,e.max.y,e.min.z),c[3].set(e.min.x,e.max.y,e.max.z),c[4].set(e.max.x,e.min.y,e.min.z),c[5].set(e.max.x,e.min.y,e.max.z),c[6].set(e.max.x,e.max.y,e.min.z),c[7].set(e.max.x,e.max.y,e.max.z);for(var g=0;g<8;g++)b(c[g],f);return d.makeEmpty(),d.setFromPoints(c),d.min.x<-1&&(d.min.x=-1),d.min.x>1&&(d.min.x=1),d.min.y<-1&&(d.min.y=-1),d.min.y>1&&(d.min.y=1),d.max.x>1&&(d.max.x=1),d.max.x<-1&&(d.max.x=-1),d.max.y>1&&(d.max.y=1),d.max.y<-1&&(d.max.y=-1),(d.max.x-d.min.x)*(d.max.y-d.min.y)}}(),A.prototype.projectedBoxArea=function(){function a(){if(!d){d=[],e=[];for(var a=0;a<10;a++)d.push(new THREE.Vector3),e.push(new THREE.Vector3)}}function b(a,b){var c=a.x,d=a.y,e=a.z,f=b.elements,g=f[3]*c+f[7]*d+f[11]*e+f[15];g<0&&(g=-g);var h=1/g;a.x=(f[0]*c+f[4]*d+f[8]*e+f[12])*h,a.y=(f[1]*c+f[5]*d+f[9]*e+f[13])*h}function c(a,b){var c,d,g,h,i,j,k,l,m=a,n=e,o=function(a){switch(k){case 0:return a.x>=-1;case 1:return a.x<=1;case 2:return a.y>=-1;case 3:return a.y<=1}},p=function(a){n[l].x=a.x,n[l++].y=a.y},q=function(){var a,b;switch(k){case 0:a=-1,b=d.y+(g.y-d.y)*(a-d.x)/(g.x-d.x);break;case 1:a=1,b=d.y+(g.y-d.y)*(a-d.x)/(g.x-d.x);break;case 2:b=-1,a=d.x+(g.x-d.x)*(b-d.y)/(g.y-d.y);break;case 3:b=1,a=d.x+(g.x-d.x)*(b-d.y)/(g.y-d.y)}n[l].x=a,n[l++].y=b};for(k=0;k<4&&b>2;k++){for(l=0,d=m[b-1],h=o(d),j=0;j<b;j++)g=m[j],i=o(g),h?i?p(g):q():i&&(q(),p(g)),d=g,h=i;b=l,c=m,m=n,n=c}return f=b,m}var d,e,f;return function(e,g){if(e.empty())return 0;a();var h,i=this.viewProj;if(h=this.eye.x>=e.min.x?this.eye.x>e.max.x?2:1:0,this.eye.y>=e.min.y&&(h+=this.eye.y>e.max.y?6:3),this.eye.z>=e.min.z&&(h+=this.eye.z>e.max.z?18:9),13===h)return 4;var j,k=wd[h][6];for(j=0;j<k;j++){var l=wd[h][j];d[j].set((l+1)%4<2?e.min.x:e.max.x,l%4<2?e.min.y:e.max.y,l<4?e.min.z:e.max.z),b(d[j],i)}var m=0;if(g)for(m=(d[k-1].x-d[0].x)*(d[k-1].y+d[0].y),j=0;j<k-1;j++)m+=(d[j].x-d[j+1].x)*(d[j].y+d[j+1].y);else{var n=c(d,k);if(f>=3)for(m=(n[f-1].x-n[0].x)*(n[f-1].y+n[0].y),j=0;j<f-1;j++)m+=(n[j].x-n[j+1].x)*(n[j].y+n[j+1].y)}return Math.abs(.5*m)}}(),A.prototype.estimateDepth=function(a){var b=this.viewProj.elements,c=(a.min.x+a.max.x)/2,d=(a.min.y+a.max.y)/2,e=(a.min.z+a.max.z)/2,f=1/(b[3]*c+b[7]*d+b[11]*e+b[15]);return(b[2]*c+b[6]*d+b[10]*e+b[14])*f},A.prototype.intersectsBox=function(){function a(){b||(b=new THREE.Vector3,c=new THREE.Vector3)}var b,c;return function(d){a();for(var e=this.frustum.planes,f=0,g=0;g<6;g++){var h=e[g];b.x=h.normal.x>0?d.min.x:d.max.x,c.x=h.normal.x>0?d.max.x:d.min.x,b.y=h.normal.y>0?d.min.y:d.max.y,c.y=h.normal.y>0?d.max.y:d.min.y,
b.z=h.normal.z>0?d.min.z:d.max.z,c.z=h.normal.z>0?d.max.z:d.min.z;var i=h.distanceToPoint(b),j=h.distanceToPoint(c);if(i<0&&j<0)return A.OUTSIDE;i>0&&j>0&&f++}return 6==f?A.CONTAINS:A.INTERSECTS}}(),Object.defineProperty(A,"OUTSIDE",{value:0}),Object.defineProperty(A,"INTERSECTS",{value:1}),Object.defineProperty(A,"CONTAINS",{value:2}),Object.defineProperty(A,"CONTAINMENT_UNKNOWN",{value:-1});var xd;C.prototype.getIndices=function(){return Array.isArray(this.indices)?this.indices[0]:this.indices},C.prototype.sortByMaterial=function(){if(!(this.numAdded<this.count)){var a=this.frags,b=this.getIndices();if(!b)return void THREE.warn("Only indexed RenderSubsets can be sorted.");var c=b.subarray(this.start,this.start+this.count);Array.prototype.sort.call(c,function(b,c){var d=a.getMaterialId(b),e=a.getMaterialId(c);return void 0===d?e?1:0:void 0===e?-1:d-e}),this.numAdded=0,this.sortDone=!0}},C.prototype.sortByShader=function(){if(this.sortDone&&!this.sortByShaderDone){var a=this.frags,b=this.getIndices(),c=b.subarray(this.start,this.start+this.count);Array.prototype.sort.call(c,function(b,c){var d=a.getMaterial(b),e=a.getMaterial(c),f=d.program.id-e.program.id;return f||d.id-e.id}),this.numAdded=0,this.sortByShaderDone=!0}},C.prototype.sortByDepth=function(){function a(a,c){b.getGeometry(a)?(b.getWorldBounds(a,e),f[c]=d.estimateDepth(e)):f[c]=-1/0}var b,c,d,e,f;return function(g){if(b=this.frags,c=this.getIndices(),d=g,e=xd,!c)return void THREE.warn("Only indexed RenderSubsets can be sorted.");(!this.indicesView||this.indicesView.length<this.count)&&(this.indicesView=c.subarray(this.start,this.start+this.count)),(!this.depths||this.depths.length<this.count)&&(this.depths=new Float32Array(this.count)),f=this.depths,this.forEachNoMesh(a);for(var h,i,j=1;j<f.length;j++)for(var k=j;k>0&&f[k-1]<f[k];)h=f[k-1],f[k-1]=f[k],f[k]=h,i=this.indicesView[k-1],this.indicesView[k-1]=this.indicesView[k],this.indicesView[k]=i,k--}}(),C.prototype.onFragmentAdded=function(){return function(a){this.frags.getWorldBounds(a,xd),this.boundingBox.union(xd),this.sortDone=!1,this.lastItem<=a&&(this.lastItem=a+1,void 0!==this.visibleStats&&(this.visibleStats=0),this.numAdded++)}}(),C.prototype.forEach=function(a,b,c){var d,e,f,g,d,f,e,g,h=this.getIndices(),i=this.frags,j=!this.sortByShaderDone;if(b||c||j)for(d=b==Sc&&this.hasOwnProperty("drawStart")?this.drawStart:this.start,f=this.lastItem;d<f;d++){e=h?h[d]:d;var g=i.getVizmesh(e,this.renderImportance);!j||g&&g.material&&g.material.program&&!g.geometry_proxy||(j=!1),!(c||g&&g.geometry)||b&&!i.isFlagSet(e,b)||a(g,e)}else for(d=this.start,f=this.lastItem;d<f;d++){e=h?h[d]:d;var g=i.getVizmesh(e,this.renderImportance);g&&g.geometry&&a(g,e)}j&&this.sortByShader()},C.prototype.forEachNoMesh=function(a,b,c){for(var d=this.getIndices(),e=this.frags,f=this.start,g=this.lastItem;f<g;f++){var h,i=d?d[f]:f;if(e.useThreeMesh){var j=e.getVizmesh(i);j&&(h=j.geometry)}else h=e.getGeometry(i);!c&&!h||b&&!e.isFlagSet(i,b)||a(i,f-this.start)}},C.prototype.raycast=function(){return function(a,b,c){if(!1!==a.ray.isIntersectionBox(this.boundingBox)){var d=this,e=xd;this.forEach(function(f,g){if(!d.frags.isFlagSet(g,Oc)){if(c&&c.length){var h=0|d.frags.getDbIds(g);if(-1===c.indexOf(h))return}d.frags.getWorldBounds(g,e),e.expandByScalar(.5),a.ray.isIntersectionBox(e)&&vd.rayCast(f,a,b)}},Mc)}}}(),C.prototype.calculateBounds=function(){function a(a){e.getWorldBounds(a,f),1&b[a]?c.union(f):d.union(f)}var b,c,d,e,f;return function(){this.boundingBox.makeEmpty(),this.boundingBoxHidden.makeEmpty(),b=this.frags.vizflags,c=this.boundingBox,d=this.boundingBoxHidden,e=this.frags,f=xd,this.forEachNoMesh(a,0,this.frags.onDemandLoadingEnabled())}}(),C.prototype.evalVisbility=function(a,b,c){var d,e=b[c]&~Sc;switch(a){case 2:d=!(e&Mc);break;case 1:d=e&Nc;break;default:d=1==(e&(Mc|Nc|Oc))}return b[c]=e|(d?Sc:0),d},C.prototype.applyVisibility=function(){function a(a,b){if(!a&&c.useThreeMesh||!a.geometry)return void(g&&g(b));if(D(h,e,c,b))return a?a.visible=!1:THREE.warn("Unexpected null mesh"),void(d[b]=d[b]&~Sc);var j=this.evalVisbility(f,d,b);a&&(a.visible=!!j),i=i&&!j}function b(a){if(!c.getGeometryId(a))return void(g&&g(a));if(D(h,e,c,a))return void(d[a]=d[a]&~Sc);var b=this.evalVisbility(f,d,a);i=i&&!b}var c,d,e,f,g,h,i;return function(j,k,l){i=!0,e=k,f=j,g=l;var m=e.intersectsBox(2===f?this.boundingBoxHidden:this.boundingBox);return m===A.OUTSIDE?i:(d=this.frags.vizflags,c=this.frags,h=m!==A.CONTAINS,l||c.useThreeMesh?this.forEach(a.bind(this),null,g):this.forEachNoMesh(b.bind(this),null),i)}}();var yd,zd,Ad,Bd={},Cd={},Dd=1,Ed={meshToGeometry:I,createBufferGeometry:H},Fd=1,Gd=function(a,b,c,d,e,f,g){for(var h=a.posOffset,i=d;i<e;i++){var j=i*a.vbstride+h;g.set(a.vb[j],a.vb[j+1],a.vb[j+2]),g.applyMatrix4(c),a.vb[j]=g.x,a.vb[j+1]=g.y,a.vb[j+2]=g.z}if(-1!==a.normalOffset){var k=2*a.vbstride,l=2*a.normalOffset,m=O(c,f);for(i=d;i<e;i++){var n=i*k+l;g.set(b[n],b[n+1],0),g.divideScalar(65535),M(g),g.applyMatrix4(m),g.normalize(),L(g),g.multiplyScalar(65535),b[n]=g.x,b[n+1]=g.y}}};K.prototype.run=function(a,b){for(var c=this.vb,d=c.length/this.vbstride,e=a.clone(),f=new Uint8Array(3*d),g=-1!==this.normalOffset,h=g?new Uint16Array(c.buffer,c.byteOffset,2*c.length):null,i=this.ranges,j=this.matrices,k=i.length-1,l=0;l<k;l++){var m=i[l],n=i[l+1];P(l,j,a),Gd(this,h,a,m,n,e,b);for(var o=3*m,p=n-m,q=this.dbIds[l],r=0;r<p;r++)N(q,f,o),o+=3}return{taskId:this.id,vb:this.vb,vertexIds:f}};var Hd=id.getVertexCount,Id={ParallelGeomMerge:T,runMergeSingleThreaded:U},Jd=[{id:"SOLID",name:"Solid",ascii_art:"_______________________________________",def:[1]},{id:"BORDER",name:"Border",ascii_art:"__ __ . __ __ . __ __ . __ __ . __ __ .",def:[.5,-.25,.5,-.25,0,-.25]},{id:"BORDER2",name:"Border (.5x)",ascii_art:"__ __ . __ __ . __ __ . __ __ . __ __ .",def:[.25,-.125,.25,-.125,0,-.125]},{id:"BORDERX2",name:"Border (2x)",ascii_art:"____  ____  .  ____  ____  .  ___",def:[1,-.5,1,-.5,0,-.5]},{id:"CENTER",name:"Center",ascii_art:"____ _ ____ _ ____ _ ____ _ ____ _ ____",def:[1.25,-.25,.25,-.25]},{id:"CENTER2",name:"Center (.5x)",ascii_art:"___ _ ___ _ ___ _ ___ _ ___ _ ___",def:[.75,-.125,.125,-.125]},{id:"CENTERX2",name:"Center (2x)",ascii_art:"________  __  ________  __  _____",def:[2.5,-.5,.5,-.5]},{id:"DASHDOT",name:"Dash dot",ascii_art:"__ . __ . __ . __ . __ . __ . __ . __",def:[.5,-.25,0,-.25]},{id:"DASHDOT2",name:"Dash dot (.5x)",ascii_art:"_._._._._._._._._._._._._._._.",def:[.25,-.125,0,-.125]},{id:"DASHDOTX2",name:"Dash dot (2x)",ascii_art:"____  .  ____  .  ____  .  ___",def:[1,-.5,0,-.5]},{id:"DASHED",name:"Dashed",ascii_art:"__ __ __ __ __ __ __ __ __ __ __ __ __ _",def:[.5,-.25]},{id:"DASHED2",name:"Dashed (.5x)",ascii_art:"_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",def:[.25,-.125]},{id:"DASHEDX2",name:"Dashed (2x)",ascii_art:"____  ____  ____  ____  ____  ___",def:[1,-.5]},{id:"DIVIDE",name:"Divide",ascii_art:"____ . . ____ . . ____ . . ____ . . ____",def:[.5,-.25,0,-.25,0,-.25]},{id:"DIVIDE2",name:"Divide (.5x)",ascii_art:"__..__..__..__..__..__..__..__.._",def:[.25,-.125,0,-.125,0,-.125]},{id:"DIVIDEX2",name:"Divide (2x)",ascii_art:"________  .  .  ________  .  .  _",def:[1,-.5,0,-.5,0,-.5]},{id:"DOT",name:"Dot",ascii_art:". . . . . . . . . . . . . . . . . . . . . . . .",def:[0,-.25]},{id:"DOT2",name:"Dot (.5x)",ascii_art:"........................................",def:[0,-.125]},{id:"DOTX2",name:"Dot (2x)",ascii_art:".  .  .  .  .  .  .  .  .  .  .  .  .  .",def:[0,-.5]},{id:"HIDDEN",name:"Hidden",ascii_art:"__ __ __ __ __ __ __ __ __ __ __ __ __ __",def:[.25,-.125]},{id:"HIDDEN2",name:"Hidden (.5x)",ascii_art:"_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",def:[.125,-.0625]},{id:"HIDDENX2",name:"Hidden (2x)",ascii_art:"____ ____ ____ ____ ____ ____ ____",def:[.5,-.25]},{id:"PHANTOM",name:"Phantom",ascii_art:"______  __  __  ______  __  __  ______",def:[1.25,-.25,.25,-.25,.25,-.25]},{id:"PHANTOM2",name:"Phantom (.5x)",ascii_art:"___ _ _ ___ _ _ ___ _ _ ___ _ _",def:[.625,-.125,.125,-.125,.125,-.125]},{id:"PHANTOMX2",name:"Phantom (2x)",ascii_art:"____________    ____    ____   _",def:[2.5,-.5,.5,-.5,.5,-.5]},{id:"ACAD_ISO02W100",name:"ISO dash",ascii_art:"__ __ __ __ __ __ __ __ __ __ __ __ __",def:[12,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO03W100",name:"ISO dash space",ascii_art:"__    __    __    __    __    __",def:[12,-18],pen_width:1,unit:"mm"},{id:"ACAD_ISO04W100",name:"ISO long-dash dot",ascii_art:"____ . ____ . ____ . ____ . _",def:[24,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO05W100",name:"ISO long-dash double-dot",ascii_art:"____ .. ____ .. ____ .",def:[24,-3,.5,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO06W100",name:"ISO long-dash triple-dot",ascii_art:"____ ... ____ ... ____",def:[24,-3,.5,-3,.5,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO07W100",name:"ISO dot",ascii_art:". . . . . . . . . . . . . . . . . . . .",def:[.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO08W100",name:"ISO long-dash short-dash",ascii_art:"____ __ ____ __ ____ _",def:[24,-3,6,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO09W100",name:"ISO long-dash double-short-dash",ascii_art:"____ __ __ ____",def:[24,-3,6,-3,6,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO10W100",name:"ISO dash dot",ascii_art:"__ . __ . __ . __ . __ . __ . __ . ",def:[12,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO11W100",name:"ISO double-dash dot",ascii_art:"__ __ . __ __ . __ __ . __ _",def:[12,-3,12,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO12W100",name:"ISO dash double-dot",ascii_art:"__ . . __ . . __ . . __ . .",def:[12,-3,.5,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO13W100",name:"ISO double-dash double-dot",ascii_art:"__ __ . . __ __ . . _",def:[12,-3,12,-3,.5,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO14W100",name:"ISO dash triple-dot",ascii_art:"__ . . . __ . . . __ . . . _",def:[12,-3,.5,-3,.5,-3,.5,-3],pen_width:1,unit:"mm"},{id:"ACAD_ISO15W100",name:"ISO double-dash triple-dot",ascii_art:"__ __ . . . __ __ . .",def:[12,-3,12,-3,.5,-3,.5,-3,.5,-3],pen_width:1,unit:"mm"},{id:"FENCELINE1",name:"Fenceline circle",ascii_art:"----0-----0----0-----0----0-----0--",def:[.25,-.1,["CIRC1","ltypeshp.shx","x=-.1","s=.1"],-.1,1]},{id:"FENCELINE2",name:"Fenceline square",ascii_art:"----[]-----[]----[]-----[]----[]---",def:[.25,-.1,["BOX","ltypeshp.shx","x=-.1","s=.1"],-.1,1]},{id:"TRACKS",name:"Tracks",ascii_art:"-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-",def:[.15,["TRACK1","ltypeshp.shx","s=.25"],.15]},{id:"BATTING",name:"Batting",ascii_art:"SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS",def:[1e-4,-.1,["BAT","ltypeshp.shx","x=-.1","s=.1"],-.2,["BAT","ltypeshp.shx","r=180","x=.1","s=.1"],-.1]},{id:"HOT_WATER_SUPPLY",name:"Hot water supply",ascii_art:"---- HW ---- HW ---- HW ----",def:[.5,-.2,["HW","STANDARD","S=.1","R=0.0","X=-0.1","Y=-.05"],-.2]},{id:"GAS_LINE",name:"Gas line",ascii_art:"----GAS----GAS----GAS----GAS----GAS----GAS--",def:[.5,-.2,["GAS","STANDARD","S=.1","R=0.0","X=-0.1","Y=-.05"],-.25]},{id:"ZIGZAG",name:"Zig zag",ascii_art:"/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/",def:[1e-4,-.2,["ZIG","ltypeshp.shx","x=-.2","s=.2"],-.4,["ZIG","ltypeshp.shx","r=180","x=.2","s=.2"],-.2]}],Kd=function(){for(var a=Jd.length,b=0,c=0;c<a;c++){var d=Jd[c];d.def.length>b&&(b=d.def.length)}for(var e=b+3,f=a,g=1;g<e;)g*=2;for(e=g,g=1;g<f;)g*=2;f=g;for(var h=new Uint8Array(e*f),i=0;i<a;i++){for(var j=i*e,d=Jd[i],k=d.unit&&"mm"==d.unit?1/25.4:1,l=d.pen_width||0,m=d.def,n=0,c=0;c<m.length;c++){var o=Math.abs(m[c]);o<=.5*l&&(o=0);var p=0|96*o*k;n+=p,h[j+c+2]=p||1}h[j]=n%256,h[j+1]=n/256,h[j+m.length+2]=0}var q=new THREE.DataTexture(h,e,f,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter,0);return q.generateMipmaps=!1,q.flipY=!1,q.needsUpdate=!0,q},Ld={LineStyleDefs:Jd,CreateLinePatternTexture:Kd},Md={uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.lights,THREE.UniformsLib.fog,_b.CutPlanesUniforms,_b.IdUniforms,_b.ThemingUniform,_b.ShadowMapUniforms,V("surface_albedo_map"),V("surface_roughness_map"),V("surface_cutout_map"),V("surface_anisotropy_map"),V("surface_rotation_map"),V("opaque_albedo_map"),V("opaque_f0_map"),V("opaque_luminance_modifier_map"),V("layered_bottom_f0_map"),V("layered_f0_map"),V("layered_diffuse_map"),V("layered_fraction_map"),V("layered_roughness_map"),V("layered_anisotropy_map"),V("layered_rotation_map"),V("metal_f0_map"),V("wood_curly_distortion_map"),W("surface_normal_map"),W("layered_normal_map"),{surface_albedo:{type:"c",value:new THREE.Color(1118481)},surface_roughness:{type:"f",value:1},surface_anisotropy:{type:"f",value:1},surface_rotation:{type:"f",value:1},opaque_albedo:{type:"c",value:new THREE.Color(1118481)},opaque_f0:{type:"f",value:1},opaque_luminance_modifier:{type:"c",value:new THREE.Color(1118481)},opaque_luminance:{type:"f",value:1},metal_f0:{type:"c",value:new THREE.Color(1118481)},layered_f0:{type:"f",value:1},layered_diffuse:{type:"c",value:new THREE.Color(0)},layered_fraction:{type:"f",value:1},layered_bottom_f0:{type:"c",value:new THREE.Color(1118481)},layered_roughness:{type:"f",value:1},layered_anisotropy:{type:"f",value:1},layered_rotation:{type:"f",value:1},transparent_ior:{type:"f",value:2},transparent_color:{type:"c",value:new THREE.Color(1118481)},transparent_distance:{type:"f",value:1},wood_fiber_cosine_enable:{type:"i",value:1},wood_fiber_cosine_bands:{type:"i",value:2},wood_fiber_cosine_weights:{type:"v4",value:new THREE.Vector4(2.5,.5,1,1)},wood_fiber_cosine_frequencies:{type:"v4",value:new THREE.Vector4(15,4,1,1)},wood_fiber_perlin_enable:{type:"i",value:1},wood_fiber_perlin_bands:{type:"i",value:3},wood_fiber_perlin_weights:{type:"v4",value:new THREE.Vector4(3,1,.2,1)},wood_fiber_perlin_frequencies:{type:"v4",value:new THREE.Vector4(40,20,3.5,1)},wood_fiber_perlin_scale_z:{type:"f",value:.3},wood_growth_perlin_enable:{type:"i",value:1},wood_growth_perlin_bands:{type:"i",value:3},wood_growth_perlin_weights:{type:"v4",value:new THREE.Vector4(1,2,1,1)},wood_growth_perlin_frequencies:{type:"v4",value:new THREE.Vector4(1,5,13,1)},wood_latewood_ratio:{type:"f",value:.238},wood_earlywood_sharpness:{type:"f",value:.395},wood_latewood_sharpness:{type:"f",value:.109},wood_ring_thickness:{type:"f",value:.75},wood_earlycolor_perlin_enable:{type:"i",value:1},wood_earlycolor_perlin_bands:{type:"i",value:2},wood_earlycolor_perlin_weights:{type:"v4",value:new THREE.Vector4(.3,.5,.15,1)},wood_earlycolor_perlin_frequencies:{type:"v4",value:new THREE.Vector4(8,3,.35,1)},wood_early_color:{type:"c",value:new THREE.Color(.286,.157,.076)},wood_use_manual_late_color:{type:"i",value:0},wood_manual_late_color:{type:"c",value:new THREE.Color(.62,.35,.127)},wood_latecolor_perlin_enable:{type:"i",value:1},wood_latecolor_perlin_bands:{type:"i",value:1},wood_latecolor_perlin_weights:{type:"v4",value:new THREE.Vector4(.75,.55,1,1)},wood_latecolor_perlin_frequencies:{type:"v4",value:new THREE.Vector4(4.5,.05,1,1)},wood_late_color_power:{type:"f",value:1.25},wood_diffuse_perlin_enable:{type:"i",value:1},wood_diffuse_perlin_bands:{type:"i",value:3},wood_diffuse_perlin_weights:{type:"v4",value:new THREE.Vector4(.15,.2,.05,1)},wood_diffuse_perlin_frequencies:{type:"v4",value:new THREE.Vector4(.05,.1,3,1)},wood_diffuse_perlin_scale_z:{type:"f",value:.2},wood_use_pores:{type:"i",value:1},wood_pore_type:{type:"i",value:0},wood_pore_radius:{type:"f",value:.04},wood_pore_cell_dim:{type:"f",value:.15},wood_pore_color_power:{type:"f",value:1.45},wood_pore_depth:{type:"f",value:.02},wood_use_rays:{type:"i",value:1},wood_ray_color_power:{type:"f",value:1.1},wood_ray_seg_length_z:{type:"f",value:5},wood_ray_num_slices:{type:"f",value:160},wood_ray_ellipse_z2x:{type:"f",value:10},wood_ray_ellipse_radius_x:{type:"f",value:.2},wood_use_latewood_bump:{type:"i",value:1},wood_latewood_bump_depth:{type:"f",value:.01},wood_use_groove_roughness:{type:"i",value:1},wood_groove_roughness:{type:"f",value:.85},wood_diffuse_lobe_weight:{type:"f",value:.9},wood_curly_distortion_enable:{type:"i",value:0},wood_curly_distortion_scale:{type:"f",value:.25},wood_ring_fraction:{type:"v4",value:new THREE.Vector4(0,0,0,0)},wood_fall_rise:{type:"v2",value:new THREE.Vector2(0,0)},permutationMap:{type:"t",value:null},gradientMap:{type:"t",value:null},perm2DMap:{type:"t",value:null},permGradMap:{type:"t",value:null},importantSamplingRandomMap:{type:"t",value:null},importantSamplingSolidAngleMap:{type:"t",value:null},irradianceMap:{type:"t",value:null},envMap:{type:"t",value:null},exposureBias:{type:"f",value:1},envMapExposure:{type:"f",value:1},envRotationSin:{type:"f",value:0},envRotationCos:{type:"f",value:1},envExponentMin:{type:"f",value:1},envExponentMax:{type:"f",value:512},envExponentCount:{type:"f",value:10}}]),vertexShader:"varying vec3 vViewPosition;\nvarying vec3 vNormal;\n#if defined(PRISMWOOD) && !defined(NO_UVW)\nvarying vec3 vUvw;\n#if defined(PRISMWOODBUMP)\nvarying vec3 vtNormal;\nvarying mat3 mNormalMatrix;\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#prism_check<USE_MAP>\n#ifdef USE_MAP\nvarying vec2 vUv;\n#endif\n#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\n#endif\nuniform float logDepthBufFC;\n#endif\n#ifdef MRT_NORMALS\nvarying float depth;\n#endif\n#include<pack_normals>\n#include<instancing_decl_vert>\n#include<id_decl_vert>\n#include<shadowmap_decl_vert>\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined( PRISMWOODBUMP )\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\n#endif\nvoid main() {\n#ifdef USE_MAP\n    vUv = uv;\n#endif\n#ifdef UNPACK_NORMALS\n    vec3 objectNormal = decodeNormal(normal);\n#else\n    vec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n    objectNormal = getInstanceNormal(objectNormal);\n    vec3 instPos = getInstancePos(position);\n#if defined(PRISMWOOD) && !defined(NO_UVW)\n#if defined(PRISMWOODBUMP)\n    vUvw = instPos;\n    vtNormal = normalize(objectNormal);\n    mNormalMatrix = normalMatrix;\n#else\n    vUvw = uvw;\n#endif\n#endif\n    vec3 transformedNormal = normalMatrix * objectNormal;\n    vNormal = normalize( transformedNormal );\n    vec4 mvPosition = modelViewMatrix * vec4( instPos, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( instPos, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined ( PRISMWOODBUMP )\n    vec3 Tu, Tv;\n#if defined(PRISMWOODBUMP)\n    ComputeTangents(vtNormal, Tu, Tv);\n#else\n    ComputeTangents(vNormal, Tu, Tv);\n#endif\n    vTangent = Tu;\n    vBitangent = Tv;\n#endif\n#ifdef USE_LOGDEPTHBUF\n    if (projectionMatrix[3][3] == 0.0) {\n        gl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + gl_Position.w;\n#else\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n#endif\n    } else {\n#ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + vViewPosition.z;\n#else\n#endif\n    }\n#endif\n#ifdef MRT_NORMALS\n    depth = mvPosition.z;\n#endif\n#include<id_vert>\n#include<shadowmap_vert>\n}\n",
fragmentShader:"\n#define PI 3.141592654\n#define RECIPROCAL_PI 0.318309886\n#define RECIPROCAL_2PI 0.159154943\n#define ONE 0.00390625\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\nuniform sampler2D importantSamplingRandomMap;\nuniform sampler2D importantSamplingSolidAngleMap;\n#if defined( PRISMOPAQUE )\nuniform vec3 opaque_albedo;\nuniform float opaque_f0;\nuniform vec3 opaque_luminance_modifier;\nuniform float opaque_luminance;\n#elif defined( PRISMMETAL )\nuniform vec3 metal_f0;\n#elif defined( PRISMLAYERED )\nuniform float layered_f0;\nuniform vec3 layered_diffuse;\nuniform float layered_fraction;\nuniform vec3 layered_bottom_f0;\nuniform float layered_roughness;\nuniform float layered_anisotropy;\nuniform float layered_rotation;\n#elif defined( PRISMTRANSPARENT )\nuniform float transparent_ior;\nuniform vec3 transparent_color;\nuniform float transparent_distance;\n#elif defined( PRISMWOOD )\nuniform bool wood_fiber_cosine_enable;\nuniform int wood_fiber_cosine_bands;\nuniform vec4 wood_fiber_cosine_weights;\nuniform vec4 wood_fiber_cosine_frequencies;\nuniform bool wood_fiber_perlin_enable;\nuniform int wood_fiber_perlin_bands;\nuniform vec4 wood_fiber_perlin_weights;\nuniform vec4 wood_fiber_perlin_frequencies;\nuniform float wood_fiber_perlin_scale_z;\nuniform bool wood_growth_perlin_enable;\nuniform int wood_growth_perlin_bands;\nuniform vec4 wood_growth_perlin_weights;\nuniform vec4 wood_growth_perlin_frequencies;\nuniform float wood_latewood_ratio;\nuniform float wood_earlywood_sharpness;\nuniform float wood_latewood_sharpness;\nuniform float wood_ring_thickness;\nuniform bool wood_earlycolor_perlin_enable;\nuniform int wood_earlycolor_perlin_bands;\nuniform vec4 wood_earlycolor_perlin_weights;\nuniform vec4 wood_earlycolor_perlin_frequencies;\nuniform vec3 wood_early_color;\nuniform bool wood_use_manual_late_color;\nuniform vec3 wood_manual_late_color;\nuniform bool wood_latecolor_perlin_enable;\nuniform int wood_latecolor_perlin_bands;\nuniform vec4 wood_latecolor_perlin_weights;\nuniform vec4 wood_latecolor_perlin_frequencies;\nuniform float wood_late_color_power;\nuniform bool wood_diffuse_perlin_enable;\nuniform int wood_diffuse_perlin_bands;\nuniform vec4 wood_diffuse_perlin_weights;\nuniform vec4 wood_diffuse_perlin_frequencies;\nuniform float wood_diffuse_perlin_scale_z;\nuniform bool wood_use_pores;\nuniform int wood_pore_type;\nuniform float wood_pore_radius;\nuniform float wood_pore_cell_dim;\nuniform float wood_pore_color_power;\nuniform float wood_pore_depth;\nuniform bool wood_use_rays;\nuniform float wood_ray_color_power;\nuniform float wood_ray_seg_length_z;\nuniform float wood_ray_num_slices;\nuniform float wood_ray_ellipse_z2x;\nuniform float wood_ray_ellipse_radius_x;\nuniform bool wood_use_latewood_bump;\nuniform float wood_latewood_bump_depth;\nuniform bool wood_use_groove_roughness;\nuniform float wood_groove_roughness;\nuniform float wood_diffuse_lobe_weight;\nuniform sampler2D permutationMap;\nuniform sampler2D gradientMap;\nuniform sampler2D perm2DMap;\nuniform sampler2D permGradMap;\nuniform vec4 wood_ring_fraction;\nuniform vec2 wood_fall_rise;\n#endif\nuniform float envExponentMin;\nuniform float envExponentMax;\nuniform float envExponentCount;\n#include<env_sample>\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\n#include<tonemap>\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#ifdef USE_LOGDEPTHBUF\nuniform float logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n#extension GL_EXT_frag_depth : enable\nvarying highp float vFragDepth;\n#endif\n#endif\n#include<id_decl_frag>\n#include<theming_decl_frag>\n#include<shadowmap_decl_frag>\n#ifdef USE_FOG\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#prism_check<USE_MAP>\n#ifdef USE_MAP\nvarying vec2 vUv;\n#endif\n#if defined(PRISMWOOD) && !defined(NO_UVW)\nvarying vec3 vUvw;\n#endif\n#prism_uniforms<surface_albedo_map>\n#prism_uniforms<surface_roughness_map>\n#prism_uniforms<surface_cutout_map>\n#prism_uniforms<surface_anisotropy_map>\n#prism_uniforms<surface_rotation_map>\n#prism_uniforms<opaque_albedo_map>\n#prism_uniforms<opaque_f0_map>\n#prism_uniforms<opaque_luminance_modifier_map>\n#prism_uniforms<layered_bottom_f0_map>\n#prism_uniforms<layered_f0_map>\n#prism_uniforms<layered_diffuse_map>\n#prism_uniforms<layered_fraction_map>\n#prism_uniforms<layered_roughness_map>\n#prism_uniforms<layered_anisotropy_map>\n#prism_uniforms<layered_rotation_map>\n#prism_uniforms<metal_f0_map>\n#prism_uniforms<wood_curly_distortion_map>\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nuniform bool wood_curly_distortion_enable;\nuniform float wood_curly_distortion_scale;\n#endif\n#prism_bump_uniforms<surface_normal_map>\n#prism_bump_uniforms<layered_normal_map>\nfloat SRGBToLinearComponent(float color) {\n    float result = color;\n    if (result<=0.04045)\n        result *= 0.07739938;\n    else\n        result = pow(abs((result+0.055)*0.947867298), 2.4);\n    return result;\n}\nvec3 SRGBToLinear(vec3 color) {\n    vec3 result = color;\n    result.x = SRGBToLinearComponent(result.x);\n    result.y = SRGBToLinearComponent(result.y);\n    result.z = SRGBToLinearComponent(result.z);\n    return result;\n}\n#if defined( USE_ENVMAP )\nuniform float envMapExposure;\nuniform samplerCube envMap;\n#endif\n#include<float3_average>\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )\nvec3 heightMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy; \n    mat3 mtxTangent = mat3(T, B, N); \n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    return normalize(N + (diff.x * T * bumpScale.x + diff.y * B * bumpScale.y));\n}\nvec3 normalMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy; \n    vec3 NMap =  2.0 * texture2D( bumpTexture, st ).xyz - 1.0;  \n    return normalize(bumpScale.x * (NMap.x * T + NMap.y * B) + NMap.z * N);\n}\n#endif\n#if !defined(USE_MAP) && (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0) || defined ( PRISMWOODBUMP )\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#if defined( PRISMWOODBUMP )\nvarying vec3 vtNormal;\nvarying mat3 mNormalMatrix;\n#endif\n#endif\n#if defined( USE_ENVMAP )\nvec3 sampleReflection(vec3 N, vec3 V, float mipIndex) {\n    vec3 dir = (2.0 * dot(V, N)) * N - V;\n    dir = adjustLookupVector(mat3(viewMatrixInverse) * dir);\n#ifdef ENV_GAMMA\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\n    return GammaDecode(envTexColor, envMapExposure);\n#elif defined(ENV_RGBM)\n#ifdef HAVE_TEXTURE_LOD\n    vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\n    vec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\n    return RGBMDecode(envTexColor, envMapExposure);\n#else\n    vec4 envTexColor = textureCube( envMap, dir );\n    vec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\n    cubeColor *= cubeColor;\n#endif\n    return cubeColor;\n#endif\n}\n#endif\n#include<hatch_pattern>\n#if defined( USE_ENVMAP ) && defined( USE_IRRADIANCEMAP )\nuniform samplerCube irradianceMap;\nvec3 sampleNormal(vec3 normal) {\n    vec3 worldNormal = mat3(viewMatrixInverse) * normal;\n    vec3 irradiance = sampleIrradianceMap(worldNormal, irradianceMap, envMapExposure);\n    irradiance = applyEnvShadow(irradiance, worldNormal);\n    return irradiance;\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\nfloat sqr(float x) {return x*x;}\nfloat aSqrd(float maxAlphaSqr, float cosTheta)\n{\n    if (abs(cosTheta) < 1e-10)\n    {\n        return 1e10;\n    }\n    float tan2 = 1.0/sqr(cosTheta) - 1.0;\n    return maxAlphaSqr * tan2;\n}\nvec3 Fresnel_Schlick(vec3 f0, float cosAngle)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 Fresnel_Rough(vec3 f0, float cosAngle, float alpha)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\nfloat IORToReflectance(float ior)\n{\n    return sqr((1.0 - ior)/(1.0 + ior));\n}\nvec2 RoughnessToAlpha(float roughness, float anisotropy)\n{\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nfloat AlphaToPhong(float alpha)\n{\n    return max(0.0, 2.56/alpha - 7.0);\n}\nfloat ExponentToReflMipIndex(float exponent)\n{\n    float targetLog = log2(exponent);\n    float minLog = log2(envExponentMin); \n    float maxLog = log2(envExponentMax); \n    float deltaLog = clamp(targetLog - minLog, 0.0, maxLog - minLog);  \n    float level = clamp((1.0-(deltaLog + 0.5) / envExponentCount), 0.0, 1.0) * 6.0; \n    return level; \n}\n#include<prism_wood>\n#if defined( ENABLEIMPORTANTSAMPLING ) && (defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ))\n#define IMPORTANTSAMPLING\n#endif\n#if defined( IMPORTANTSAMPLING )\n#define SAMPLECOUNT 32\nvec2 Hammersley(int index)\n{\n    float u = (float(index) + 0.5) / 32.0;\n    float v = 0.5;\n    float noise = texture2D(importantSamplingRandomMap, vec2(u, v), 0.0).r;\n   return vec2(2.0 * PI * float(index/SAMPLECOUNT), noise);\n}\nvec3 ImportanceSampleAnisotropicGGX(int index, vec2 alpha, vec3 N, vec3 Tu, vec3 Tv)\n{\n    vec2 uniformSample2D = Hammersley(index);\n    float coef = sqrt(uniformSample2D.y / (1.0 - uniformSample2D.y));\n    float sinSigma, cosSigma;\n    sinSigma = sin(uniformSample2D.x);\n    cosSigma = cos(uniformSample2D.x);\n    vec3 H = coef * ((alpha.x * cosSigma) * Tu + (alpha.y * sinSigma) * Tv) + N;\n    H = normalize(H);\n    return H;\n}\nfloat ComputePDF(vec2 alpha, float NdotH, float HdotTu, float HdotTv, float VdotH)\n{\n    float factor1 = HdotTu / alpha.x;\n    float factor2 = HdotTv / alpha.y;\n    float factor3 = factor1 * factor1 + factor2 * factor2 + NdotH * NdotH;\n    float factor = factor3 * factor3 * alpha.x * alpha.y * VdotH * 4.0 * PI;\n    if (factor > 0.0)\n    {\n        return (NdotH / factor);\n    }\n    else\n    {\n        return 0.0;\n    }\n}\n#define INVFACESIZE 0.0078125\nfloat DirectionToSolidAngle(vec3 dir)\n{\n    dir = abs(dir);\n    float first = min(dir.x, dir.y);\n    float temp = max(dir.x, dir.y);\n    float second = min(temp, dir.z);\n    float third = max(temp, dir.z);\n    first /= third;\n    second /= third;\n    float u = (first+1.0)/2.0;\n    float v = (second + 1.0) / 2.0;\n    float solidAngle = texture2D(importantSamplingSolidAngleMap, vec2(u, v), 0.0).r * 0.000255;\n    return solidAngle;\n}\nfloat Smith_GGX(float value)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + value));\n}\nvec2 RoughnessAnisotropyToAlpha(float roughness, float anisotropy)\n{\n    float aspect = sqrt(1.0 - 0.9 * anisotropy);\n    vec2 alpha = vec2(roughness * roughness / aspect, roughness * roughness * aspect);\n    return alpha;\n}\nvec3 ImportanceSamplingSpecular(float angle, vec3 reflectance, float roughness, float anisotropy, vec3 V, vec3 N, vec3 Tu, vec3 Tv)\n{\n    vec3 specular = vec3(0.0);\n    float radAngle;\n    if (anisotropy < 1e-10)\n    {\n        radAngle = 0.0;\n    }\n    else\n    {\n        radAngle = -PI * angle;\n    }\n    vec2 alpha = RoughnessAnisotropyToAlpha(roughness, anisotropy);\n    float alpha2 = max(alpha.x * alpha.x, alpha.y * alpha.y);\n    float NdotV = dot(N, V);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    vec2 sincosTheta;\n    sincosTheta.x = sin(radAngle);\n    sincosTheta.y = cos(radAngle);\n    vec3 Tu1, Tv1;\n    Tu1 = sincosTheta.y * Tu - sincosTheta.x * Tv;\n    Tv1 = sincosTheta.x * Tu + sincosTheta.y * Tv;\n    vec3 H;\n    vec3 sampleLightIntensity;\n    vec3 L;\n    float effectiveSample = 0.0;\n    for (int i = 0; i < SAMPLECOUNT; i++)\n    {\n        H = ImportanceSampleAnisotropicGGX(i, alpha, N, Tu1, Tv1);\n        float VdotH = dot(V, H);\n        L = 2.0 * VdotH * H - V;\n        float NdotH = dot(N, H);\n        float NdotL = dot(N, L);\n        if (NdotL >= 0.0 && NdotV > 0.0 && NdotH > 0.0)\n        {\n            float alpha2NL = aSqrd(alpha2, NdotL);\n            float HdotTu = dot(H, Tu1);\n            float HdotTv = dot(H, Tv1);\n            float pdf = ComputePDF(alpha, NdotH, HdotTu, HdotTv, VdotH);\n            float mipmapLevel = 0.0;\n            if (pdf > 0.0)\n            {\n                mipmapLevel = 0.3 * log2(1.0 / (float(SAMPLECOUNT) * pdf * DirectionToSolidAngle(L)));\n            }\n            mipmapLevel = clamp(mipmapLevel, 0.0, 4.0);\n            L = normalize(L);\n            sampleLightIntensity = sampleReflection(L, L, mipmapLevel).rgb;\n            float G = Smith_GGX(alpha2NL) * Smith_GGX(alpha2NV);\n            vec3 F = Fresnel_Schlick(reflectance, VdotH);\n            float factor = G * VdotH / (NdotH * NdotV);\n            if (factor >= 0.0)\n            {\n                specular += abs(sampleLightIntensity * F * factor);\n                effectiveSample += 1.0;\n            }\n        }\n    }\n    if (effectiveSample > 0.0)\n    {\n        specular /= effectiveSample;\n    }\n    return specular;\n}\n#endif\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvec3 DiffuseLobe(vec3 diffuseColor)\n{\n    return diffuseColor * RECIPROCAL_PI;\n}\nvec3 Rotate(vec3 vec, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\nfloat NDF_GGX(float alphaU, float alphaV, vec3 normal)\n{\n    float nx2 = sqr(normal.x);\n    float ny2 = sqr(normal.y);\n    float nz2 = sqr(normal.z);\n    float scale = 1.0/(alphaU * alphaV * PI);\n    return scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);\n}\nfloat G1_GGX(float aSqrd)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\nvec3 MicrofacetLobe(\n        vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\n        float roughness, float anisotropy, float rotation, vec3 reflectance)\n{\n    vec2 alpha = RoughnessToAlpha(roughness, anisotropy);\n    Hlocal = Rotate(Hlocal, rotation);\n    vec3 F = Fresnel_Schlick(reflectance, VdotH);\n    float D = NDF_GGX(alpha.x, alpha.y, Hlocal);\n    float alpha2 = max(sqr(alpha.x), sqr(alpha.y));\n    float alpha2NL = aSqrd(alpha2, NdotL);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    float G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);\n    return max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));\n}\n#if defined( PRISMOPAQUE )\nvec3 BRDF_Opaque(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, \n        float opaqueF0, vec3 opaqueAlbedo)\n{\n    vec3 diffuse = DiffuseLobe(opaqueAlbedo);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, vec3(opaqueF0));\n    return (specular+diffuse)*NdotL;\n}\n#elif defined( PRISMMETAL )\nvec3 BRDF_Metal(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, \n        vec3 metalF0)\n{\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, metalF0);\n    return specular*NdotL;\n}\n#elif defined( PRISMLAYERED )\nvec3 BRDF_Layered(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n        vec3 Hlocal2, float N2dotL, float N2dotH, float N2dotV, \n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n        float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,\n        float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 Fl = Fresnel_Schlick(vec3(layeredF0), NdotL);\n    vec3 Fv = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    vec3 amount = (1.0 - Fl) * (1.0 - Fv);\n    vec3 topSpecular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n            vec3(layeredF0));\n    vec3 topDiffuse = DiffuseLobe(layeredDiffuse);\n    vec3 botSpecular = MicrofacetLobe(\n            Hlocal2, N2dotL, N2dotH, N2dotV, VdotH,\n            layeredRoughness, layeredAnisotropy, layeredRotation,\n            bottom_f0);\n    return topSpecular*NdotL + amount * mix(topDiffuse*NdotL, botSpecular*N2dotL, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 BRDF_Transparent(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n        vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, surfaceAnisotropy, surfaceRotation, reflectance);\n    return specular*NdotL;\n}\n#elif defined( PRISMWOOD )\nvec3 BRDF_Wood(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n        vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse)\n{\n    vec3 diffuse = DiffuseLobe(woodDiffuse);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n            Hlocal, NdotL, NdotH, NdotV, VdotH,\n            surfaceRoughness, 0.0, 0.0, vec3(0.04));\n    return (specular+diffuse)*NdotL;\n}\n#endif\n#endif\n#if defined( USE_ENVMAP )\n#if defined( PRISMOPAQUE )\nvec3 Environment_Opaque(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float opaqueF0, vec3 opaqueAlbedo, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 T)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(vec3(opaqueF0), NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(opaqueF0), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F* surfaceAlbedo * envSpecular;\n#endif\n    \n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * opaqueAlbedo * envIrradiance;\n    vec3 luminanceModifier;\n#prism_sample_texture<opaque_luminance_modifier, luminanceModifier, false, true>\n    vec3 emission = luminanceModifier * opaque_luminance;\n    return diffuse + specular + emission;\n}\n#elif defined( PRISMMETAL )\nvec3 Environment_Metal(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 metalF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, metalF0, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 F = Fresnel_Rough(metalF0, NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n    return specular;\n}\n#elif defined( PRISMLAYERED )\nvec3 Environment_Layered(vec3 N, vec3 V, float NdotV, vec3 N2, float N2dotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float layeredF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv, vec3 layeredDiffuse, float layeredRoughness, \n        float layeredAnisotropy, float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 F = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n#if defined( IMPORTANTSAMPLING )\n    vec3 topSpecular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(layeredF0), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 topSpecular = F * surfaceAlbedo * envSpecular;\n#endif\n    vec3 amount = (1.0 - F);\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 topDiffuse = layeredDiffuse * envIrradiance;\n#if defined( IMPORTANTSAMPLING )\n    vec3 botSpecular = ImportanceSamplingSpecular(layeredRotation, bottom_f0, layeredRoughness, layeredAnisotropy, V, N2, Tu, Tv);\n#else\n    alpha = RoughnessToAlpha(layeredRoughness, 0.0).x;\n    exponent = AlphaToPhong(alpha);\n    reflMipIndex = ExponentToReflMipIndex(exponent);\n    envSpecular = sampleReflection(N2, V, reflMipIndex);\n    F = Fresnel_Rough(bottom_f0, N2dotV, alpha);\n    vec3 botSpecular = F * envSpecular;\n#endif\n    return topSpecular + amount * mix(topDiffuse, botSpecular, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 Environment_Transparent(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(reflectance, NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, reflectance, surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 color = F * surfaceRoughness * transparent_color * envIrradiance;\n    return specular + color;\n}\n#elif defined( PRISMWOOD )\nvec3 Environment_Wood(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = Fresnel_Rough(vec3(0.04), NdotV, alpha);\n#if defined( IMPORTANTSAMPLING )\n    vec3 specular = surfaceAlbedo * ImportanceSamplingSpecular(surfaceRotation, vec3(0.04), surfaceRoughness, surfaceAnisotropy, V, N, Tu, Tv);\n#else\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#endif\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * woodDiffuse * envIrradiance;\n    return diffuse + specular;\n}\n#endif\n#endif\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n#include<cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n    vec3 N = normalize(vNormal);\n    vec3 Tu = vec3(0.0);\n    vec3 Tv = vec3(0.0);\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0 || defined( PRISMWOODBUMP ) || defined( IMPORTANTSAMPLING )\n#if !defined(USE_MAP) || defined( PRISMWOODBUMP )\n    Tu = normalize(vTangent);\n    Tv = normalize(vBitangent);\n#else\n    vec3 q0 = dFdx( -vViewPosition );\n    vec3 q1 = dFdy( -vViewPosition );\n    vec2 st0 = dFdx( vUv );\n    vec2 st1 = dFdy( vUv );\n    Tu = normalize(  q0 * st1.t - q1 * st0.t );\n    Tv = normalize( -q0 * st1.s + q1 * st0.s );\n#endif\n#endif\n    vec3 V;\n    if (projectionMatrix[3][3] == 0.0) {\n        V = normalize( vViewPosition );\n    } else {\n        V = vec3(0.0, 0.0, 1.0);\n    }\n    N = faceforward(N, -V, N);\n#if defined(PRISMLAYERED)\n    vec3 N2 = N;\n#endif\n#ifndef FLAT_SHADED\n    vec3 normal = normalize( vNormal );\n#ifdef DOUBLE_SIDED\n    normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#else\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n#endif\n    vec3 geomNormal = normal;\n#if defined( USE_SURFACE_NORMAL_MAP )\n    if (surface_normal_map_bumpmapType == 0)\n        N = heightMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    else\n        N = normalMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n#endif\n#if defined( USE_LAYERED_NORMAL_MAP )\n    if (layered_normal_map_bumpmapType == 0)\n        N2 = heightMapTransform(layered_normal_map, vUv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n    else\n        N2 = normalMapTransform(layered_normal_map, vUv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n#endif\n#if defined( PRISMWOOD )\n#ifdef NO_UVW\n    vec3 p = vec3(0.0);\n#elif defined( USE_WOOD_CURLY_DISTORTION_MAP )\n    vec3 p = DistortCurly(vUvw);\n#else\n    vec3 p = vUvw;\n#endif\n#if !defined( NO_UVW ) && defined( PRISMWOODBUMP )\n    vec3 offsetTuLeft = p - 0.001 * Tu;\n    vec3 offsetTuRight = p + 0.001 * Tu;\n    vec3 offsetTvLeft = p - 0.001 * Tv;\n    vec3 offsetTvRight = p + 0.001 * Tv;\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\n    vec3 newNormalView = normalize(mNormalMatrix * newNormal);\n    vec3 selectedNormal = SelectNormal(geomNormal, newNormalView, V);\n    ComputeTangents(selectedNormal, Tu, Tv);\n    Tu = normalize(Tu);\n    Tv = normalize(Tv);\n    N = faceforward(selectedNormal, -V, selectedNormal);\n#endif\n#endif\n    float NdotV = dot(N, V);\n#if defined(PRISMLAYERED)\n    float N2dotV = dot(N2, V);\n#endif\n    vec3 surfaceAlbedo;\n#prism_sample_texture<surface_albedo, surfaceAlbedo, false, true>\n    float surfaceRoughness;\n#prism_sample_texture<surface_roughness, surfaceRoughness, true, false>\n    float surfaceAnisotropy;\n#prism_sample_texture<surface_anisotropy, surfaceAnisotropy, true, false>\n    float surfaceRotation;\n#prism_sample_texture<surface_rotation, surfaceRotation, true, false>\n#if defined(PRISMOPAQUE)\n    float opaqueF0;\n#prism_sample_texture<opaque_f0, opaqueF0, true, false>\n    vec3 opaqueAlbedo;\n#prism_sample_texture<opaque_albedo, opaqueAlbedo, false, true>\n#elif defined(PRISMMETAL)\n    vec3 metalF0;\n#prism_sample_texture<metal_f0, metalF0, false, true>\n#elif defined(PRISMLAYERED)\n    float layeredF0;\n#prism_sample_texture<layered_f0, layeredF0, true, false>\n    vec3 layeredDiffuse;\n#prism_sample_texture<layered_diffuse, layeredDiffuse, false, true>\n    float layeredRoughness;\n#prism_sample_texture<layered_roughness, layeredRoughness, true, false>\n    float layeredAnisotropy;\n#prism_sample_texture<layered_anisotropy, layeredAnisotropy, true, false>\n    float layeredRotation;\n#prism_sample_texture<layered_rotation, layeredRotation, true, false>\n    vec3 bottom_f0;\n#prism_sample_texture<layered_bottom_f0, bottom_f0, false, true>\n    float layeredFraction;\n#prism_sample_texture<layered_fraction, layeredFraction, true, false>\n#elif defined(PRISMWOOD)\n    vec3 woodDiffuse = NoiseWood(p, surfaceRoughness);\n#endif\n    vec3 outRadianceLight = vec3(0.0);\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\n    vec3 lightDirection[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n    vec3 lightColor[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n#if MAX_DIR_LIGHTS > 0\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n        vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n        lightDirection[i] = normalize( lDirection.xyz );\n        lightColor[i] = SRGBToLinear(directionalLightColor[ i ]);\n    }\n#endif\n#if MAX_POINT_LIGHTS > 0\n    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        lightDirection[MAX_DIR_LIGHTS + i] = normalize( lVector );\n        float lDistance = 1.0;\n        if ( pointLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n        lightColor[MAX_DIR_LIGHTS + i] = SRGBToLinear(pointLightColor[ i ]) * lDistance;\n    }\n#endif\n#if MAX_SPOT_LIGHTS > 0\n    for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n        lightDirection[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = normalize( lVector );\n        float lDistance = 1.0;\n        if ( spotLightDistance[ i ] > 0.0 )\n            lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n        if ( spotEffect > spotLightAngleCos[ i ] )\n            spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n        lightColor[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = SRGBToLinear(spotLightColor[ i ]) * lDistance * spotEffect;\n    }\n#endif\n    for( int i = 0; i < MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS; i ++ ) {\n        vec3 L = lightDirection[i];\n        float NdotL = max(0.0, dot(N, L));\n        vec3 H = normalize(L + V);\n        float NdotH = dot(N, H);\n        float VdotH = dot(V, H);\n        float Hu = dot(H, Tu);\n        float Hv = dot(H, Tv);\n        vec3 Hlocal = vec3(Hu, Hv, NdotH);\n#if defined(PRISMLAYERED)\n        float N2dotL = dot(N2, L);\n        float N2dotH = dot(N2, H);\n        vec3 Hlocal2 = vec3(Hu, Hv, N2dotH);\n#endif\n        vec3 brdf = lightColor[i] * \n#if defined(PRISMOPAQUE)\n            BRDF_Opaque(Hlocal, NdotL, NdotH, NdotV, VdotH,\n                    surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                    opaqueF0, opaqueAlbedo);\n#elif defined(PRISMMETAL)\n        BRDF_Metal(Hlocal, NdotL, NdotH, NdotV, VdotH, \n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, \n                metalF0);\n#elif defined(PRISMLAYERED)\n        BRDF_Layered(Hlocal, NdotL, NdotH, NdotV, VdotH, Hlocal2, N2dotL, N2dotH, N2dotV,\n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n                layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n        BRDF_Transparent(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation);\n#elif defined(PRISMWOOD)\n        BRDF_Wood(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, woodDiffuse);\n#endif\n        outRadianceLight += max(vec3(0.0), brdf);\n    }\n#endif\n    float opacity = 1.0;\n    vec3 outRadianceEnv = vec3(0.0);\n#if defined( USE_ENVMAP )\n    outRadianceEnv =\n#if defined(PRISMOPAQUE)\n        Environment_Opaque(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n                opaqueF0, opaqueAlbedo, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMMETAL)\n    Environment_Metal(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, metalF0, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMLAYERED)\n    Environment_Layered(N, V, clamp(NdotV, 0.0, 1.0), N2, clamp(N2dotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n            layeredF0, surfaceAnisotropy, surfaceRotation, Tu, Tv, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n            layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n    Environment_Transparent(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#elif defined(PRISMWOOD)\n    Environment_Wood(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, woodDiffuse, surfaceAnisotropy, surfaceRotation, Tu, Tv);\n#endif\n#endif\n    float surface_cutout = 1.0;\n#prism_sample_texture<surface_cutout, surface_cutout, true, false>\n#if defined( USE_SURFACE_CUTOUT_MAP )\n    if(surface_cutout < 0.01) discard;\n#endif\n    gl_FragColor = vec4( outRadianceLight + outRadianceEnv, opacity*surface_cutout );\n#if TONEMAP_OUTPUT == 1\n    gl_FragColor.xyz = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.xyz);\n#elif TONEMAP_OUTPUT == 2\n    gl_FragColor.xyz = toneMapCanonFilmic_WithGamma(exposureBias * gl_FragColor.xyz);\n#endif\n#ifdef USE_FOG\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif\n#if defined(PRISMTRANSPARENT)\n    float fsLevel = max( gl_FragColor.r, gl_FragColor.g );\n    fsLevel = max( gl_FragColor.b, fsLevel );\n    gl_FragColor = vec4( gl_FragColor.r/fsLevel, gl_FragColor.g/fsLevel, gl_FragColor.b/fsLevel, fsLevel );\n    float transLevel = min( transparent_color.r, transparent_color.g );\n    transLevel = min( transparent_color.b, transLevel );\n    transLevel = min( (1.0-surface_roughness), transLevel );\n    float transAlpha = (1.0-transLevel)*0.4 + surface_roughness*0.55;\n    vec3 tr_g_color = sqrt(transparent_color);\n    vec4 transColor = vec4( 0.5 * vec3(tr_g_color), transAlpha );\n    float strength = 1.0 - (1.0-fsLevel)*(1.0-fsLevel);\n    gl_FragColor = mix( transColor, gl_FragColor, strength );\n    if ( gl_FragColor.a < 0.05 ) {\n        gl_FragColor.a = 0.05;\n    }\n    gl_FragColor.a *= surface_cutout;\n    \n    if (transparent_ior == 1.0 && tr_g_color == vec3(1.0,1.0,1.0)) {\n        gl_FragColor.a = 0.0;\n    }\n#endif\n#include<theming_frag>\n#include<final_frag>\n}\n"
};THREE.ShaderLib.prism=Md;var Nd=function(){var a=pc.createShaderMaterial(Md);return a.defaultAttributeValues.uvw=[0,0,0],a.enable3DWoodBump=!1,a.enableImportantSampling=!1,a.mapList={},a.isPrismMaterial=!0,a},Od=function(a){var b=Nd();switch(b.name=a.name,b.side=a.side,b.opacity=a.opacity,b.transparent=a.transparent,b.blending=a.blending,b.blendSrc=a.blendSrc,b.blendDst=a.blendDst,b.blendEquation=a.blendEquation,b.blendSrcAlpha=a.blendSrcAlpha,b.blendDstAlpha=a.blendDstAlpha,b.blendEquationAlpha=a.blendEquationAlpha,b.depthTest=a.depthTest,b.depthWrite=a.depthWrite,b.polygonOffset=a.polygonOffset,b.polygonOffsetFactor=a.polygonOffsetFactor,b.polygonOffsetUnits=a.polygonOffsetUnits,b.alphaTest=a.alphaTest,b.overdraw=a.overdraw,b.visible=a.visible,b.mapList=a.mapList,b.prismType=a.prismType,b.surface_albedo=a.surface_albedo,void 0!==a.surface_albedo_map&&(b.surface_albedo_map=a.surface_albedo_map),b.surface_roughness=a.surface_roughness,void 0!==a.surface_roughness_map&&(b.surface_roughness_map=a.surface_roughness_map),b.surface_anisotropy=a.surface_anisotropy,void 0!==a.surface_anisotropy_map&&(b.surface_anisotropy_map=a.surface_anisotropy_map),b.surface_rotation=a.surface_rotation,void 0!==a.surface_rotation_map&&(b.surface_rotation_map=a.surface_rotation_map),void 0!==a.surface_cutout_map&&(b.surface_cutout_map=a.surface_cutout_map),void 0!==a.surface_normal_map&&(b.surface_normal_map=a.surface_normal_map),b.uniforms.importantSamplingRandomMap.value=a.uniforms.importantSamplingRandomMap.value,b.uniforms.importantSamplingSolidAngleMap.value=a.uniforms.importantSamplingSolidAngleMap.value,b.prismType){case"PrismOpaque":b.opaque_albedo=(new THREE.Color).copy(a.opaque_albedo),b.opaque_luminance_modifier=(new THREE.Color).copy(a.opaque_luminance_modifier),b.opaque_f0=a.opaque_f0,b.opaque_luminance=a.opaque_luminance,void 0!==a.opaque_albedo_map&&(b.opaque_albedo_map=a.opaque_albedo_map),void 0!==a.opaque_luminance_modifier_map&&(b.opaque_luminance_modifier_map=a.opaque_luminance_modifier_map),void 0!==a.opaque_f0_map&&(b.opaque_f0_map=a.opaque_f0_map);break;case"PrismMetal":b.metal_f0=(new THREE.Color).copy(a.metal_f0),void 0!==a.metal_f0_map&&(b.metal_f0_map=a.metal_f0_map);break;case"PrismLayered":b.layered_f0=a.layered_f0,b.layered_diffuse=(new THREE.Color).copy(a.layered_diffuse),b.layered_fraction=a.layered_fraction,b.layered_bottom_f0=(new THREE.Color).copy(a.layered_bottom_f0),b.layered_roughness=a.layered_roughness,b.layered_anisotropy=a.layered_anisotropy,b.layered_rotation=a.layered_rotation,void 0!==a.layered_bottom_f0_map&&(b.layered_bottom_f0_map=a.layered_bottom_f0_map),void 0!==a.layered_f0_map&&(b.layered_f0_map=a.layered_f0_map),void 0!==a.layered_diffuse_map&&(b.layered_diffuse_map=a.layered_diffuse_map),void 0!==a.layered_fraction_map&&(b.layered_fraction_map=a.layered_fraction_map),void 0!==a.layered_rotationlayered_roughness_map&&(b.layered_rotationlayered_roughness_map=a.layered_rotationlayered_roughness_map),void 0!==a.layered_anisotropy_map&&(b.layered_anisotropy_map=a.layered_anisotropy_map),void 0!==a.layered_rotation_map&&(b.layered_rotation_map=a.layered_rotation_map),void 0!==a.layered_normal_map&&(b.layered_normal_map=a.layered_normal_map);break;case"PrismTransparent":b.transparent_color=(new THREE.Color).copy(a.transparent_color),b.transparent_distance=a.transparent_distance,b.transparent_ior=a.transparent_ior,b.transparent=a.transparent,b.twoPassTransparency=a.twoPassTransparency;break;case"PrismWood":b.wood_fiber_cosine_enable=a.wood_fiber_cosine_enable,b.wood_fiber_cosine_bands=a.wood_fiber_cosine_bands,b.wood_fiber_cosine_weights=(new THREE.Vector4).copy(a.wood_fiber_cosine_weights),b.wood_fiber_cosine_frequencies=(new THREE.Vector4).copy(a.wood_fiber_cosine_frequencies),b.wood_fiber_perlin_enable=a.wood_fiber_perlin_enable,b.wood_fiber_perlin_bands=a.wood_fiber_perlin_bands,b.wood_fiber_perlin_weights=(new THREE.Vector4).copy(a.wood_fiber_perlin_weights),b.wood_fiber_perlin_frequencies=(new THREE.Vector4).copy(a.wood_fiber_perlin_frequencies),b.wood_fiber_perlin_scale_z=a.wood_fiber_perlin_scale_z,b.wood_growth_perlin_enable=a.wood_growth_perlin_enable,b.wood_growth_perlin_bands=a.wood_growth_perlin_bands,b.wood_growth_perlin_weights=(new THREE.Vector4).copy(a.wood_growth_perlin_weights),b.wood_growth_perlin_frequencies=(new THREE.Vector4).copy(a.wood_growth_perlin_frequencies),b.wood_latewood_ratio=a.wood_latewood_ratio,b.wood_earlywood_sharpness=a.wood_earlywood_sharpness,b.wood_latewood_sharpness=a.wood_latewood_sharpness,b.wood_ring_thickness=a.wood_ring_thickness,b.wood_earlycolor_perlin_enable=a.wood_earlycolor_perlin_enable,b.wood_earlycolor_perlin_bands=a.wood_earlycolor_perlin_bands,b.wood_earlycolor_perlin_weights=(new THREE.Vector4).copy(a.wood_earlycolor_perlin_weights),b.wood_earlycolor_perlin_frequencies=(new THREE.Vector4).copy(a.wood_earlycolor_perlin_frequencies),b.wood_early_color=(new THREE.Color).copy(a.wood_early_color),b.wood_use_manual_late_color=a.wood_use_manual_late_color,b.wood_manual_late_color=(new THREE.Color).copy(a.wood_manual_late_color),b.wood_latecolor_perlin_enable=a.wood_latecolor_perlin_enable,b.wood_latecolor_perlin_bands=a.wood_latecolor_perlin_bands,b.wood_latecolor_perlin_weights=(new THREE.Vector4).copy(a.wood_latecolor_perlin_weights),b.wood_latecolor_perlin_frequencies=(new THREE.Vector4).copy(a.wood_latecolor_perlin_frequencies),b.wood_late_color_power=a.wood_late_color_power,b.wood_diffuse_perlin_enable=a.wood_diffuse_perlin_enable,b.wood_diffuse_perlin_bands=a.wood_diffuse_perlin_bands,b.wood_diffuse_perlin_weights=(new THREE.Vector4).copy(a.wood_diffuse_perlin_weights),b.wood_diffuse_perlin_frequencies=(new THREE.Vector4).copy(a.wood_diffuse_perlin_frequencies),b.wood_diffuse_perlin_scale_z=a.wood_diffuse_perlin_scale_z,b.wood_use_pores=a.wood_use_pores,b.wood_pore_type=a.wood_pore_type,b.wood_pore_radius=a.wood_pore_radius,b.wood_pore_cell_dim=a.wood_pore_cell_dim,b.wood_pore_color_power=a.wood_pore_color_power,b.wood_pore_depth=a.wood_pore_depth,b.wood_use_rays=a.wood_use_rays,b.wood_ray_color_power=a.wood_ray_color_power,b.wood_ray_seg_length_z=a.wood_ray_seg_length_z,b.wood_ray_num_slices=a.wood_ray_num_slices,b.wood_ray_ellipse_z2x=a.wood_ray_ellipse_z2x,b.wood_ray_ellipse_radius_x=a.wood_ray_ellipse_radius_x,b.wood_use_latewood_bump=a.wood_use_latewood_bump,b.wood_latewood_bump_depth=a.wood_latewood_bump_depth,b.wood_use_groove_roughness=a.wood_use_groove_roughness,b.wood_groove_roughness=a.wood_groove_roughness,b.wood_diffuse_lobe_weight=a.wood_diffuse_lobe_weight,b.uniforms.permutationMap.value=a.uniforms.permutationMap.value,b.uniforms.gradientMap.value=a.uniforms.gradientMap.value,b.uniforms.perm2DMap.value=a.uniforms.perm2DMap.value,b.uniforms.permGradMap.value=a.uniforms.permGradMap.value,void 0!==a.wood_curly_distortion_map&&(b.wood_curly_distortion_map=a.wood_curly_distortion_map,b.wood_curly_distortion_enable=a.wood_curly_distortion_enable,b.wood_curly_distortion_scale=a.wood_curly_distortion_scale),b.wood_ring_fraction=a.wood_ring_fraction,b.wood_fall_rise=a.wood_fall_rise;break;default:THREE.warn("Unknown prism type: "+a.prismType)}return b.envExponentMin=a.envExponentMin,b.envExponentMax=a.envExponentMax,b.envExponentCount=a.envExponentCount,b.envMap=a.envMap,b.defines=a.defines,b},Pd={PrismShader:Md,GetPrismMapUniforms:V,createPrismMaterial:Nd,clonePrismMaterial:Od};!function(a){a[a.DEBUG=5]="DEBUG",a[a.LOG=4]="LOG",a[a.INFO=3]="INFO",a[a.WARNING=2]="WARNING",a[a.ERROR=1]="ERROR",a[a.NONE=0]="NONE"}(a.LogLevels||(a.LogLevels={})),a.logger={initialize:function(a){},shutdown:function(){},track:function(a){},logToADP:function(a){return!1},updateRuntimeStats:function(a){},reportRuntimeStats:function(){},setLevel:function(a){},error:function(){},warn:function(){},info:function(){},log:function(){},debug:function(){}};var Qd,Rd,Sd={MilliMeter:1e3,mm:1e3,8206:1e3,DeciMeter:10,dm:10,8204:10,CentiMeter:100,cm:100,8205:100,Meter:1,m:1,8193:1,KiloMeter:.001,km:.001,8201:.001,Inch:39.37008,in:39.37008,8214:39.37008,Foot:3.28084,ft:3.28084,8215:3.28084,Mile:62137e-8,mi:62137e-8,8225:62137e-8,Yard:1.09361,yard:1.09361,8221:1.09361},Td={convertMaterial:la,convertTexture:oa,isPrismMaterial:pa,convertMaterialGltf:qa,applyAppearanceHeuristics:sa,applyGeometryFlagsToMaterial:ta},Ud=Ld.CreateLinePatternTexture,Vd=Pd.clonePrismMaterial,Wd=function(a){this._renderer=a,this._textures={},this._texturesToUpdate=[],this._materials={},this._materialsNonHDR={},this._exposureBias=0,this._tonemapMethod=0,this._envMapExposure=1,this._envRotationSin=0,this._envRotationCos=1,this._reflectionMap=null,this._irradianceMap=null,this._cutplanes=[],this._mrtNormals=!1,this._mrtIdBuffer=void 0,this._pixelsPerUnit=1,this._layerMaskTex=null,this._layersMap=null,this._lineStyleTex=null,this._selectionTex=null,this._swapBlackAndWhite=0,this._depthWriteTransparent=!0,this._needsTwoSided=!1,this._hasTransparentMaterial=!1,this.hasPrism=!1,this.defaultMaterial=new THREE.MeshPhongMaterial({ambient:197379,color:7829367,specular:3355443,shininess:30,shading:THREE.SmoothShading,reflectivity:0}),this.addMaterial("__defaultMaterial__",this.defaultMaterial)};Wd.MATERIAL_VARIANT={INSTANCED:0,VERTEX_IDS:1},Wd.prototype.dtor=function(){this.cleanup(),THREE.Cache.clear()},Wd.prototype._getModelHash=function(a){return"model:"+(a?a.id:"")+"|"},Wd.prototype._getMaterialHash=function(a,b){return this._getModelHash(a)+"mat:"+b},Wd.prototype._getTextureHash=function(a,b,c){return this._getModelHash(a)+"tex:"+b+"|map:"+c},Wd.prototype.addNonHDRMaterial=function(a,b){b.doNotCut||(b.cutplanes=this._cutplanes),this._materialsNonHDR[a]=b},Wd.prototype.addMaterialNonHDR=function(a,b){this.addNonHDRMaterial.call(this,a,b)},Wd.prototype.addHDRMaterial=function(a,b){this._reflectionMap&&!b.disableEnvMap&&(b.envMap=this._reflectionMap),this._irradianceMap&&(b.irradianceMap=this._irradianceMap),b.exposureBias=Math.pow(2,this._exposureBias),b.tonemapOutput=this._tonemapMethod,b.envMapExposure=this._envMapExposure,b.envRotationSin=this._envRotationSin,b.envRotationCos=this._envRotationCos,b.doNotCut||(b.cutplanes=this._cutplanes),this._applyMRTFlags(b),this._applyPolygonOffset(b,this._polygonOffsetOn),this._materials[a]=b},Wd.prototype.addMaterial=function(a,b,c){var d=b.prismType&&-1!==b.prismType.indexOf("Prism");this.hasPrism=d||this.hasPrism,Td.applyAppearanceHeuristics(b,d||c,this.isDepthWriteTransparentEnabled()),b.side===THREE.DoubleSide&&(this._needsTwoSided=!0),this.addHDRMaterial(a,b)},Wd.prototype.addLineMaterial=function(a,b){this._layerMaskTex&&(b.defines.HAS_LAYERS=1,b.uniforms.tLayerMask.value=this._layerMaskTex),this._lineStyleTex&&(b.defines.HAS_LINESTYLES=1,b.defines.MAX_LINESTYLE_LENGTH=this._lineStyleTex.image.width,b.uniforms.tLineStyle.value=this._lineStyleTex,b.uniforms.vLineStyleTexSize.value.set(this._lineStyleTex.image.width,this._lineStyleTex.image.height)),b.uniforms.aaRange.value=.5/(this._pixelsPerUnit*b.modelScale),b.uniforms.pixelsPerUnit.value=this._pixelsPerUnit*b.modelScale,b.uniforms.swap.value=this._swapBlackAndWhite,this._materials[a]=b},Wd.prototype.addOverrideMaterial=function(a,b){if(this.addNonHDRMaterial(a,b),b.variants)for(var c=0;c<b.variants.length;c++){var d=b.variants[c];if(d){var e=a+"_variant_"+c;this.addNonHDRMaterial(e,d)}}},Wd.prototype.getMaterialVariant=function(a,b,c){var d=this._getModelHash(c)+a.id+"|"+b,e=this._materials[d];return e||(e=this.cloneMaterial(a,c),b===Wd.MATERIAL_VARIANT.INSTANCED?(e.useInstancing=!0,e.vertexIds=!0):b===Wd.MATERIAL_VARIANT.VERTEX_IDS&&(e.vertexIds=!0),this.addHDRMaterial(d,e)),e},Wd.prototype.addInstancingSupport=function(a){var b=a.clone();b.useInstancing=!0;var c=a.clone();c.wideLines=!0,a.variants=[b,c],a.getCustomOverrideMaterial=function(a){return a.useInstancing?this.variants[0]:a.wideLines?this.variants[1]:null}},Wd.prototype.removeMaterial=function(a){delete this._materials[a]},Wd.prototype.findMaterial=function(a,b){var c=this._getMaterialHash(a,b),d=this._materials[c];return d||(THREE.warn("Unknown material "+b+". Using default."),d=this.defaultMaterial),d},Wd.prototype.hasTransparentMaterial=function(){return this._hasTransparentMaterial},Wd.prototype.convertOneMaterial=function(a,b,c){var d=a.getData(),e=Td.convertMaterial(b);d.doubleSided&&(e.side=THREE.DoubleSide);var f=this._getMaterialHash(a,c);if(this.addMaterial(f,e),this._hasTransparentMaterial=this._hasTransparentMaterial||e.transparent,b.decals){e.decals=[];for(var g=0,h=b.decals.length;g<h;g++){var i=b.decals[g],j=Td.convertMaterial(i.material);e.decals.push({uv:i.uv||0,material:j}),this.addMaterial(f+"|decal|"+g,j)}}},Wd.prototype.forEach=function(a){var b=this._materials;for(var c in b)a(b[c])},Wd.prototype.updateMaterials=function(){for(var a={needsClear:!1,needsRender:!1,overlayDirty:!1};this._texturesToUpdate.length;)for(var b=this._texturesToUpdate.pop(),c=0;c<b.mats.length;c++)b.mats[c][b.slots[c]]=b.tex,b.mats[c].needsUpdate=!0,a.needsClear=!0;return a},Wd.prototype.setTextureInCache=function(a,b,c){var d=this._getTextureHash(a,b.uri,b.mapName),e=this._textures[d];if(e){e.tex||(e.tex=c);for(var f=0;f<e.mats.length;f++)e.mats[f][e.slots[f]]=c;this._texturesToUpdate.push(e)}},Wd.prototype.loadTextureFromCache=function(a,b,c,d){var e=this._getTextureHash(a,c.uri,c.mapName),f=this._textures[e];return f?f.tex?(b[d]=f.tex,b.needsUpdate=!0):(f.mats.push(b),f.slots.push(d)):this._textures[e]={mats:[b],slots:[d],tex:null},!!f},Wd.prototype.exportModelMaterials=function(a,b){var c=this._getModelHash(a),d={};for(var e in this._materials)if(-1!==e.indexOf(c)){var f=this._materials[e],g=f.defines&&f.defines.hasOwnProperty("SELECTION_RENDERER");g||(d[e]=f)}var h={};for(var e in this._materialsNonHDR)-1!==e.indexOf(c)&&(h[e]=this._materialsNonHDR[e]);var i={};for(var j in this._textures)-1!==j.indexOf(c)&&(i[j]=this._textures[j]);return this.cleanup(a),{mats:d,matsNonHDR:h,textures:i}},Wd.prototype.importModelMaterials=function(a){for(var b in a.mats){var c=a.mats[b];c.is2d?this.addLineMaterial(b,c):this.addHDRMaterial(b,c)}for(var b in a.matsNonHDR)this.addMaterialNonHDR(b,a.matsNonHDR[b]);for(var d in a.textures)this._textures[d]=a.textures[d]},Wd.prototype.cloneMaterial=function(b,c){var d=b.isPrismMaterial?Vd(b):b.clone();if(b.defines&&(d.defines=av.ObjectAssign({},b.defines)),(d instanceof THREE.MeshPhongMaterial||d.isPrismMaterial)&&(d.packedNormals=b.packedNormals,d.exposureBias=b.exposureBias,d.irradianceMap=b.irradianceMap,d.envMapExposure=b.envMapExposure,d.envRotationSin=b.envRotationSin,d.envRotationCos=b.envRotationCos,d.proteinType=b.proteinType,d.proteinMat=b.proteinMat,d.tonemapOutput=b.tonemapOutput,d.cutplanes=b.cutplanes,d.textureMaps=b.textureMaps,d.texturesLoaded=b.texturesLoaded),b.is2d&&(d.is2d=!0),b.textureMaps)for(var e in b.textureMaps)if(b[e])d[e]=b[e];else if(c){var f=d.textureMaps[e],g=f.uri,h=f.mapName,i=this._getTextureHash(c,g,h),j=this._textures[i];j?(j.mats.push(d),j.slots.push(e)):a.logger.error("Missing texture receiver",i)}return this._applyMRTFlags(d),d},Wd.prototype.setupMaterial=function(a,b,c){var d,e=a.getData();if(b.isLines||b.isPoints){var f=!!b.attributes.color,g=this.findMaterial(a,c);b.isPoints?d=new THREE.PointCloudMaterial({vertexColors:f,size:b.pointSize}):b.isWideLines?(d=new THREE.MeshBasicMaterial({vertexColors:f}),d.wideLines=!0,b.isLines=!1,d.polygonOffset=g.polygonOffset,d.polygonOffsetFactor=g.polygonOffsetFactor,d.polygonOffsetUnits=g.polygonOffsetUnits):f?(g.cachedLineMaterialVC||(g.cachedLineMaterialVC=new THREE.LineBasicMaterial({vertexColors:f})),d=g.cachedLineMaterialVC):(g.cachedLineMaterial||(g.cachedLineMaterial=new THREE.LineBasicMaterial({vertexColors:f})),d=g.cachedLineMaterial),f||(d.color=g.color),d.svfMatId=c,this.addMaterialNonHDR(e.basePath+c+"_line_"+d.id,d),e.hasLines=!0}else d=this.findMaterial(a,c),d&&(d.svfMatId=c),Td.applyGeometryFlagsToMaterial(d,b);return d},Wd.prototype.cleanup=function(a){var b=this._getModelHash(a),c={};for(var d in this._textures){var e=this._textures[d];-1===d.indexOf(b)?c[d]=e:e.tex&&(e.tex.dispose(),e.tex.needsUpdate=!0)}this._textures=c;var f={},g={type:"dispose"};for(var h in this._materials)if(a&&-1===h.indexOf(b))f[h]=this._materials[h];else{var i=this._materials[h];if(i.dispatchEvent(g),i.needsUpdate=!0,i.envMap=null,i.is2d){i.uniforms.tLayerMask.value=null,i.uniforms.tLineStyle.value=null;var j=i.uniforms.tRaster;j&&j.value instanceof THREE.Texture&&(j.value.dispose(),j.value.needsUpdate=!0)}}this._materials=f;var k={};for(var h in this._materialsNonHDR)if(a&&-1===h.indexOf(b))k[h]=this._materialsNonHDR[h];else{var i=this._materialsNonHDR[h];i.dispatchEvent(g),i.needsUpdate=!0}this._materialsNonHDR=k},Wd.prototype.toggleDepthWriteTransparent=function(a){this._depthWriteTransparent!=a&&(this._depthWriteTransparent=a,this.forEach(function(b){b.lmv_depthWriteTransparent&&(b.depthWrite=a)}))},Wd.prototype.isDepthWriteTransparentEnabled=function(){return this._depthWriteTransparent},Wd.prototype.hasTwoSidedMaterials=function(){return this._needsTwoSided},Wd.prototype.texturesLoaded=function(){return 0===this._texturesToUpdate.length},Wd.prototype.setTonemapExposureBias=function(a){this._exposureBias=a;var b=Math.pow(2,a);this.forEach(function(a){a.exposureBias=b,a.needsUpdate=!0})},Wd.prototype.setTonemapMethod=function(a){this._tonemapMethod=a,this.forEach(function(b){b.tonemapOutput=a,b.needsUpdate=!0})},Wd.prototype.setEnvExposure=function(a){var b=Math.pow(2,a);this._envMapExposure=b,this.forEach(function(a){a.envMapExposure=b,a.needsUpdate=!0})},Wd.prototype.setEnvRotation=function(a){var b=this._envRotationSin=Math.sin(a),c=this._envRotationCos=Math.cos(a);this.forEach(function(a){a.envRotationSin=b,a.envRotationCos=c,a.needsUpdate=!0})},Wd.prototype.setReflectionMap=function(a){this._reflectionMap=a,this.forEach(function(b){b.disableEnvMap||(b.envMap=a,b.needsUpdate=!0)})},Wd.prototype.setIrradianceMap=function(a){this._irradianceMap=a,this.forEach(function(b){b.disableEnvMap||(b.irradianceMap=a,b.needsUpdate=!0)})},Wd.prototype.setCutPlanes=function(a){if(this._cutplanes.length!==(a?a.length||0:0)){this.forEach(function(b){b.doNotCut||(b.needsUpdate=!0,a&&a.length>0&&(b.side=THREE.DoubleSide))});for(var b in this._materialsNonHDR)this._materialsNonHDR[b].doNotCut||(this._materialsNonHDR[b].needsUpdate=!0)}for(;this._cutplanes.length>0;)this._cutplanes.pop();if(a)for(var c=0;c<a.length;c++)this._cutplanes.push(a[c].clone())},Wd.prototype.getCutPlanes=function(){return this._cutplanes.slice()},Wd.prototype.getCutPlanesRaw=function(){return this._cutplanes},Wd.prototype._applyPolygonOffset=function(a){(a instanceof THREE.MeshPhongMaterial||a.isPrismMaterial)&&(a.polygonOffset=this._polygonOffsetOn,a.polygonOffsetFactor=this._polygonOffsetFactor,a.polygonOffsetUnits=this._polygonOffsetUnits,a.extraDepthOffset&&(a.polygonOffsetFactor+=a.extraDepthOffset),a.needsUpdate=!0)},Wd.prototype.getPolygonOffsetOn=function(){return this._polygonOffsetOn},Wd.prototype.getPolygonOffsetFactor=function(){return this._polygonOffsetFactor},Wd.prototype.getPolygonOffsetUnits=function(){return this._polygonOffsetUnits},Wd.prototype.togglePolygonOffset=function(a,b,c){this._polygonOffsetOn=a,this._polygonOffsetFactor=a?b||1:0,this._polygonOffsetUnits=a?c||.1:0;var d=this;this.forEach(function(a){d._applyPolygonOffset(a)})},Wd.prototype._applyMRTFlags=function(a){var b=a.supportsMrtNormals||a instanceof THREE.MeshPhongMaterial||a.isPrismMaterial,c=a.mrtNormals,d=a.mrtIdBuffer,e=this._renderer&&this._renderer.supportsMRT();a.mrtNormals=b&&e&&this._mrtNormals,a.mrtIdBuffer=e?this._mrtIdBuffer:void 0,a.mrtNormals===c&&a.mrtIdBuffer===d||(a.needsUpdate=!0)},Wd.prototype.toggleMRTSetting=function(a){this._mrtNormals=a.mrtNormals,this._mrtIdBuffer=a.mrtIdBuffer;var b=this;this.forEach(function(a){a.is2d||b._applyMRTFlags(a)})},Wd.prototype.initLineStyleTexture=function(){this._lineStyleTex=Ud()},Wd.prototype.initLayersTexture=function(a,b){for(var c=new Uint8Array(65536),d=0,e=a;d<e;d++)c[d]=255;var f=new THREE.DataTexture(c,256,256,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter,0);f.generateMipmaps=!1,f.flipY=!1,f.needsUpdate=!0,this._layerMaskTex=f,this._layersMap=b},Wd.prototype.setLayerVisible=function(a,b){for(var c=this._layerMaskTex,d=c.image.data,e=this._layersMap,f=b?255:0,g=0;g<a.length;++g){d[e[a[g]]]=f}c.needsUpdate=!0,this.forEach(function(a){a.is2d&&(a.needsUpdate=!0)})},Wd.prototype.isLayerVisible=function(a){return!!this._layerMaskTex.image.data[this._layersMap[a]]},Wd.prototype.initSelectionTexture=function(a){for(var b=a||1,c=0|Math.ceil(b/4096),d=1;d<c;)d*=2;c=d;for(var e=new Uint8Array(4096*c),f=0;f<b;f++)e[f]=0;var g=new THREE.DataTexture(e,4096,c,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter,0);return g.generateMipmaps=!1,g.flipY=!1,g.needsUpdate=!0,this._selectionTex=g,g},Wd.prototype.highlightObject2D=function(a,b){this._selectionTex.image.data[a]=b?255:0,this._selectionTex.needsUpdate=!0},Wd.prototype.updatePixelScale=function(a){var b=this._pixelsPerUnit=a;this.forEach(function(a){a.is2d&&(a.uniforms.aaRange.value=.5/(b*a.modelScale),a.uniforms.pixelsPerUnit.value=b*a.modelScale)})},Wd.prototype.updateSwapBlackAndWhite=function(a){var b=this._swapBlackAndWhite=a?1:0;this.forEach(function(a){a.is2d&&(a.uniforms.swap.value=b)})},Wd.prototype.updateViewportId=function(a){this.forEach(function(b){b.is2d&&(b.uniforms.viewportId.value=a,b.needsUpdate=!0)})};var Xd=id.getVertexCount,Yd=Id.runMergeSingleThreaded,Zd=Id.ParallelGeomMerge,$d=Wd.MATERIAL_VARIANT,_d={UNKNOWN:0,TRIANGLES:1,LINES:2,WIDE_LINES:3,POINTS:4};wa.prototype={constructor:wa,addGeom:function(a,b,c){this.geoms.push(a),this.fragIds.push(c),this.worldBox.union(b),this.vertexCount+=Xd(a);var d=this.geoms.length;return 1==d?0:(void 0===a.byteSize&&THREE.warn("Error in consolidation: Geometry must contain byteSize."),a.byteSize+(2==d?this.geoms[0].byteSize:0))}},Da.prototype={constructor:Da,addContainerMesh:function(a,b,c,d,e){var f=new THREE.Mesh(a,b);this.meshes.push(f),this.byteSize+=a.byteSize;var g=d||0,h=e||c.length,i=g+h;f.frustumCulled=!1;for(var j=this.meshes.length-1,k=g;k<i;k++){var l=c[k];this.fragId2MeshIndex[l]=j}},addSingleMesh:function(a,b,c,d,e){var f=new THREE.Mesh(a,b);f.matrix.copy(d),f.matrixAutoUpdate=!1,f.dbId=e,f.fragId=c,this.meshes.push(f),f.frustumCulled=!1,this.fragId2MeshIndex[c]=this.meshes.length-1},addSingleFragment:function(a,b){var c=a.getVizmesh(b);this.addSingleMesh(c.geometry,c.material,b,c.matrixWorld,c.dbId)}},Ea.prototype={addGeom:function(a,b,c,d){var e=null,f=this.buckets[b.id];if(f)for(var g=0;g<f.length;g++){var h=f[g],i=h.geoms[0];if(Ca(i,a)){var j=Xd(a);if(!(j+h.vertexCount>65535)){e=h;break}}}e||(e=new wa(b),this.bucketCount++,this.buckets[b.id]?this.buckets[b.id].push(e):this.buckets[b.id]=[e]),this.costs+=e.addGeom(a,c,d)},createConsolidationMap:function(a,b){var c=a.length,d=new Fa(c,this.bucketCount),e=0,f=0;for(var g in this.buckets)for(var h=this.buckets[g],i=0;i<h.length;i++){var j=h[i];d.ranges[f]=e,d.boxes[f]=j.worldBox,d.fragOrder.set(j.fragIds,e),e+=j.fragIds.length,f++}d.numConsolidated=b;for(var k=b;k<a.length;k++)d.fragOrder[k]=a[k];return d}},Fa.prototype={buildConsolidation:function(a,b,c){var d=this.fragOrder,e=a.getCount(),f=this.ranges.length,g=new Da(e),h=null;Ha()&&(h=new Zd(g));for(var i=[],j=new THREE.Matrix4,k=0;k<f;k++){var l=this.ranges[k],m=k===f-1?this.numConsolidated:this.ranges[k+1],n=m-l;if(1===n){var o=d[l];g.addSingleFragment(a,o,g)}i.length=n;for(var p=new Float32Array(16*n),q=new Uint32Array(n),r=0;r<n;r++)o=d[l+r],i[r]=a.getGeometry(o),a.getOriginalWorldMatrix(o,j),p.set(j.elements,16*r),q[r]=a.getDbIds(o);var s=this.boxes[k],t=d[l],u=a.getMaterial(t),v=Ba(i,p,q,s,h),w=b.getMaterialVariant(u,$d.VERTEX_IDS,c);g.addContainerMesh(v,w,d,l,n)}return h&&h.runTasks(),g.consolidationMap=this,g}};var ae={copyVertexFormat:xa,copyPrimitiveProps:ya,mergeGeometries:Ba,Consolidation:Da,ConsolidationBuilder:Ea,registerWorkerSupport:Ga,multithreadingSupported:Ha},be=_b.resolve,ce="undefined"!=typeof navigator&&!!navigator.userAgent.match(/Trident\/7\./),de=["opaque_luminance_modifier","surface_albedo","surface_roughness","surface_anisotropy","surface_rotation","opaque_f0","opaque_albedo","metal_f0","layered_f0","layered_diffuse","layered_roughness","layered_anisotropy","layered_rotation","layered_bottom_f0","layered_fraction","surface_cutout","wood_curly_distortion"],ee=function(a,b,c){var d="uv_"+a+"_map",e="";return b&&c?e="if ("+d+".x < 0.0 || "+d+".x > 1.0 || "+d+".y < 0.0 || "+d+".y > 1.0) { discard; }":b?e="if ("+d+".x < 0.0 || "+d+".x > 1.0) { discard; }":c&&(e="if ("+d+".y < 0.0 || "+d+".y > 1.0) { discard; }"),"#define "+a.toUpperCase()+"_CLAMP_TEST "+e},fe=function(){var a=0,b=function(a){var b,c,d=[];for(var e in a)!1!==(b=a[e])&&(c="#define "+e+" "+b,d.push(c));return d.join("\n")},c=function(a,b,c){for(var d={},e=0,f=c.length;e<f;e++){var g=c[e];d[g]=a.getUniformLocation(b,g)}return d},d=function(a,b,c){for(var d={},e=0,f=c.length;e<f;e++){var g=c[e];d[g]=a.getAttribLocation(b,g)}return d},e=function(a,b,c,d,e){var f=d?"1.0-":"",g="texture2D("+a+", (UV))",h="";return e=e||"vec4(0.0)",b&&c?h="((UV).x < 0.0 || (UV).x > 1.0 || (UV).y < 0.0 || (UV).y > 1.0) ? "+e+" : ":b?h="((UV).x < 0.0 || (UV).x > 1.0) ? "+e+" : ":c&&(h="((UV).y < 0.0 || (UV).y > 1.0) ? "+e+" : "),"#define GET_"+a.toUpperCase()+"(UV) ("+h+f+g+")"},f=function(a){for(var b="\n",c=0;c<de.length;c++){var d=a[de[c]];d&&(b+=ee(de[c],d.S,d.T)+"\n")}return b};return function(g,h,i,j){var k=g,l=k.context,m=i.defines,n=i.__webglShader.uniforms,o=i.attributes,p=be(i.__webglShader.vertexShader),q=be(i.__webglShader.fragmentShader),r=i.index0AttributeName;void 0===r&&!0===j.morphTargets&&(r="position");j.envMap;var s,t,u=g.gammaFactor>0?g.gammaFactor:1,v=b(m),w=l.createProgram();i instanceof THREE.RawShaderMaterial?(s="",t=""):(s=["precision "+j.precision+" float;","precision "+j.precision+" int;",v,j.vertexPrefix,j.supportsVertexTextures?"#define VERTEX_TEXTURES":"",k.gammaInput?"#define GAMMA_INPUT":"",k.gammaOutput?"#define GAMMA_OUTPUT":"","#define GAMMA_FACTOR "+u,j.mrtNormals?"#define MRT_NORMALS":"",j.mrtIdBuffer?"#define MRT_ID_BUFFER":"","#define MAX_DIR_LIGHTS "+j.maxDirLights,"#define MAX_POINT_LIGHTS "+j.maxPointLights,"#define MAX_SPOT_LIGHTS "+j.maxSpotLights,"#define MAX_HEMI_LIGHTS "+j.maxHemiLights,"#define MAX_BONES "+j.maxBones,"#define NUM_CUTPLANES "+j.numCutplanes,j.map?"#define USE_MAP":"",j.envMap?"#define USE_ENVMAP":"",j.envMap?"#define ENVMAP_MODE_REFLECTION":"",j.irradianceMap?"#define USE_IRRADIANCEMAP":"",j.lightMap?"#define USE_LIGHTMAP":"",j.bumpMap?"#define USE_BUMPMAP":"",j.normalMap?"#define USE_NORMALMAP":"",j.specularMap?"#define USE_SPECULARMAP":"",j.alphaMap?"#define USE_ALPHAMAP":"",j.vertexColors?"#define USE_COLOR":"",j.vertexIds?"#define USE_VERTEX_ID":"",j.useInstancing?"#define USE_INSTANCING":"",j.wideLines?"#define WIDE_LINES":"",j.skinning?"#define USE_SKINNING":"",j.useVertexTexture?"#define BONE_TEXTURE":"",j.morphTargets?"#define USE_MORPHTARGETS":"",j.morphNormals?"#define USE_MORPHNORMALS":"",j.wrapAround?"#define WRAP_AROUND":"",j.doubleSided?"#define DOUBLE_SIDED":"",j.flipSided?"#define FLIP_SIDED":"",j.sizeAttenuation?"#define USE_SIZEATTENUATION":"",j.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",j.useFragDepthExt?"#define USE_LOGDEPTHBUF_EXT":"",j.packedNormals?"#define UNPACK_NORMALS":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","attribute vec3 position;","#ifdef UNPACK_NORMALS","attribute vec2 normal;","#else","attribute vec3 normal;","#endif","attribute vec2 uv;","attribute vec2 uv2;","#ifdef PRISMWOOD","attribute vec3 uvw;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif",""].join("\n"),t=[j.bumpMap||j.normalMap?"#extension GL_OES_standard_derivatives : enable":"",!j.mrtIdBuffer&&!j.mrtNormals||ce?"":"#extension GL_EXT_draw_buffers : enable",j.mrtIdBuffer?"#define gl_FragColor gl_FragData[0]":"",j.haveTextureLod?"#define HAVE_TEXTURE_LOD":"",v,j.fragmentPrefix,"#define MAX_DIR_LIGHTS "+j.maxDirLights,"#define MAX_POINT_LIGHTS "+j.maxPointLights,"#define MAX_SPOT_LIGHTS "+j.maxSpotLights,"#define MAX_HEMI_LIGHTS "+j.maxHemiLights,"#define NUM_CUTPLANES "+j.numCutplanes,j.alphaTest?"#define ALPHATEST "+j.alphaTest:"",k.gammaInput?"#define GAMMA_INPUT":"",k.gammaOutput?"#define GAMMA_OUTPUT":"","#define GAMMA_FACTOR "+u,j.mrtNormals?"#define MRT_NORMALS":"",j.mrtIdBuffer?"#define MRT_ID_BUFFER":"",j.mrtIdBuffer>1?"#define MODEL_COLOR":"","#define TONEMAP_OUTPUT "+(j.tonemapOutput||0),j.useFog&&j.fog?"#define USE_FOG":"",j.useFog&&j.fogExp?"#define FOG_EXP2":"",j.map?"#define USE_MAP":"",j.envMap?"#define USE_ENVMAP":"",j.envMap?"#define ENVMAP_TYPE_CUBE":"",j.envMap?"#define ENVMAP_MODE_REFLECTION":"",j.envMap?"#define ENVMAP_BLENDING_MULTIPLY":"",j.irradianceMap?"#define USE_IRRADIANCEMAP":"",j.envGammaEncoded?"#define ENV_GAMMA":"",j.irrGammaEncoded?"#define IRR_GAMMA":"",j.envRGBM?"#define ENV_RGBM":"",j.irrRGBM?"#define IRR_RGBM":"",j.lightMap?"#define USE_LIGHTMAP":"",j.bumpMap?"#define USE_BUMPMAP":"",j.normalMap?"#define USE_NORMALMAP":"",j.specularMap?"#define USE_SPECULARMAP":"",j.alphaMap?"#define USE_ALPHAMAP":"",j.vertexColors?"#define USE_COLOR":"",j.vertexIds?"#define USE_VERTEX_ID":"",j.metal?"#define METAL":"",j.clearcoat?"#define CLEARCOAT":"",j.wrapAround?"#define WRAP_AROUND":"",j.doubleSided?"#define DOUBLE_SIDED":"",j.flipSided?"#define FLIP_SIDED":"",j.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",j.hatchPattern?"#define HATCH_PATTERN":"",j.mapInvert?"#define MAP_INVERT":"",e("map",j.mapClampS,j.mapClampT),e("bumpMap",j.bumpMapClampS,j.bumpMapClampT),e("normalMap",j.normalMapClampS,j.normalMapClampT),e("specularMap",j.specularMapClampS,j.specularMapClampT),e("alphaMap",j.alphaMapClampS,j.alphaMapClampT,j.alphaMapInvert),"#ifdef USE_ENVMAP","#ifdef HAVE_TEXTURE_LOD","#extension GL_EXT_shader_texture_lod : enable","#endif","#endif","#extension GL_OES_standard_derivatives : enable","precision "+j.precisionFragment+" float;","precision "+j.precisionFragment+" int;","uniform highp mat4 viewMatrix;","uniform highp mat4 projectionMatrix;","uniform highp vec3 cameraPosition;","#if defined(USE_ENVMAP) || defined(USE_IRRADIANCEMAP)","uniform mat4 viewMatrixInverse;","#endif",""].join("\n"),j.isPrism&&(t+=f(j)));var x=new Yc(l,l.VERTEX_SHADER,s+p),y=new Yc(l,l.FRAGMENT_SHADER,t+q);l.attachShader(w,x),l.attachShader(w,y),void 0!==r&&l.bindAttribLocation(w,0,r),l.linkProgram(w),l.deleteShader(x),l.deleteShader(y);var z=["viewMatrix","modelViewMatrix","projectionMatrix","normalMatrix","modelMatrix","cameraPosition","viewMatrixInverse","mvpMatrix","dbId"];j.logarithmicDepthBuffer&&z.push("logDepthBufFC");for(var A in n)z.push(A);this.uniforms=c(l,w,z),z=["position","normal","uv","uv2","tangent","color","lineDistance","uvw","id","instOffset","instScaling","instRotation","prev","next","side"];for(var B in o)z.push(B);return this.attributes=d(l,w,z),this.attributesKeys=Object.keys(this.attributes),this.id=a++,this.code=h,this.usedTimes=1,this.program=w,this.vertexShader=x,this.fragmentShader=y,this}}(),ge={PrismMaps:de,GetPrismMapChunk:ee,WebGLProgram:fe},he={uniforms:{cutplanes:{type:"v4v",value:[]}},
vertexShader:"#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\n#endif\nuniform float logDepthBufFC;\n#endif\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );;\n#if NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#ifdef USE_LOGDEPTHBUF\n    gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n    vFragDepth = 1.0 + gl_Position.w;\n#else\n    gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n#endif\n#endif\n}\n",fragmentShader:"#ifdef USE_LOGDEPTHBUF\nuniform float logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n#extension GL_EXT_frag_depth : enable\nvarying float vFragDepth;\n#endif\n#endif\n#include<pack_depth>\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#include<cutplanes>\nvoid main() {\n#if NUM_CUTPLANES > 0\n    checkCutPlanes(vWorldPosition);\n#endif\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_LOGDEPTHBUF_EXT\n    float depth = gl_FragDepthEXT / gl_FragCoord.w;\n#else\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n#endif\n    depth = 1.0 - depth;\n    gl_FragColor = packDepth(depth);\n}\n"},ie={uniforms:{tDepth:{type:"t",value:null},worldSize:{type:"v3",value:new THREE.Vector3(1,1,1)}},defines:{},vertexShader:bc,fragmentShader:"#define NUM_SAMPLES 29.0\n#define NUM_SPIRAL_TURNS 7.0\nuniform sampler2D tDepth;\nuniform vec3 worldSize;\nvarying vec2 vUv;\n#ifdef PRESET_2\n#define SAMPLE_RADIUS 0.3\n#define AO_GAMMA 1.0\n#define AO_INTENSITY 1.0\n#else\n#define SAMPLE_RADIUS 0.2\n#define AO_GAMMA 3.0\n#define AO_INTENSITY 0.8\n#endif\n#include<pack_depth>\n#define PI 3.14159265358979\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat getRandomAngle(vec2 pos) {\n    return rand(pos) * (2.0 * PI);\n}\nvec2 tapLocation(float sampleNumber, float spinAngle, out float ssR){\n    float alpha = float(sampleNumber + 0.5) * (1.0 / NUM_SAMPLES);\n    float angle = alpha * (NUM_SPIRAL_TURNS * PI * 2.0) + spinAngle;\n    ssR = alpha;\n    return vec2(cos(angle), sin(angle));\n}\nvec2 sampleAO(vec2 unitDirection, float radius) {\n    vec2 sampleOffset = unitDirection * radius;\n    float idepth = unpackDepth(texture2D(tDepth, vUv + sampleOffset));\n    float depth = 1.0 - idepth;\n    if (depth < 1e-6) {\n        if (radius == 0.0)\n            return vec2(1.0, 1.0);\n        else\n            return vec2(0.0, 1.0);\n    }\n    vec3 dir = vec3(sampleOffset.x, depth, sampleOffset.y) * worldSize;\n    float distance2 = dot(dir,dir);\n    float idistance = 1.0 / sqrt(distance2);\n    vec3 ndir = dir * idistance;\n#ifdef PRESET_2\n    float importance = ndir.y * idistance;\n#else\n    float importance = ndir.y / distance2;\n#endif\n    vec2 ret;\n    ret.x = (idepth == 0.0) ? 0.0 : importance;\n    ret.y = importance;\n    return ret;\n}\nvoid main() {\n    vec2 sum = vec2(0.0);\n    float angle = getRandomAngle(vUv);\n    for (float i = 0.0; i<NUM_SAMPLES; i+= 1.0) {\n        float ssR;\n        vec2 uv = tapLocation(i, angle, ssR);\n        sum += sampleAO(uv, ssR * SAMPLE_RADIUS);\n    }\n    float ao = sum.x / sum.y;\n    gl_FragColor = packDepth(AO_INTENSITY * clamp(pow(ao, AO_GAMMA), 0.0, 0.9999));\n}\n"},je={uniforms:{tDepth:{type:"t",value:null}},defines:{},vertexShader:bc,fragmentShader:"uniform sampler2D tDepth;\nvarying vec2 vUv;\n#ifdef HORIZONTAL\n#define GET_UV(X) vec2(vUv.x + KERNEL_SCALE*(X), vUv.y)\n#else\n#define GET_UV(Y) vec2(vUv.x, vUv.y + KERNEL_SCALE*(Y))\n#endif\n#include<pack_depth>\n#define PI 3.14159265358979\n#define SIGMA ((2.0 * KERNEL_RADIUS+1.0) / 6.0)\n#define SIGMASQ2 (2.0 * SIGMA * SIGMA)\n#ifdef BOX\n#define KERNEL_VAL(X) 1.0\n#else\n#define KERNEL_VAL(X) ( (1.0 / sqrt(PI * SIGMASQ2)) * exp(-(X)*(X)/SIGMASQ2) )\n#endif\nvoid main() {\n    float depthVal = 0.0;\n    float sum = 0.0;\n    for (float x=-KERNEL_RADIUS; x<=KERNEL_RADIUS; x+=1.0) {\n        depthVal += unpackDepth(texture2D(tDepth, GET_UV(x))) * KERNEL_VAL(x);\n        sum += KERNEL_VAL(x);\n    }\n    gl_FragColor = packDepth(depthVal/sum);\n}\n"},ke={uniforms:{tDepth:{type:"t",value:null},uShadowColor:{type:"v4",value:new THREE.Vector4(0,0,0,1)}},vertexShader:bc,fragmentShader:"uniform sampler2D tDepth;\nuniform vec4 uShadowColor;\nvarying vec2 vUv;\n#include<pack_depth>\nvoid main() {\n    float depthVal = unpackDepth(texture2D(tDepth, vUv));\n    gl_FragColor = vec4(uShadowColor.rgb, uShadowColor.a * depthVal);\n}\n"},le=function(){var a,b,c;return function(d,e,f,g,h){a||(a=new THREE.Matrix4),b||(b=new THREE.Vector3),c||(c=new THREE.Vector3),b.subVectors(e,g),a.lookAt(b,e,h),c.copy(g).multiplyScalar(-.5*f.y).add(e),d.position.copy(c),d.rotation.setFromRotationMatrix(a),d.scale.set(f.z,f.x,f.y)}}(),me=function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n=a,o=!1,p=!0,q=1,r={texSize:64,pixScale:1,blurRadius:7,debug:!1};if(this.setTransform=function(){var a=new THREE.Vector3(0,0,0),b=new THREE.Vector3(0,0,0),d=new THREE.Vector3(0,0,0),f=new THREE.Vector3(0,0,0);return function(g,h,i,j){g.equals(a)&&h.equals(b)&&i.equals(d)&&j.equals(f)||(a.copy(g),b.copy(h),d.copy(i),f.copy(j),this.setDirty(),c.left=-h.z/2,c.right=h.z/2,c.top=h.x/2,c.bottom=-h.x/2,c.near=1,c.far=h.y+c.near,c.updateProjectionMatrix(),le(e,g,h,i,j),c.position.addVectors(g,i.clone().multiplyScalar(-h.y/2-c.near)),j&&c.up.set(j.x,j.y,j.z),c.lookAt(g),r.debug&&(m.position.set(g.x,g.y,g.z),m.rotation.set(c.rotation.x,c.rotation.y,c.rotation.z),m.scale.set(h.z,h.x,h.y)),l.uniforms.worldSize.value.copy(h))}}(),this.renderIntoShadow=function(a){if(!a.overrideMaterial||!a.overrideMaterial.transparent){var b=a.overrideMaterial;a.overrideMaterial=h,n.render(a,c,f,!1),a.overrideMaterial=b}},this.prepareGroundShadow=function(){var a,b=0,c=0,d=0;return function(e,f,g,h){if(!this.enabled||e.isEmpty())return q=1,g;if(a!=e.getGeomScenes()&&(p=!0),p)this.clear(),p=!1,a=e.getGeomScenes(),b=a.length,c=0,d=f?Math.max(Math.ceil(b/100),f):b;else{if(2===q||1===q)return q=1,g;0===f&&(d=b)}var i,j;g&&(i=performance.now(),h=void 0===h?1:h,j=h*g);for(var k,l=0;l<d&&c<b;){var m=a[c++];if(m&&(l++,m.forceVisible=!0,this.renderIntoShadow(m),m.forceVisible=!1,g)){var n=performance.now()-i;if(j<n){q=0,k=g-n;break}}}return c<b&&(q=0,k=g?g-performance.now()+i:1),void 0!==k?k:(this.postprocess(),q=2,g?g-performance.now()+i:1)}}(),this.renderShadow=function(a,b){o&&(b?n.render(d,a,b,!1):n.render(d,a))},this.postprocess=function(){k.render(n,g,f),j.render(n,f,g),o=!0},this.clear=function(){var a=n.getClearColor().getHex(),b=n.getClearAlpha();n.setClearColor(0,0),n.clearTarget(f,!0,!0,!1),n.setClearColor(a,b),n.clearBlend(),o=!1},this.setColor=function(a){i.uniforms.uShadowColor.value.x=a.r,i.uniforms.uShadowColor.value.y=a.g,i.uniforms.uShadowColor.value.z=a.b},this.getColor=function(){return new THREE.Color(i.uniforms.uShadowColor.value.x,i.uniforms.uShadowColor.value.y,i.uniforms.uShadowColor.value.z)},this.setAlpha=function(a){i.uniforms.uShadowColor.value.w=a},this.getAlpha=function(){return i.uniforms.uShadowColor.value.w},this.isValid=function(){return o},this.getStatus=function(){return q},this.setDirty=function(){p=!0,q=0},this.getDepthMaterial=function(){return h},b)for(var s in r)r[s]=b[s]||r[s];d=new THREE.Scene,c=new THREE.OrthographicCamera,f=new THREE.WebGLRenderTarget(r.texSize,r.texSize,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1}),f.generateMipmaps=!1,g=new THREE.WebGLRenderTarget(r.texSize,r.texSize,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1}),g.generateMipmaps=!1,h=pc.createShaderMaterial(he),h.side=THREE.DoubleSide,h.blending=THREE.NoBlending,j=new qc(je,"tDepth"),k=new qc(je,"tDepth"),l=new qc(ie,"tDepth"),j.material.defines.KERNEL_SCALE=k.material.defines.KERNEL_SCALE=(r.pixScale/r.texSize).toFixed(4),j.material.defines.KERNEL_RADIUS=k.material.defines.KERNEL_RADIUS=r.blurRadius.toFixed(2),l.material.blending=j.material.blending=k.material.blending=THREE.NoBlending,l.material.depthWrite=j.material.depthWrite=k.material.depthWrite=!1,l.material.depthTest=j.material.depthTest=k.material.depthTest=!1,j.material.defines.HORIZONTAL=1,i=pc.createShaderMaterial(ke),i.uniforms.tDepth.value=f,i.depthWrite=!1,i.transparent=!0,e=Ja(i),d.add(e),r.debug&&(m=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshBasicMaterial({color:65280,wireframe:!0})),d.add(m)),this.setTransform(new THREE.Vector3(0,0,0),new THREE.Vector3(1,1,1),new THREE.Vector3(0,1,0),THREE.Object3D.DefaultUp)};me.prototype.constructor=me;var ne={GroundShadow:me,createGroundShape:Ja,setGroundShapeTransform:le},oe={uniforms:THREE.UniformsUtils.merge([_b.ShadowMapCommonUniforms,{shadowMapRangeMin:{type:"f",value:0},shadowMapRangeSize:{type:"f",value:0},shadowMinOpacity:{type:"f",value:0},map:{type:"t",value:null},alphaMap:{type:"t",value:null},texMatrix:{type:"m3",value:new THREE.Matrix3},texMatrixAlpha:{type:"m3",value:new THREE.Matrix3}},Pd.GetPrismMapUniforms("surface_cutout_map")]),vertexShader:"#include<shadowmap_decl_common>\nvarying float depth;\n#ifdef USE_SURFACE_CUTOUT_MAP\nvarying vec2 vUv;\n#else\n#ifdef USE_MAP\nvarying vec2 vUv;\nuniform mat3 texMatrix;\n#endif\n#ifdef USE_ALPHAMAP\nvarying vec2 vUvAlpha;\nuniform mat3 texMatrixAlpha;\n#endif\n#endif\nvoid passCutoutUVCoords() {\n#ifdef USE_SURFACE_CUTOUT_MAP\n    vUv = uv;\n#else\n#ifdef USE_MAP\n    vUv = (texMatrix * vec3(uv, 1.0)).xy;\n#endif\n#ifdef USE_ALPHAMAP\n    vUvAlpha = (texMatrixAlpha * vec3(uv, 1.0)).xy;\n#endif\n#endif\n}\nvoid main() {\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vec4 p_Position = projectionMatrix * mvPosition;\n    gl_Position = p_Position;\n    depth = -mvPosition.z;\n    passCutoutUVCoords();\n}\n",fragmentShader:"#include<shadowmap_decl_common>\nvarying float depth;\n#ifdef USE_SURFACE_CUTOUT_MAP\n#include<float3_average>\n#prism_uniforms<surface_cutout_map>\nvarying vec2 vUv;\n#else\n#ifdef USE_MAP\nvarying vec2 vUv;\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nvarying vec2 vUvAlpha;\nuniform sampler2D alphaMap;\n#endif\n#endif\nuniform float shadowMinOpacity;\nvoid applyCutoutMaps() {\n    float opacity = 1.0;\n#ifdef USE_SURFACE_CUTOUT_MAP\n#prism_sample_texture<surface_cutout, opacity, true, false>\n#else\n#ifdef USE_MAP\n    opacity *= GET_MAP(vUv).a;\n#endif\n#ifdef USE_ALPHAMAP\n    opacity *= GET_ALPHAMAP(vUvAlpha).r;\n#endif\n#endif\n#if defined(USE_SURFACE_CUTOUT_MAP) || defined(USE_MAP) || defined(USE_ALPHAMAP)\n    if (opacity < shadowMinOpacity) discard;\n#endif\n}\nvoid main() {\n    float normalizedLinearDepth = (depth - shadowMapRangeMin) / shadowMapRangeSize;\n    float val = exp(shadowESMConstant * normalizedLinearDepth);\n#ifdef USE_HARD_SHADOWS\n    val = normalizedLinearDepth;\n#endif\n    applyCutoutMaps();\n    gl_FragColor = vec4(val, 0, 0, 1);\n}\n"},pe={uniforms:_b.ShadowMapUniforms,vertexShader:"#include<shadowmap_decl_vert>\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n#include<shadowmap_vert>\n}\n",fragmentShader:"#include<shadowmap_decl_frag>\nvoid main() {\n    float shadowIntensity = 0.5 * (1.0 - getShadowValue());\n    gl_FragColor = vec4(0.0, 0.0, 0.0, shadowIntensity);\n}\n"},qe=function(){function a(){this.init=function(){this.isPrism=!1,this.alphaMap=!1,this.alphaClampS=!1,this.alphaClampT=!1,this.alphaInvert=!1,this.rgbaMap=!1,this.rgbaClampS=!1,this.rgbaClampT=!1,this.rgbaInvert=!1,this.instanced=!1,this.decalIndex=-1},this.init(),this.getMaterialIndex=function(){return(this.isPrism?1:0)|(this.alphaMap?2:0)|(this.alphaClampS?4:0)|(this.alphaClampT?8:0)|(this.alphaInvert?16:0)|(this.rgbaMap?32:0)|(this.rgbaClampS?64:0)|(this.rgbaClampT?128:0)|(this.rgbaInvert?256:0)|(this.instanced?512:0)|1024*(this.decalIndex+1)}}function b(a,b){var c=a.getMaterialIndex();if(!e[c]){var d=f.clone();a.isPrism&&a.alphaMap&&(pc.setMacro(d,"USE_SURFACE_CUTOUT_MAP"),d.fragmentShader=fe.GetPrismMapChunk("surface_cutout",a.alphaClampS,a.alphaClampT)+"\n"+d.fragmentShader),a.instanced&&(d.useInstancing=!0),e[c]=d}return e[c]}function c(a){return a instanceof THREE.MeshPhongMaterial?a.opacity<re.ShadowMinOpacity:a.isPrismMaterial?"PrismTransparent"===a.prismType:!a.visible}function d(a,d){if(c(a))return g;var e=a instanceof THREE.MeshPhongMaterial,f=a.isPrismMaterial;if(!e&&!f)return null;var h=e?a.alphaMap:a.surface_cutout_map,j=e&&a.alphaTest?a.map:null;if(!h&&!j&&!a.useInstancing)return null;var k=i;k.init(),k.isPrism=f,k.alphaMap=!!h,k.rgbaMap=!!j,k.instanced=a.useInstancing,k.decalIndex=void 0===d?-1:d,h&&(k.alphaClampS=h.clampS,k.alphaClampT=h.clampT,k.alphaInvert=h.invert),j&&(k.rgbaClampS=j.clampS,k.rgbaClampT=j.clampT,k.rgbaInvert=j.invert);var l=b(k,d);return h&&(e?(l.uniforms.alphaMap.value=h,l.uniforms.texMatrixAlpha.value=h.matrix,l.alphaMap=h,l.side=a.side):(l.uniforms.surface_cutout_map.value=h,l.uniforms.surface_cutout_map_texMatrix.value.copy(h.matrix),l.uniforms.surface_cutout_map_invert.value=h.invert,l.side=THREE.DoubleSide)),j&&(l.uniforms.map.value=j,l.uniforms.texMatrix.value=j.matrix,l.map=j),l}var e=[],f=pc.createShaderMaterial(oe),g=new THREE.Material;g.visible=!1;var h=[],i=new a;this.forEachMaterial=function(a){for(var b=0;b<e.length;b++){var c=e[b];c&&a(c)}a(f)},this.getCustomOverrideMaterial=function(a){var b=d(a);if(!b)return null;if(!a.decals)return b.decals=null,b;if(a.decals){h.length=0;for(var c=0;c<a.decals.length;c++){var e=a.decals[c],f=d(e.material,c);if(!f)return null;h.push({uv:e.uv,material:f})}}return b.decals=h,b},this.dispose=function(){this.forEachMaterial(function(a){a.dispose()})}},re={ShadowMapSize:1024,ShadowESMConstant:80,ShadowBias:.001,ShadowDarkness:.7,ShadowMapBlurRadius:4,ShadowMinOpacity:.9,UseHardShadows:!1,BlurShadowMap:!0},se=0,te=1,ue=2,ve=new Ka;Ma.RefreshUniformsShadow=function(a,b){a.shadowMap&&(a.shadowMap.value=b.shadowMap),a.shadowMatrix&&(a.shadowMatrix.value=b.shadowMatrix),a.shadowLightDir&&(a.shadowLightDir.value=b.shadowLightDir),a.shadowESMConstant&&(a.shadowESMConstant.value=re.ShadowESMConstant),a.shadowBias&&(a.shadowBias.value=re.ShadowBias),a.shadowMapSize&&(a.shadowMapSize.value=re.ShadowMapSize),a.shadowDarkness&&(a.shadowDarkness.value=re.ShadowDarkness)};var we={ShadowMapOverrideMaterials:qe,SHADOWMAP_NEEDS_UPDATE:0,SHADOWMAP_INCOMPLETE:1,SHADOWMAP_VALID:2,ShadowConfig:re,ShadowRender:Ma,ShadowMaps:La},xe=function(a){function b(a){a.__webglVertexBuffer=Oa.createBuffer(),a.__webglColorBuffer=Oa.createBuffer(),a.__webglLineDistanceBuffer=Oa.createBuffer(),Sa.info.memory.geometries++}function c(a){a.__webglVertexBuffer=Oa.createBuffer(),a.__webglColorBuffer=Oa.createBuffer(),Sa.info.memory.geometries++}function d(a){a.__webglVertexBuffer=Oa.createBuffer(),a.__webglNormalBuffer=Oa.createBuffer(),a.__webglTangentBuffer=Oa.createBuffer(),a.__webglColorBuffer=Oa.createBuffer(),a.__webglUVBuffer=Oa.createBuffer(),a.__webglUV2Buffer=Oa.createBuffer(),a.__webglSkinIndicesBuffer=Oa.createBuffer(),a.__webglSkinWeightsBuffer=Oa.createBuffer(),a.__webglFaceBuffer=Oa.createBuffer(),a.__webglLineBuffer=Oa.createBuffer(),Sa.info.memory.geometries++}function e(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var g=1;"v2"===f.type?g=2:"v3"===f.type?g=3:"v4"===f.type?g=4:"c"===f.type&&(g=3),f.size=g,f.array=new Float32Array(c*g),f.buffer=Oa.createBuffer(),f.buffer.belongsToAttribute=e,f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}function f(a,b){var c=a.vertices.length;a.__vertexArray=new Float32Array(3*c),a.__colorArray=new Float32Array(3*c),a.__lineDistanceArray=new Float32Array(1*c),a.__webglLineCount=c,e(a,b)}function g(a,b){var c=a.vertices.length;a.__vertexArray=new Float32Array(3*c),a.__colorArray=new Float32Array(3*c),a.__webglPointCount=c,e(a,b)}function h(a,b){var c=b.geometry,d=a.faces3,e=3*d.length,f=1*d.length,g=3*d.length,h=i(b,a),j=m(h),n=k(h),o=l(h);a.__vertexArray=new Float32Array(3*e),n&&(a.__normalArray=new Float32Array(3*e)),c.hasTangents&&(a.__tangentArray=new Float32Array(4*e)),o&&(a.__colorArray=new Float32Array(3*e)),j&&(c.faceVertexUvs.length>0&&(a.__uvArray=new Float32Array(2*e)),c.faceVertexUvs.length>1&&(a.__uv2Array=new Float32Array(2*e))),b.geometry.skinWeights.length&&b.geometry.skinIndices.length&&(a.__skinIndexArray=new Float32Array(4*e),a.__skinWeightArray=new Float32Array(4*e));var p=null!==pb.get("OES_element_index_uint")&&f>21845?Uint32Array:Uint16Array;if(a.__typeArray=p,a.__faceArray=new p(3*f),a.__lineArray=new p(2*g),a.__webglFaceCount=3*f,a.__webglLineCount=2*g,h.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var q in h.attributes){var r=h.attributes[q],s={};for(var t in r)s[t]=r[t];if(!s.__webglInitialized||s.createUniqueBuffers){s.__webglInitialized=!0;var u=1;"v2"===s.type?u=2:"v3"===s.type?u=3:"v4"===s.type?u=4:"c"===s.type&&(u=3),s.size=u,s.array=new Float32Array(e*u),s.buffer=Oa.createBuffer(),s.buffer.belongsToAttribute=q,r.needsUpdate=!0,s.__original=r}a.__webglCustomAttributesList.push(s)}}a.__inittedArrays=!0}function i(a,b){return a.material instanceof THREE.MeshFaceMaterial?a.material.materials[b.materialIndex]:a.material}function j(a){return a&&void 0!==a.shading&&a.shading===THREE.SmoothShading}function k(a){return!(a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial)&&(j(a)?THREE.SmoothShading:THREE.FlatShading)}function l(a){return!!a.vertexColors&&a.vertexColors}function m(a){return!!(a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a.alphaMap||a instanceof THREE.ShaderMaterial)}function n(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,o=a.vertices,p=a.colors,q=a.lineDistances,r=o.length,s=p.length,t=q.length,u=a.__vertexArray,v=a.__colorArray,w=a.__lineDistanceArray,x=a.verticesNeedUpdate,y=a.colorsNeedUpdate,z=a.lineDistancesNeedUpdate,A=a.__webglCustomAttributesList;if(x){for(c=0;c<r;c++)f=o[c],g=3*c,u[g]=f.x,u[g+1]=f.y,u[g+2]=f.z;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglVertexBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,u,b)}if(y){for(d=0;d<s;d++)h=p[d],g=3*d,v[g]=h.r,v[g+1]=h.g,v[g+2]=h.b;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglColorBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,v,b)}if(z){for(e=0;e<t;e++)w[e]=q[e];Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglLineDistanceBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,w,b)}if(A)for(i=0,j=A.length;i<j;i++)if(n=A[i],n.needsUpdate&&(void 0===n.boundTo||"vertices"===n.boundTo)){if(g=0,l=n.value.length,1===n.size)for(k=0;k<l;k++)n.array[k]=n.value[k];else if(2===n.size)for(k=0;k<l;k++)m=n.value[k],n.array[g]=m.x,n.array[g+1]=m.y,g+=2;else if(3===n.size)if("c"===n.type)for(k=0;k<l;k++)m=n.value[k],n.array[g]=m.r,n.array[g+1]=m.g,n.array[g+2]=m.b,g+=3;else for(k=0;k<l;k++)m=n.value[k],n.array[g]=m.x,n.array[g+1]=m.y,n.array[g+2]=m.z,g+=3;else if(4===n.size)for(k=0;k<l;k++)m=n.value[k],n.array[g]=m.x,n.array[g+1]=m.y,n.array[g+2]=m.z,n.array[g+3]=m.w,g+=4;Oa.bindBuffer(Oa.ARRAY_BUFFER,n.buffer),Oa.bufferData(Oa.ARRAY_BUFFER,n.array,b)}}function o(a,b){var c,d,e,f,g,h,i,j,k,l,m,n=a.vertices,o=a.colors,p=n.length,q=o.length,r=a.__vertexArray,s=a.__colorArray,t=a.verticesNeedUpdate,u=a.colorsNeedUpdate,v=a.__webglCustomAttributesList;if(t){for(c=0;c<p;c++)e=n[c],f=3*c,r[f]=e.x,r[f+1]=e.y,r[f+2]=e.z;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglVertexBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,r,b)}if(u){for(d=0;d<q;d++)g=o[d],f=3*d,s[f]=g.r,s[f+1]=g.g,s[f+2]=g.b;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglColorBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,s,b)}if(v)for(h=0,i=v.length;h<i;h++)if(m=v[h],m.needsUpdate&&(void 0===m.boundTo||"vertices"===m.boundTo)){if(f=0,k=m.value.length,1===m.size)for(j=0;j<k;j++)m.array[j]=m.value[j];else if(2===m.size)for(j=0;j<k;j++)l=m.value[j],m.array[f]=l.x,m.array[f+1]=l.y,f+=2;else if(3===m.size)if("c"===m.type)for(j=0;j<k;j++)l=m.value[j],m.array[f]=l.r,m.array[f+1]=l.g,m.array[f+2]=l.b,f+=3;else for(j=0;j<k;j++)l=m.value[j],m.array[f]=l.x,m.array[f+1]=l.y,m.array[f+2]=l.z,f+=3;else if(4===m.size)for(j=0;j<k;j++)l=m.value[j],m.array[f]=l.x,m.array[f+1]=l.y,m.array[f+2]=l.z,m.array[f+3]=l.w,f+=4;Oa.bindBuffer(Oa.ARRAY_BUFFER,m.buffer),Oa.bufferData(Oa.ARRAY_BUFFER,m.array,b)}}function p(a,b,c,d,e){if(a.__inittedArrays){var f,g,h,i,j,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J=k(e),K=l(e),L=m(e),M=J===THREE.SmoothShading,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=a.__vertexArray,Y=a.__uvArray,Z=a.__uv2Array,$=a.__normalArray,_=a.__tangentArray,aa=a.__colorArray,ba=a.__webglCustomAttributesList,ca=a.__faceArray,da=a.__lineArray,ea=b.geometry,fa=ea.verticesNeedUpdate,ga=ea.elementsNeedUpdate,ha=ea.uvsNeedUpdate,ia=ea.normalsNeedUpdate,ja=ea.tangentsNeedUpdate,ka=ea.colorsNeedUpdate,la=ea.vertices,ma=a.faces3,na=ea.faces,oa=ea.faceVertexUvs[0],pa=ea.faceVertexUvs[1];if(fa){for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],t=la[i.a],u=la[i.b],v=la[i.c],X[O]=t.x,X[O+1]=t.y,X[O+2]=t.z,X[O+3]=u.x,X[O+4]=u.y,X[O+5]=u.z,X[O+6]=v.x,X[O+7]=v.y,X[O+8]=v.z,O+=9;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglVertexBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,X,c)}if(ka&&K){for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],o=i.vertexColors,p=i.color,3===o.length&&K===THREE.VertexColors?(z=o[0],A=o[1],B=o[2]):(z=p,A=p,B=p),aa[V]=z.r,aa[V+1]=z.g,aa[V+2]=z.b,aa[V+3]=A.r,aa[V+4]=A.g,aa[V+5]=A.b,aa[V+6]=B.r,aa[V+7]=B.g,aa[V+8]=B.b,V+=9;V>0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglColorBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,aa,c))}if(ja&&ea.hasTangents){for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],q=i.vertexTangents,w=q[0],x=q[1],y=q[2],_[T]=w.x,_[T+1]=w.y,_[T+2]=w.z,_[T+3]=w.w,_[T+4]=x.x,_[T+5]=x.y,_[T+6]=x.z,_[T+7]=x.w,_[T+8]=y.x,_[T+9]=y.y,_[T+10]=y.z,_[T+11]=y.w,T+=12;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglTangentBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,_,c)}if(ia&&J){for(f=0,g=ma.length;f<g;f++)if(i=na[ma[f]],j=i.vertexNormals,n=i.normal,3===j.length&&M)for(C=0;C<3;C++)E=j[C],$[S]=E.x,$[S+1]=E.y,$[S+2]=E.z,S+=3;else for(C=0;C<3;C++)$[S]=n.x,$[S+1]=n.y,$[S+2]=n.z,S+=3;Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglNormalBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,$,c)}if(ha&&oa&&L){for(f=0,g=ma.length;f<g;f++)if(h=ma[f],void 0!==(r=oa[h]))for(C=0;C<3;C++)F=r[C],Y[P]=F.x,Y[P+1]=F.y,P+=2;P>0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglUVBuffer),Oa.bufferData(Oa.ARRAY_BUFFER,Y,c))}if(ha&&pa&&L){for(f=0,g=ma.length;f<g;f++)if(h=ma[f],void 0!==(s=pa[h]))for(C=0;C<3;C++)G=s[C],Z[Q]=G.x,Z[Q+1]=G.y,Q+=2;Q>0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,a.__webglUV2Buffer),Oa.bufferData(Oa.ARRAY_BUFFER,Z,c))}if(ga){for(f=0,g=ma.length;f<g;f++)ca[R]=N,ca[R+1]=N+1,ca[R+2]=N+2,R+=3,da[U]=N,da[U+1]=N+1,da[U+2]=N,da[U+3]=N+2,da[U+4]=N+1,da[U+5]=N+2,U+=6,N+=3;Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,a.__webglFaceBuffer),Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,ca,c),Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,a.__webglLineBuffer),Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,da,c)}if(ba)for(C=0,D=ba.length;C<D;C++)if(I=ba[C],I.__original.needsUpdate){if(W=0,1===I.size){if(void 0===I.boundTo||"vertices"===I.boundTo)for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],I.array[W]=I.value[i.a],I.array[W+1]=I.value[i.b],I.array[W+2]=I.value[i.c],W+=3;else if("faces"===I.boundTo)for(f=0,g=ma.length;f<g;f++)H=I.value[ma[f]],I.array[W]=H,I.array[W+1]=H,I.array[W+2]=H,W+=3}else if(2===I.size){if(void 0===I.boundTo||"vertices"===I.boundTo)for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],t=I.value[i.a],u=I.value[i.b],v=I.value[i.c],I.array[W]=t.x,I.array[W+1]=t.y,I.array[W+2]=u.x,I.array[W+3]=u.y,I.array[W+4]=v.x,I.array[W+5]=v.y,W+=6;else if("faces"===I.boundTo)for(f=0,g=ma.length;f<g;f++)H=I.value[ma[f]],t=H,u=H,v=H,I.array[W]=t.x,I.array[W+1]=t.y,I.array[W+2]=u.x,I.array[W+3]=u.y,I.array[W+4]=v.x,I.array[W+5]=v.y,W+=6}else if(3===I.size){var qa;if(qa="c"===I.type?["r","g","b"]:["x","y","z"],void 0===I.boundTo||"vertices"===I.boundTo)for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],t=I.value[i.a],u=I.value[i.b],v=I.value[i.c],I.array[W]=t[qa[0]],I.array[W+1]=t[qa[1]],I.array[W+2]=t[qa[2]],I.array[W+3]=u[qa[0]],I.array[W+4]=u[qa[1]],I.array[W+5]=u[qa[2]],I.array[W+6]=v[qa[0]],I.array[W+7]=v[qa[1]],I.array[W+8]=v[qa[2]],W+=9;else if("faces"===I.boundTo)for(f=0,g=ma.length;f<g;f++)H=I.value[ma[f]],t=H,u=H,v=H,I.array[W]=t[qa[0]],I.array[W+1]=t[qa[1]],I.array[W+2]=t[qa[2]],I.array[W+3]=u[qa[0]],I.array[W+4]=u[qa[1]],I.array[W+5]=u[qa[2]],I.array[W+6]=v[qa[0]],I.array[W+7]=v[qa[1]],I.array[W+8]=v[qa[2]],W+=9;else if("faceVertices"===I.boundTo)for(f=0,g=ma.length;f<g;f++)H=I.value[ma[f]],t=H[0],u=H[1],v=H[2],I.array[W]=t[qa[0]],I.array[W+1]=t[qa[1]],I.array[W+2]=t[qa[2]],I.array[W+3]=u[qa[0]],I.array[W+4]=u[qa[1]],I.array[W+5]=u[qa[2]],I.array[W+6]=v[qa[0]],I.array[W+7]=v[qa[1]],I.array[W+8]=v[qa[2]],W+=9}else if(4===I.size)if(void 0===I.boundTo||"vertices"===I.boundTo)for(f=0,g=ma.length;f<g;f++)i=na[ma[f]],t=I.value[i.a],u=I.value[i.b],v=I.value[i.c],I.array[W]=t.x,I.array[W+1]=t.y,I.array[W+2]=t.z,I.array[W+3]=t.w,I.array[W+4]=u.x,I.array[W+5]=u.y,I.array[W+6]=u.z,I.array[W+7]=u.w,I.array[W+8]=v.x,I.array[W+9]=v.y,I.array[W+10]=v.z,I.array[W+11]=v.w,W+=12;else if("faces"===I.boundTo)for(f=0,g=ma.length;f<g;f++)H=I.value[ma[f]],t=H,u=H,v=H,I.array[W]=t.x,I.array[W+1]=t.y,I.array[W+2]=t.z,I.array[W+3]=t.w,I.array[W+4]=u.x,I.array[W+5]=u.y,I.array[W+6]=u.z,I.array[W+7]=u.w,I.array[W+8]=v.x,I.array[W+9]=v.y,I.array[W+10]=v.z,I.array[W+11]=v.w,W+=12;else if("faceVertices"===I.boundTo)for(f=0,g=ma.length;f<g;f++)H=I.value[ma[f]],t=H[0],u=H[1],v=H[2],I.array[W]=t.x,I.array[W+1]=t.y,I.array[W+2]=t.z,I.array[W+3]=t.w,I.array[W+4]=u.x,I.array[W+5]=u.y,I.array[W+6]=u.z,I.array[W+7]=u.w,I.array[W+8]=v.x,I.array[W+9]=v.y,I.array[W+10]=v.z,I.array[W+11]=v.w,W+=12;Oa.bindBuffer(Oa.ARRAY_BUFFER,I.buffer),Oa.bufferData(Oa.ARRAY_BUFFER,I.array,c)}d&&(delete a.__inittedArrays,delete a.__colorArray,delete a.__normalArray,delete a.__tangentArray,delete a.__uvArray,delete a.__uv2Array,delete a.__faceArray,delete a.__vertexArray,delete a.__lineArray,delete a.__skinIndexArray,delete a.__skinWeightArray)}}function q(a){if(a.streamingDraw){if(!a.streamingIndex){var b=a.attributes.index;b&&(b.buffer=Oa.createBuffer(),Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,b.buffer),Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,b.array||a.ib,Oa.STATIC_DRAW))}}else{a.vb&&void 0===a.vbbuffer&&(a.vbbuffer=Oa.createBuffer(),a.vbNeedsUpdate=!0),a.ib&&void 0===a.ibbuffer&&(a.ibbuffer=Oa.createBuffer(),Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,a.ibbuffer),Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,a.ib,Oa.STATIC_DRAW)),a.iblines&&void 0===a.iblinesbuffer&&(a.iblinesbuffer=Oa.createBuffer(),Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,a.iblinesbuffer),Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,a.iblines,Oa.STATIC_DRAW));for(var c=a.attributes,d=a.attributesKeys,e=0,f=d.length;e<f;e++){var g=d[e],h=c[g],i="index"===g;if(h.array&&void 0===h.buffer&&(h.buffer=Oa.createBuffer(),h.needsUpdate=!0),!0===h.needsUpdate){var j=i?Oa.ELEMENT_ARRAY_BUFFER:Oa.ARRAY_BUFFER;Oa.bindBuffer(j,h.buffer),Oa.bufferData(j,h.array,Oa.STATIC_DRAW),h.needsUpdate=!1}}a.vbNeedsUpdate&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,a.vbbuffer),Oa.bufferData(Oa.ARRAY_BUFFER,a.vb,Oa.STATIC_DRAW),a.vbNeedsUpdate=!1,a.discardAfterUpload&&(a.vb=null))}}function r(a,b,c,d){var e;if(c.streamingDraw)return c.vaos=null,!1;if(c.offsets&&c.offsets.length>1)return c.vaos=null,!1;if(!Ra)return c.vaos=null,!1;if(void 0===c.vaos&&(c.vaos=[]),e=Ra.createVertexArrayOES(),c.vaos.push({geomhash:b.id,uv:d,vao:e}),Ra.bindVertexArrayOES(e),a.isEdgeMaterial)Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,c.iblinesbuffer);else{var f=c.attributes.index;f&&Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,c.ibbuffer||f.buffer)}for(var g=null,h=b.attributes,i=b.attributesKeys,j=c.vbstride,k=c.offsets&&c.offsets.length?c.offsets[0].index:0,l=0,m=i.length;l<m;l++){var n=i[l],o=h[n];if(o>=0){var p=c.attributes[n];if("uv"===n&&d&&(p=c.attributes["uv"+(d+1)]),!p){Ra.bindVertexArrayOES(null);for(var q=0;q<c.vaos.length;q++)Ra.deleteVertexArrayOES(c.vaos[q].vao);return c.vaos=null,!1}var r=Oa.FLOAT,s=p.bytesPerItem||4;1===s?r=Oa.UNSIGNED_BYTE:2===s&&(r=Oa.UNSIGNED_SHORT),Oa.enableVertexAttribArray(o),void 0!==p.itemOffset?(g!=c.vbbuffer&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,c.vbbuffer),g=c.vbbuffer),Oa.vertexAttribPointer(o,p.itemSize,r,!!p.normalize,4*j,4*(p.itemOffset+k*j))):(Oa.bindBuffer(Oa.ARRAY_BUFFER,p.buffer),g=p.buffer,Oa.vertexAttribPointer(o,p.itemSize,r,!!p.normalize,0,k*p.itemSize*s)),Qa&&Qa.vertexAttribDivisorANGLE(o,c.numInstances?p.divisor||0:0)}}return!0}function s(a,b,c,d){var e=c.vaos;if(e)for(var f=0,g=e.length;f<g;f++){var h=e[f];if(h.geomhash===b.id&&h.uv===d)return Ra.bindVertexArrayOES(h.vao),!0}else if(null===e)return!1;return r(a,b,c,d)}function t(a,b){var c=fb[a];return c||(c=Oa.createBuffer(),fb[a]=c),Oa.bindBuffer(Oa.ARRAY_BUFFER,c),Oa.bufferData(Oa.ARRAY_BUFFER,b,Oa.DYNAMIC_DRAW),c}function u(a,b,c,d,e,f){var g,h=b.attributes,i=b.attributesKeys,j=0;if(e)if(!e.buffer&&c.streamingDraw){var k=fb.index;k||(k=Oa.createBuffer(),fb.index=k),Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,k),a.isEdgeMaterial?Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,c.iblines,Oa.DYNAMIC_DRAW):Oa.bufferData(Oa.ELEMENT_ARRAY_BUFFER,e.array||c.ib,Oa.DYNAMIC_DRAW)}else a.isEdgeMaterial?Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,c.iblinesbuffer):Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,c.ibbuffer||e.buffer);for(var l=0,m=i.length;l<m;l++){var n=i[l],o=h[n];if(o>=0){var p=c.attributes[n];if("uv"===n&&f&&(p=c.attributes["uv"+(f+1)]),p){var q,r,s=void 0!==p.itemOffset;s?(q=c.vbstride,r=p.itemOffset,j!==g&&(c.streamingDraw?j=t("interleavedVB",c.vb):(j=c.vbbuffer,Oa.bindBuffer(Oa.ARRAY_BUFFER,j)),g=j)):(q=p.itemSize,r=0,c.streamingDraw?j=t(n,p.array):(j=p.buffer,Oa.bindBuffer(Oa.ARRAY_BUFFER,j)));var u=Oa.FLOAT,v=p.bytesPerItem||4;1===v?u=Oa.UNSIGNED_BYTE:2===v&&(u=Oa.UNSIGNED_SHORT),s&&(v=4),ob.enableAttribute(o),Oa.vertexAttribPointer(o,p.itemSize,u,p.normalize,q*v,(r+d*q)*v),Qa&&Qa.vertexAttribDivisorANGLE(o,c.numInstances?p.divisor||0:0)}else if(a.defaultAttributeValues){var w=a.defaultAttributeValues[n];w&&2===w.length?Oa.vertexAttrib2fv(o,a.defaultAttributeValues[n]):w&&3===w.length?Oa.vertexAttrib3fv(o,a.defaultAttributeValues[n]):w&&4===w.length&&Oa.vertexAttrib4fv(o,a.defaultAttributeValues[n])}}}ob.disableUnusedAttributes()}function v(a,b){return a.object.renderOrder!==b.object.renderOrder?a.object.renderOrder-b.object.renderOrder:a.z!==b.z?a.z-b.z:a.id-b.id}function w(a,b){return a.object.renderOrder!==b.object.renderOrder?a.object.renderOrder-b.object.renderOrder:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?b.z-a.z:a.id-b.id}function x(a){z(a,!0)}function y(a){z(a,!1)}function z(a,b,c){var d,e;if(c||!1!==a.visible){if(a instanceof THREE.Scene||a instanceof THREE.Group);else if(a instanceof C)a.forEach(b?x:y);else if(I(a),a instanceof THREE.Light)Ha.push(a);else{var f=Ia[a.id];if(f&&(!1===a.frustumCulled||!0===gb.intersectsObject(a)))for(d=0,e=f.length;d<e;d++){var g=f[d];H(g),g.render=!0,!0===b&&(jb.setFromMatrixPosition(a.matrixWorld),jb.applyProjection(hb),g.z=jb.z)}}if(a.children)for(d=0,e=a.children.length;d<e;d++)z(a.children[d],b,c)}}function A(a,b){if(!b.getCustomOverrideMaterial)return b;var c=b.getCustomOverrideMaterial(a);return c||b}function B(a,b,c,d,e){for(var f,g=0,h=a.length;g<h;g++){var i=a[g],j=i.object,k=i.buffer;if(e)f=A(i.material,e);else{if(!(f=i.material))continue;U(f)}if(f.twoPassTransparency){var l=f.side;f.side=THREE.BackSide,D(f,b,c,d,k,e,j),f.side=THREE.FrontSide,D(f,b,c,d,k,e,j),f.side=l}else D(f,b,c,d,k,e,j)}}function D(a,b,c,d,e,f,g){if(Sa.setMaterialFaces(a),
e instanceof THREE.BufferGeometry?Sa.renderBufferDirect(b,c,d,a,e,g):Sa.renderBuffer(b,c,d,a,e,g),a.decals)for(var h=a.decals,i=0,j=h.length;i<j;i++){var k=h[i];a=k.material,U(a),Sa.setMaterialFaces(a),e instanceof THREE.BufferGeometry&&Sa.renderBufferDirect(b,c,d,a,e,g,k.uv)}}function E(a,b){if(a.visible&&!a.hide){var c;if(Tb)c=A(a.material,Tb);else{if(!(c=a.material))return;U(c)}if(c.twoPassTransparency){var d=c.side;c.side=THREE.BackSide,F(a,c),c.side=THREE.FrontSide,F(a,c),c.side=d}else F(a,c)}}function F(a,b){if(Sa.setMaterialFaces(b),Sa.renderBufferDirect(Qb,Rb,Sb,b,a.geometry,a),b.decals)for(var c=b.decals,d=0,e=c.length;d<e;d++){var f=c[d];b=f.material,U(b),Sa.setMaterialFaces(b),Sa.renderBufferDirect(Qb,Rb,Sb,b,a.geometry,a,f.uv)}}function G(a,b,c,d,e,f){Qb=c,Rb=d,Sb=e,Tb=f||null,a.forEach(E,a.forceVisible?1:128,!1)}function H(a){var b=a.object,c=a.buffer,d=b.geometry,e=b.material;if(e instanceof THREE.MeshFaceMaterial){var f=d instanceof THREE.BufferGeometry?0:c.materialIndex;e=e.materials[f],a.material=e,e.transparent?Na.push(a):Ma.push(a)}else e&&(a.material=e,e.transparent?Na.push(a):Ma.push(a))}function I(a){void 0===a.__webglInit&&(a.__webglInit=!0,a.addEventListener("removed",Gb));var d=a.geometry;if(void 0===d||void 0===d.__webglInit&&(d.__webglInit=!0,d.addEventListener("dispose",Hb),d instanceof THREE.BufferGeometry||(a instanceof THREE.Mesh?K(a,d):a instanceof THREE.Line?void 0===d.__webglVertexBuffer&&(b(d),f(d,a),d.verticesNeedUpdate=!0,d.colorsNeedUpdate=!0,d.lineDistancesNeedUpdate=!0):a instanceof THREE.PointCloud&&void 0===d.__webglVertexBuffer&&(c(d),g(d,a),d.verticesNeedUpdate=!0,d.colorsNeedUpdate=!0))),void 0===a.__webglActive)if(a.__webglActive=!0,a instanceof THREE.Mesh){if(d instanceof THREE.BufferGeometry)L(Ia,d,a);else if(d instanceof THREE.Geometry)for(var e=Ub[d.id],h=0,i=e.length;h<i;h++)L(Ia,e[h],a)}else a instanceof THREE.Line||a instanceof THREE.PointCloud?L(Ia,d,a):(a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback)&&M(Ja,a)}function J(a,b){for(var c,d,e=pb.get("OES_element_index_uint")?4294967296:65535,f={},g=a.morphTargets?a.morphTargets.length:0,h=a.morphNormals?a.morphNormals.length:0,i={},j=[],k=0,l=a.faces.length;k<l;k++){var m=a.faces[k],n=b?m.materialIndex:0;n in f||(f[n]={hash:n,counter:0}),c=f[n].hash+"_"+f[n].counter,c in i||(d={id:Vb++,faces3:[],materialIndex:n,vertices:0,numMorphTargets:g,numMorphNormals:h},i[c]=d,j.push(d)),i[c].vertices+3>e&&(f[n].counter+=1,(c=f[n].hash+"_"+f[n].counter)in i||(d={id:Vb++,faces3:[],materialIndex:n,vertices:0,numMorphTargets:g,numMorphNormals:h},i[c]=d,j.push(d))),i[c].faces3.push(k),i[c].vertices+=3}return j}function K(a,b){var c=a.material,e=!1;void 0!==Ub[b.id]&&!0!==b.groupsNeedUpdate||(delete Ia[a.id],Ub[b.id]=J(b,c instanceof THREE.MeshFaceMaterial),b.groupsNeedUpdate=!1);for(var f=Ub[b.id],g=0,i=f.length;g<i;g++){var j=f[g];void 0===j.__webglVertexBuffer?(d(j),h(j,a),b.verticesNeedUpdate=!0,b.morphTargetsNeedUpdate=!0,b.elementsNeedUpdate=!0,b.uvsNeedUpdate=!0,b.normalsNeedUpdate=!0,b.tangentsNeedUpdate=!0,b.colorsNeedUpdate=!0,e=!0):e=!1,(e||void 0===a.__webglActive)&&L(Ia,j,a)}a.__webglActive=!0}function L(a,b,c){var d=c.id;a[d]=a[d]||[],a[d].push({id:d,buffer:b,object:c,material:null,z:0})}function M(a,b){a.push({id:null,object:b,opaque:null,transparent:null,z:0})}function N(a){var b,c,d=a.geometry;if(d instanceof THREE.BufferGeometry)q(d);else if(a instanceof THREE.Mesh){!0===d.groupsNeedUpdate&&K(a,d);for(var e=Ub[d.id],f=0,g=e.length;f<g;f++){var h=e[f];c=i(a,h),b=c.attributes&&O(c),(d.verticesNeedUpdate||d.morphTargetsNeedUpdate||d.elementsNeedUpdate||d.uvsNeedUpdate||d.normalsNeedUpdate||d.colorsNeedUpdate||d.tangentsNeedUpdate||b)&&p(h,a,Oa.DYNAMIC_DRAW,!d.dynamic,c)}d.verticesNeedUpdate=!1,d.morphTargetsNeedUpdate=!1,d.elementsNeedUpdate=!1,d.uvsNeedUpdate=!1,d.normalsNeedUpdate=!1,d.colorsNeedUpdate=!1,d.tangentsNeedUpdate=!1,c.attributes&&P(c)}else a instanceof THREE.Line?(c=i(a,d),b=c.attributes&&O(c),(d.verticesNeedUpdate||d.colorsNeedUpdate||d.lineDistancesNeedUpdate||b)&&n(d,Oa.DYNAMIC_DRAW),d.verticesNeedUpdate=!1,d.colorsNeedUpdate=!1,d.lineDistancesNeedUpdate=!1,c.attributes&&P(c)):a instanceof THREE.PointCloud&&(c=i(a,d),b=c.attributes&&O(c),(d.verticesNeedUpdate||d.colorsNeedUpdate||b)&&o(d,Oa.DYNAMIC_DRAW),d.verticesNeedUpdate=!1,d.colorsNeedUpdate=!1,c.attributes&&P(c))}function O(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;return!1}function P(a){for(var b in a.attributes)a.attributes[b].needsUpdate=!1}function Q(a){a instanceof THREE.Mesh||a instanceof THREE.PointCloud||a instanceof THREE.Line?delete Ia[a.id]:(a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback)&&R(Ja,a),delete a.__webglInit,delete a.__webglActive}function R(a,b){for(var c=a.length-1;c>=0;c--)a[c].object===b&&a.splice(c,1)}function S(a,b){if(b.textureMaps)for(var c=0;c<ge.PrismMaps.length;c++){var d=ge.PrismMaps[c],e=b.textureMaps[d+"_map"];if(e){var f=e.textureObj.properties.booleans;a[d]={S:!f.texture_URepeat.values[0],T:!f.texture_VRepeat.values[0]}}}}function T(a,b,c,d){a.addEventListener("dispose",Kb);var e=Wb[a.type];if(e){var f=THREE.ShaderLib[e];a.__webglShader={uniforms:THREE.UniformsUtils.clone(f.uniforms),vertexShader:f.vertexShader,fragmentShader:f.fragmentShader}}else a.__webglShader={uniforms:a.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader};var g=sa(b),h={precision:va,precisionFragment:wa,supportsVertexTextures:xb,haveTextureLod:!!pb.get("EXT_shader_texture_lod"),map:!!a.map,envMap:!!a.envMap,irradianceMap:!!a.irradianceMap,envIsSpherical:a.envMap&&a.envMap.mapping==THREE.SphericalReflectionMapping,envGammaEncoded:a.envMap&&a.envMap.GammaEncoded,irrGammaEncoded:a.irradianceMap&&a.irradianceMap.GammaEncoded,envRGBM:a.envMap&&a.envMap.RGBM,irrRGBM:a.irradianceMap&&a.irradianceMap.RGBM,lightMap:!!a.lightMap,bumpMap:pb.get("OES_standard_derivatives")&&!!a.bumpMap,normalMap:pb.get("OES_standard_derivatives")&&!!a.normalMap,specularMap:!!a.specularMap,alphaMap:!!a.alphaMap,vertexColors:a.vertexColors,vertexIds:a.vertexIds,useInstancing:a.useInstancing,wideLines:a.wideLines,fog:c,useFog:a.fog,fogExp:c instanceof THREE.FogExp2,sizeAttenuation:a.sizeAttenuation,logarithmicDepthBuffer:Ca,maxDirLights:g.directional,maxPointLights:g.point,maxSpotLights:g.spot,maxHemiLights:g.hemi,alphaTest:a.alphaTest,metal:a.metal,clearcoat:a.clearcoat,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide,mrtNormals:a.mrtNormals,mrtIdBuffer:a.mrtIdBuffer,vertexPrefix:$a,fragmentPrefix:_a,tonemapOutput:a.tonemapOutput,packedNormals:a.packedNormals,hatchPattern:!!a.hatchParams,numCutplanes:a.cutplanes?a.cutplanes.length:0,mapInvert:a.map&&a.map.invert,mapClampS:a.map&&a.map.clampS,mapClampT:a.map&&a.map.clampT,bumpMapClampS:a.bumpMap&&a.bumpMap.clampS,bumpMapClampT:a.bumpMap&&a.bumpMap.clampT,normalMapClampS:a.normalMap&&a.normalMap.clampS,normalMapClampT:a.normalMap&&a.normalMap.clampT,specularMapClampS:a.specularMap&&a.specularMap.clampS,specularMapClampT:a.specularMap&&a.specularMap.clampT,alphaMapInvert:a.alphaMap&&a.alphaMap.invert,alphaMapClampS:a.alphaMap&&a.alphaMap.clampS,alphaMapClampT:a.alphaMap&&a.alphaMap.clampT};a.isPrismMaterial&&(S(h,a),h.isPrism=!0);var i=[];e?i.push(e):(i.push(a.fragmentShader),i.push(a.vertexShader));for(var j in a.defines)i.push(j),i.push(a.defines[j]);var k,l;for(k in h)i.push(k),i.push(h[k]);var m,n=i.join();for(k=0,l=Ta.length;k<l;k++){var o=Ta[k];if(o.code===n){m=o,m.usedTimes++;break}}void 0===m&&(m=new ge.WebGLProgram(Sa,n,a,h),Ta.push(m),Sa.info.memory.programs=Ta.length),a.programs||(a.programs=[]),a.programs[Za]=m,a.uniformsLists||(a.uniformsLists=[]),a.uniformsList=a.uniformsLists[Za]=[];for(var p in a.__webglShader.uniforms){var q=m.uniforms[p];q&&a.uniformsList.push([a.__webglShader.uniforms[p],q])}}function U(a){!0===a.transparent&&ob.setBlending(a.blending,a.blendEquation,a.blendSrc,a.blendDst,a.blendEquationAlpha,a.blendSrcAlpha,a.blendDstAlpha),ob.setDepthTest(a.depthTest),ob.setDepthWrite(a.depthWrite),ob.setPolygonOffset(a.polygonOffset,a.polygonOffsetFactor,a.polygonOffsetUnits)}function V(a,b,c,d,e){ab=0,d.needsUpdate?(d.program&&Pb(d),T(d,b,c,e),d.needsUpdate=!1):d.programs[Za]||T(d,b,c,e);var f=!1,g=!1,h=!1;d.uniformsList=d.uniformsLists[Za];var i=d.program=d.programs[Za],j=i.uniforms,k=d.__webglShader.uniforms;if(i.id!==Ua&&(Oa.useProgram(i.program),Ua=i.id,f=!0,g=!0,h=!0),d.id!==Wa&&(-1===Wa&&(h=!0),Wa=d.id,g=!0),(f||a!==Xa)&&(Oa.uniformMatrix4fv(j.projectionMatrix,!1,a.projectionMatrix.elements),Ca&&Oa.uniform1f(j.logDepthBufFC,2/(Math.log(a.far+1)/Math.LN2)),a!==Xa&&(Xa=a),(d instanceof THREE.ShaderMaterial||d instanceof THREE.MeshPhongMaterial||d.isPrismMaterial||d.envMap)&&null!==j.cameraPosition&&(jb.setFromMatrixPosition(a.matrixWorld),Oa.uniform3f(j.cameraPosition,jb.x,jb.y,jb.z)),(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.ShaderMaterial||d.isPrismMaterial||d.skinning)&&(null!==j.viewMatrix&&Oa.uniformMatrix4fv(j.viewMatrix,!1,a.matrixWorldInverse.elements),null!==j.viewMatrixInverse&&Oa.uniformMatrix4fv(j.viewMatrixInverse,!1,ib.elements),j.mvpMatrix&&Oa.uniformMatrix4fv(j.mvpMatrix,!1,hb.elements),h?(_(k,d),aa(k,!0)):aa(k,!1))),g){c&&d.fog&&$(k,c),(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d.isPrismMaterial||d.lights)&&(lb&&(h=!0,ka(b),lb=!1),h?(ea(k,mb),fa(k,!0)):fa(k,!1)),(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial)&&(W(k,d),_(k,d)),d instanceof THREE.PointCloudMaterial?X(k,d):d instanceof THREE.LineBasicMaterial?Y(k,d):d instanceof THREE.LineDashedMaterial?(Y(k,d),Z(k,d)):d instanceof THREE.MeshPhongMaterial?ba(k,d):d instanceof THREE.MeshLambertMaterial?da(k,d):d instanceof THREE.MeshDepthMaterial?(k.mNear.value=a.near,k.mFar.value=a.far,k.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial?k.opacity.value=d.opacity:d.isPrismMaterial&&(ca(k,d),_(k,d)),d.wideLines&&(k.view_size.value=new THREE.Vector2(window.innerWidth,window.innerHeight)),we.ShadowRender&&d.shadowMap&&we.ShadowRender.RefreshUniformsShadow(k,d);var l=k.cutplanes;d.cutplanes&&d.cutplanes.length>0&&l&&(l.value=d.cutplanes,l._array&&l._array.length!=4*d.cutplanes&&(l._array=void 0)),d.hatchParams&&k.hatchParams&&(k.hatchParams.value.copy(d.hatchParams),k.hatchTintColor.value.copy(d.hatchTintColor),k.hatchTintIntensity.value=d.hatchTintIntensity),ia(d.uniformsList)}ga(j,e,a),null!==j.modelMatrix&&Oa.uniformMatrix4fv(j.modelMatrix,!1,e.matrixWorld.elements);var m;if(j.modelId){j.dbId&&(m=e.dbId||e.fragId||0,Oa.uniform3f(j.dbId,(255&m)/255,(m>>8&255)/255,(m>>16&255)/255));var n=e.modelId;Oa.uniform3f(j.modelId,(255&n)/255,(n>>8&255)/255,(m>>24&255)/255)}else null!==j.dbId&&(m=!Da&&e.dbId||e.fragId||0,Oa.uniform3f(j.dbId,(255&m)/255,(m>>8&255)/255,(m>>16&255)/255));if(j.themingColor){var o=e.themingColor;o instanceof THREE.Vector4?Oa.uniform4f(j.themingColor,o.x,o.y,o.z,o.w):Oa.uniform4f(j.themingColor,0,0,0,0)}return i}function W(a,b){function c(a,b,c){var d=c.offset,e=c.repeat;if(b){var f=b.value;c.matrix?f.copy(c.matrix):f.identity(),f.elements[6]+=d.x,f.elements[7]+=d.y,f.elements[0]*=e.x,f.elements[3]*=e.x,f.elements[1]*=e.y,f.elements[4]*=e.y}else a.offsetRepeat.value.set(d.x,d.y,e.x,e.y)}a.opacity.value=b.opacity,a.diffuse.value.copy(b.color),a.map.value=b.map,a.lightMap.value=b.lightMap,a.specularMap.value=b.specularMap,a.alphaMap.value=b.alphaMap,b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale),b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale)),b.alphaMap&&c(a,a.texMatrixAlpha,b.alphaMap);var d;b.normalMap?d=b.normalMap:b.bumpMap&&(d=b.bumpMap),void 0!==d&&c(a,a.texMatrixBump,d);var e;b.map?e=b.map:b.specularMap&&(e=b.specularMap),void 0!==e&&c(a,a.texMatrix,e),a.envMap.value=b.envMap,a.irradianceMap&&(a.irradianceMap.value=b.irradianceMap),a.reflectivity.value=b.reflectivity,a.refractionRatio.value=b.refractionRatio}function X(a,b){Y(a,b),a.point_size.value=b.size}function Y(a,b){a.diffuse.value=b.color,a.opacity.value=b.opacity}function Z(a,b){a.dashSize.value=b.dashSize,a.totalSize.value=b.dashSize+b.gapSize,a.scale.value=b.scale}function $(a,b){a.fogColor.value=b.color,b instanceof THREE.Fog?(a.fogNear.value=b.near,a.fogFar.value=b.far):b instanceof THREE.FogExp2&&(a.fogDensity.value=b.density)}function _(a,b){a.envMap&&(a.envMap.value=b.envMap),a.irradianceMap&&(a.irradianceMap.value=b.irradianceMap),a.envMapExposure&&(a.envMapExposure.value=b.envMapExposure),a.envRotationSin&&a.envRotationCos&&(a.envRotationSin.value=b.envRotationSin,a.envRotationCos.value=b.envRotationCos)}function aa(a,b){a.envMap&&(a.envMap.needsUpdate=b),a.irradianceMap&&(a.irradianceMap.needsUpdate=b),a.envMapExposure&&(a.envMapExposure.needsUpdate=b)}function ba(a,b){if(a.shininess.value=b.shininess,a.reflMipIndex){var c=Math.log(Math.max(1+1e-10,b.shininess));a.reflMipIndex.value=Math.max(0,-.72134752*c+5.5)}a.emissive&&a.emissive.value.copy(b.emissive),a.specular.value.copy(b.specular),a.exposureBias&&(a.exposureBias.value=b.exposureBias)}function ca(a,b){function c(a,b,c){a[c].value=b[c],null!=b[c]&&(a[c+"_texMatrix"].value=(new THREE.Matrix3).copy(b[c].matrix),a[c+"_invert"].value=b[c].invert)}function d(a,b,c){a[c].value=b[c],null!=b[c]&&(a[c+"_texMatrix"].value=(new THREE.Matrix3).copy(b[c].matrix),a[c+"_bumpScale"].value=(new THREE.Vector2).copy(b[c].bumpScale),a[c+"_bumpmapType"].value=b[c].bumpmapType)}switch(a.exposureBias.value=b.exposureBias,a.surface_albedo.value=(new THREE.Color).copy(b.surface_albedo),a.surface_roughness.value=b.surface_roughness,a.surface_anisotropy.value=b.surface_anisotropy,a.surface_rotation.value=b.surface_rotation,c(a,b,"surface_albedo_map"),c(a,b,"surface_roughness_map"),c(a,b,"surface_cutout_map"),c(a,b,"surface_anisotropy_map"),c(a,b,"surface_rotation_map"),d(a,b,"surface_normal_map"),b.prismType){case"PrismOpaque":a.opaque_albedo.value=(new THREE.Color).copy(b.opaque_albedo),a.opaque_luminance_modifier.value=(new THREE.Color).copy(b.opaque_luminance_modifier),a.opaque_f0.value=b.opaque_f0,a.opaque_luminance.value=b.opaque_luminance,c(a,b,"opaque_albedo_map"),c(a,b,"opaque_luminance_modifier_map"),c(a,b,"opaque_f0_map");break;case"PrismMetal":a.metal_f0.value=(new THREE.Color).copy(b.metal_f0),c(a,b,"metal_f0_map");break;case"PrismLayered":a.layered_f0.value=b.layered_f0,a.layered_diffuse.value=(new THREE.Color).copy(b.layered_diffuse),a.layered_fraction.value=b.layered_fraction,a.layered_bottom_f0.value=(new THREE.Color).copy(b.layered_bottom_f0),a.layered_roughness.value=b.layered_roughness,a.layered_anisotropy.value=b.layered_anisotropy,a.layered_rotation.value=b.layered_rotation,c(a,b,"layered_bottom_f0_map"),c(a,b,"layered_f0_map"),c(a,b,"layered_diffuse_map"),c(a,b,"layered_fraction_map"),c(a,b,"layered_roughness_map"),c(a,b,"layered_anisotropy_map"),c(a,b,"layered_rotation_map"),d(a,b,"layered_normal_map");break;case"PrismTransparent":a.transparent_color.value=(new THREE.Color).copy(b.transparent_color),a.transparent_distance.value=b.transparent_distance,a.transparent_ior.value=b.transparent_ior;break;case"PrismWood":a.wood_fiber_cosine_enable.value=b.wood_fiber_cosine_enable,a.wood_fiber_cosine_bands.value=b.wood_fiber_cosine_bands,a.wood_fiber_cosine_weights.value=(new THREE.Vector4).copy(b.wood_fiber_cosine_weights),a.wood_fiber_cosine_frequencies.value=(new THREE.Vector4).copy(b.wood_fiber_cosine_frequencies),a.wood_fiber_perlin_enable.value=b.wood_fiber_perlin_enable,a.wood_fiber_perlin_bands.value=b.wood_fiber_perlin_bands,a.wood_fiber_perlin_weights.value=(new THREE.Vector4).copy(b.wood_fiber_perlin_weights),a.wood_fiber_perlin_frequencies.value=(new THREE.Vector4).copy(b.wood_fiber_perlin_frequencies),a.wood_fiber_perlin_scale_z.value=b.wood_fiber_perlin_scale_z,a.wood_growth_perlin_enable.value=b.wood_growth_perlin_enable,a.wood_growth_perlin_bands.value=b.wood_growth_perlin_bands,a.wood_growth_perlin_weights.value=(new THREE.Vector4).copy(b.wood_growth_perlin_weights),a.wood_growth_perlin_frequencies.value=(new THREE.Vector4).copy(b.wood_growth_perlin_frequencies),a.wood_latewood_ratio.value=b.wood_latewood_ratio,a.wood_earlywood_sharpness.value=b.wood_earlywood_sharpness,a.wood_latewood_sharpness.value=b.wood_latewood_sharpness,a.wood_ring_thickness.value=b.wood_ring_thickness,a.wood_earlycolor_perlin_enable.value=b.wood_earlycolor_perlin_enable,a.wood_earlycolor_perlin_bands.value=b.wood_earlycolor_perlin_bands,a.wood_earlycolor_perlin_weights.value=(new THREE.Vector4).copy(b.wood_earlycolor_perlin_weights),a.wood_earlycolor_perlin_frequencies.value=(new THREE.Vector4).copy(b.wood_earlycolor_perlin_frequencies),a.wood_early_color.value=(new THREE.Color).copy(b.wood_early_color),a.wood_use_manual_late_color.value=b.wood_use_manual_late_color,a.wood_manual_late_color.value=(new THREE.Color).copy(b.wood_manual_late_color),a.wood_latecolor_perlin_enable.value=b.wood_latecolor_perlin_enable,a.wood_latecolor_perlin_bands.value=b.wood_latecolor_perlin_bands,a.wood_latecolor_perlin_weights.value=(new THREE.Vector4).copy(b.wood_latecolor_perlin_weights),a.wood_latecolor_perlin_frequencies.value=(new THREE.Vector4).copy(b.wood_latecolor_perlin_frequencies),a.wood_late_color_power.value=b.wood_late_color_power,a.wood_diffuse_perlin_enable.value=b.wood_diffuse_perlin_enable,a.wood_diffuse_perlin_bands.value=b.wood_diffuse_perlin_bands,a.wood_diffuse_perlin_weights.value=(new THREE.Vector4).copy(b.wood_diffuse_perlin_weights),a.wood_diffuse_perlin_frequencies.value=(new THREE.Vector4).copy(b.wood_diffuse_perlin_frequencies),a.wood_diffuse_perlin_scale_z.value=b.wood_diffuse_perlin_scale_z,a.wood_use_pores.value=b.wood_use_pores,a.wood_pore_type.value=b.wood_pore_type,a.wood_pore_radius.value=b.wood_pore_radius,a.wood_pore_cell_dim.value=b.wood_pore_cell_dim,a.wood_pore_color_power.value=b.wood_pore_color_power,a.wood_pore_depth.value=b.wood_pore_depth,a.wood_use_rays.value=b.wood_use_rays,a.wood_ray_color_power.value=b.wood_ray_color_power,a.wood_ray_seg_length_z.value=b.wood_ray_seg_length_z,a.wood_ray_num_slices.value=b.wood_ray_num_slices,a.wood_ray_ellipse_z2x.value=b.wood_ray_ellipse_z2x,a.wood_ray_ellipse_radius_x.value=b.wood_ray_ellipse_radius_x,a.wood_use_latewood_bump.value=b.wood_use_latewood_bump,a.wood_latewood_bump_depth.value=b.wood_latewood_bump_depth,a.wood_use_groove_roughness.value=b.wood_use_groove_roughness,a.wood_groove_roughness.value=b.wood_groove_roughness,a.wood_diffuse_lobe_weight.value=b.wood_diffuse_lobe_weight,c(a,b,"wood_curly_distortion_map"),null!=a.wood_curly_distortion_map.value&&(a.wood_curly_distortion_map.value.minFilter=THREE.NearestFilter,a.wood_curly_distortion_map.value.magFilter=THREE.NearestFilter,a.wood_curly_distortion_enable.value=b.wood_curly_distortion_enable,a.wood_curly_distortion_scale.value=b.wood_curly_distortion_scale);var e=1-b.wood_latewood_ratio,f=b.wood_earlywood_sharpness*e,g=b.wood_latewood_sharpness*b.wood_latewood_ratio,h=e+g;a.wood_ring_fraction.value=new THREE.Vector4(e,f,g,h),a.wood_fall_rise.value=new THREE.Vector2(e-f,b.wood_latewood_ratio-g);break;default:THREE.warn("Unknown prism type: "+b.prismType)}a.envExponentMin.value=b.envExponentMin,a.envExponentMax.value=b.envExponentMax,a.envExponentCount.value=b.envExponentCount}function da(a,b){a.emissive.value.copy(b.emissive),b.wrapAround&&a.wrapRGB.value.copy(b.wrapRGB)}function ea(a,b){a.ambientLightColor.value=b.ambient,a.directionalLightColor.value=b.directional.colors,a.directionalLightDirection.value=b.directional.positions,a.pointLightColor.value=b.point.colors,a.pointLightPosition.value=b.point.positions,a.pointLightDistance.value=b.point.distances,a.spotLightColor.value=b.spot.colors,a.spotLightPosition.value=b.spot.positions,a.spotLightDistance.value=b.spot.distances,a.spotLightDirection.value=b.spot.directions,a.spotLightAngleCos.value=b.spot.anglesCos,a.spotLightExponent.value=b.spot.exponents,a.hemisphereLightSkyColor.value=b.hemi.skyColors,a.hemisphereLightGroundColor.value=b.hemi.groundColors,a.hemisphereLightDirection.value=b.hemi.positions}function fa(a,b){a.ambientLightColor.needsUpdate=b,a.directionalLightColor.needsUpdate=b,a.directionalLightDirection.needsUpdate=b,a.pointLightColor.needsUpdate=b,a.pointLightPosition.needsUpdate=b,a.pointLightDistance.needsUpdate=b,a.spotLightColor.needsUpdate=b,a.spotLightPosition.needsUpdate=b,a.spotLightDistance.needsUpdate=b,a.spotLightDirection.needsUpdate=b,a.spotLightAngleCos.needsUpdate=b,a.spotLightExponent.needsUpdate=b,a.hemisphereLightSkyColor.needsUpdate=b,a.hemisphereLightGroundColor.needsUpdate=b,a.hemisphereLightDirection.needsUpdate=b}function ga(a,b,c){Ka.multiplyMatrices(c.matrixWorldInverse,b.matrixWorld),Oa.uniformMatrix4fv(a.modelViewMatrix,!1,Ka.elements),a.normalMatrix&&(La.getNormalMatrix(Ka),Oa.uniformMatrix3fv(a.normalMatrix,!1,La.elements))}function ha(){var a=ab;return a>=tb&&THREE.warn("WebGLRenderer: trying to use "+a+" texture units while this GPU supports only "+tb),ab+=1,a}function ia(a){for(var b,c,d,e=0,f=a.length;e<f;e++){var g=a[e][0];if(!1!==g.needsUpdate){var h,i,j=g.type,k=g.value,l=a[e][1];switch(j){case"1i":Oa.uniform1i(l,k);break;case"1f":Oa.uniform1f(l,k);break;case"2f":Oa.uniform2f(l,k[0],k[1]);break;case"3f":Oa.uniform3f(l,k[0],k[1],k[2]);break;case"4f":Oa.uniform4f(l,k[0],k[1],k[2],k[3]);break;case"1iv":Oa.uniform1iv(l,k);break;case"3iv":Oa.uniform3iv(l,k);break;case"1fv":Oa.uniform1fv(l,k);break;case"2fv":Oa.uniform2fv(l,k);break;case"3fv":Oa.uniform3fv(l,k);break;case"4fv":Oa.uniform4fv(l,k);break;case"Matrix3fv":Oa.uniformMatrix3fv(l,!1,k);break;case"Matrix4fv":Oa.uniformMatrix4fv(l,!1,k);break;case"i":Oa.uniform1i(l,k);break;case"f":Oa.uniform1f(l,k);break;case"v2":Oa.uniform2f(l,k.x,k.y);break;case"v3":Oa.uniform3f(l,k.x,k.y,k.z);break;case"v4":Oa.uniform4f(l,k.x,k.y,k.z,k.w);break;case"c":Oa.uniform3f(l,k.r,k.g,k.b);break;case"iv1":Oa.uniform1iv(l,k);break;case"iv":Oa.uniform3iv(l,k);break;case"fv1":Oa.uniform1fv(l,k);break;case"fv":Oa.uniform3fv(l,k);break;case"v2v":for(void 0===g._array&&(g._array=new Float32Array(2*k.length)),h=0,i=k.length;h<i;h++)d=2*h,g._array[d]=k[h].x,g._array[d+1]=k[h].y;Oa.uniform2fv(l,g._array);break;case"v3v":for(void 0===g._array&&(g._array=new Float32Array(3*k.length)),h=0,i=k.length;h<i;h++)d=3*h,g._array[d]=k[h].x,g._array[d+1]=k[h].y,g._array[d+2]=k[h].z;Oa.uniform3fv(l,g._array);break;case"v4v":for(void 0===g._array&&(g._array=new Float32Array(4*k.length)),h=0,i=k.length;h<i;h++)d=4*h,g._array[d]=k[h].x,g._array[d+1]=k[h].y,g._array[d+2]=k[h].z,g._array[d+3]=k[h].w;Oa.uniform4fv(l,g._array);break;case"m3":Oa.uniformMatrix3fv(l,!1,k.elements);break;case"m3v":for(void 0===g._array&&(g._array=new Float32Array(9*k.length)),h=0,i=k.length;h<i;h++)k[h].flattenToArrayOffset(g._array,9*h);Oa.uniformMatrix3fv(l,!1,g._array);break;case"m4":Oa.uniformMatrix4fv(l,!1,k.elements);break;case"m4v":for(void 0===g._array&&(g._array=new Float32Array(16*k.length)),h=0,i=k.length;h<i;h++)k[h].flattenToArrayOffset(g._array,16*h);Oa.uniformMatrix4fv(l,!1,g._array);break;case"t":if(b=k,c=ha(),Oa.uniform1i(l,c),!b)continue;Array.isArray(b.image)&&6===b.image.length||b instanceof THREE.CubeTexture?b.needsUpdate?na(b,c):(Oa.activeTexture(Oa.TEXTURE0+c),Oa.bindTexture(Oa.TEXTURE_CUBE_MAP,b.__webglTextureCube)):b instanceof THREE.WebGLRenderTargetCube?oa(b,c):Sa.setTexture(b,c);break;case"tv":for(void 0===g._array&&(g._array=[]),h=0,i=g.value.length;h<i;h++)g._array[h]=ha();for(Oa.uniform1iv(l,g._array),h=0,i=g.value.length;h<i;h++)b=g.value[h],c=g._array[h],b&&Sa.setTexture(b,c);break;default:THREE.warn("THREE.WebGLRenderer: Unknown uniform type: "+j)}}}}function ja(a,b,c,d){a[b]=c.r*d,a[b+1]=c.g*d,a[b+2]=c.b*d}function ka(a){var b,c,d,e,f,g,h,i,j=0,k=0,l=0,m=mb,n=m.directional.colors,o=m.directional.positions,p=m.point.colors,q=m.point.positions,r=m.point.distances,s=m.spot.colors,t=m.spot.positions,u=m.spot.distances,v=m.spot.directions,w=m.spot.anglesCos,x=m.spot.exponents,y=m.hemi.skyColors,z=m.hemi.groundColors,A=m.hemi.positions,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0;for(b=0,c=a.length;b<c;b++)if(d=a[b],!d.onlyShadow)if(e=d.color,h=d.intensity,i=d.distance,d instanceof THREE.AmbientLight){if(!d.visible)continue;j+=e.r,k+=e.g,l+=e.b}else if(d instanceof THREE.DirectionalLight){if(F+=1,!d.visible)continue;kb.setFromMatrixPosition(d.matrixWorld),jb.setFromMatrixPosition(d.target.matrixWorld),kb.sub(jb),kb.normalize(),J=3*B,o[J]=kb.x,o[J+1]=kb.y,o[J+2]=kb.z,ja(n,J,e,h),B+=1}else if(d instanceof THREE.PointLight){if(G+=1,!d.visible)continue;K=3*C,ja(p,K,e,h),jb.setFromMatrixPosition(d.matrixWorld),q[K]=jb.x,q[K+1]=jb.y,q[K+2]=jb.z,r[C]=i,C+=1}else if(d instanceof THREE.SpotLight){if(H+=1,!d.visible)continue;L=3*D,ja(s,L,e,h),jb.setFromMatrixPosition(d.matrixWorld),t[L]=jb.x,t[L+1]=jb.y,t[L+2]=jb.z,u[D]=i,kb.copy(jb),jb.setFromMatrixPosition(d.target.matrixWorld),kb.sub(jb),kb.normalize(),v[L]=kb.x,v[L+1]=kb.y,v[L+2]=kb.z,w[D]=Math.cos(d.angle),x[D]=d.exponent,D+=1}else if(d instanceof THREE.HemisphereLight){if(I+=1,!d.visible)continue;kb.setFromMatrixPosition(d.matrixWorld),kb.normalize(),M=3*E,A[M]=kb.x,A[M+1]=kb.y,A[M+2]=kb.z,f=d.color,g=d.groundColor,ja(y,M,f,h),ja(z,M,g,h),E+=1}for(b=3*B,c=Math.max(n.length,3*F);b<c;b++)n[b]=0;for(b=3*C,c=Math.max(p.length,3*G);b<c;b++)p[b]=0;for(b=3*D,c=Math.max(s.length,3*H);b<c;b++)s[b]=0;for(b=3*E,c=Math.max(y.length,3*I);b<c;b++)y[b]=0;for(b=3*E,c=Math.max(z.length,3*I);b<c;b++)z[b]=0;m.directional.length=B,m.point.length=C,m.spot.length=D,m.hemi.length=E,m.ambient[0]=j,m.ambient[1]=k,m.ambient[2]=l}function la(a,b,c){var d;c?(Oa.texParameteri(a,Oa.TEXTURE_WRAP_S,ra(b.wrapS)),Oa.texParameteri(a,Oa.TEXTURE_WRAP_T,ra(b.wrapT)),Oa.texParameteri(a,Oa.TEXTURE_MAG_FILTER,ra(b.magFilter)),Oa.texParameteri(a,Oa.TEXTURE_MIN_FILTER,ra(b.minFilter))):(Oa.texParameteri(a,Oa.TEXTURE_WRAP_S,Oa.CLAMP_TO_EDGE),Oa.texParameteri(a,Oa.TEXTURE_WRAP_T,Oa.CLAMP_TO_EDGE),b.wrapS===THREE.ClampToEdgeWrapping&&b.wrapT===THREE.ClampToEdgeWrapping||THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( "+b.sourceFile+" )"),Oa.texParameteri(a,Oa.TEXTURE_MAG_FILTER,qa(b.magFilter)),Oa.texParameteri(a,Oa.TEXTURE_MIN_FILTER,qa(b.minFilter)),b.minFilter!==THREE.NearestFilter&&b.minFilter!==THREE.LinearFilter&&THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( "+b.sourceFile+" )")),(d=pb.get("EXT_texture_filter_anisotropic"))&&b.type!==THREE.FloatType&&b.type!==THREE.HalfFloatType&&(b.anisotropy>1||b.__oldAnisotropy)&&(Oa.texParameterf(a,d.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Sa.getMaxAnisotropy())),b.__oldAnisotropy=b.anisotropy)}function ma(a,b){if(a.width<=b&&a.height<=b)return a;var c=Math.max(a.width,a.height),d=Math.floor(a.width*b/c),e=Math.floor(a.height*b/c),f=document.createElement("canvas");return f.width=d,f.height=e,f.getContext("2d").drawImage(a,0,0,a.width,a.height,0,0,d,e),f}function na(a,b){if(6===a.image.length)if(a.needsUpdate){a.__webglTextureCube||(a.addEventListener("dispose",Ib),a.__webglTextureCube=Oa.createTexture(),Sa.info.memory.textures++),Oa.activeTexture(Oa.TEXTURE0+b),Oa.bindTexture(Oa.TEXTURE_CUBE_MAP,a.__webglTextureCube),Oa.pixelStorei(Oa.UNPACK_FLIP_Y_WEBGL,a.flipY);var c,d=a instanceof THREE.CompressedTexture,e=a.image[0]instanceof THREE.DataTexture,f=[];for(c=0;c<6;c++)!Sa.autoScaleCubemaps||d||e?f[c]=e?a.image[c].image:a.image[c]:f[c]=ma(a.image[c],wb);var g=f[0],h=THREE.Math.isPowerOfTwo(g.width)&&THREE.Math.isPowerOfTwo(g.height),i=ra(a.format),j=ra(a.type);for(la(Oa.TEXTURE_CUBE_MAP,a,h),c=0;c<6;c++)if(d)for(var k,l=f[c].mipmaps,m=0,n=l.length;m<n;m++)k=l[m],a.format!==THREE.RGBAFormat&&a.format!==THREE.RGBFormat?Cb().indexOf(i)>-1?Oa.compressedTexImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X+c,m,i,k.width,k.height,0,k.data):THREE.warn("Attempt to load unsupported compressed texture format"):Oa.texImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X+c,m,i,k.width,k.height,0,i,j,k.data);else e?Oa.texImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X+c,0,i,f[c].width,f[c].height,0,i,j,f[c].data):Oa.texImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X+c,0,i,i,j,f[c]);a.generateMipmaps&&h&&Oa.generateMipmap(Oa.TEXTURE_CUBE_MAP),a.needsUpdate=!1,a.onUpdate&&a.onUpdate()}else Oa.activeTexture(Oa.TEXTURE0+b),Oa.bindTexture(Oa.TEXTURE_CUBE_MAP,a.__webglTextureCube)}function oa(a,b){Oa.activeTexture(Oa.TEXTURE0+b),Oa.bindTexture(Oa.TEXTURE_CUBE_MAP,a.__webglTexture)}function pa(a){Oa.bindTexture(Oa.TEXTURE_2D,a.__webglTexture),Oa.generateMipmap(Oa.TEXTURE_2D),Oa.bindTexture(Oa.TEXTURE_2D,null)}function qa(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?Oa.NEAREST:Oa.LINEAR}function ra(a){var b;if(a===THREE.RepeatWrapping)return Oa.REPEAT;if(a===THREE.ClampToEdgeWrapping)return Oa.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return Oa.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return Oa.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return Oa.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return Oa.NEAREST_MIPMAP_LINEAR;if(a===THREE.LinearFilter)return Oa.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return Oa.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return Oa.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return Oa.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return Oa.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return Oa.UNSIGNED_SHORT_5_5_5_1;if(a===THREE.UnsignedShort565Type)return Oa.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return Oa.BYTE;if(a===THREE.ShortType)return Oa.SHORT;if(a===THREE.UnsignedShortType)return Oa.UNSIGNED_SHORT;if(a===THREE.IntType)return Oa.INT;if(a===THREE.UnsignedIntType)return Oa.UNSIGNED_INT;if(a===THREE.FloatType)return Oa.FLOAT;if(a===THREE.HalfFloatType)return 36193;if(a===THREE.AlphaFormat)return Oa.ALPHA;if(a===THREE.RGBFormat)return Oa.RGB;if(a===THREE.RGBAFormat)return Oa.RGBA;if(a===THREE.LuminanceFormat)return Oa.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return Oa.LUMINANCE_ALPHA;if(a===THREE.AddEquation)return Oa.FUNC_ADD;if(a===THREE.SubtractEquation)return Oa.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return Oa.FUNC_REVERSE_SUBTRACT;if(a===THREE.ZeroFactor)return Oa.ZERO;if(a===THREE.OneFactor)return Oa.ONE;if(a===THREE.SrcColorFactor)return Oa.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return Oa.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return Oa.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return Oa.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return Oa.DST_ALPHA;if(a===THREE.OneMinusDstAlphaFactor)return Oa.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return Oa.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return Oa.ONE_MINUS_DST_COLOR;if(a===THREE.SrcAlphaSaturateFactor)return Oa.SRC_ALPHA_SATURATE;if(null!==(b=pb.get("WEBGL_compressed_texture_s3tc"))){if(a===THREE.RGB_S3TC_DXT1_Format)return b.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return b.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(null!==(b=pb.get("WEBGL_compressed_texture_pvrtc"))){if(a===THREE.RGB_PVRTC_4BPPV1_Format)return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(a===THREE.RGB_PVRTC_2BPPV1_Format)return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(a===THREE.RGBA_PVRTC_4BPPV1_Format)return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(a===THREE.RGBA_PVRTC_2BPPV1_Format)return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(null!==(b=pb.get("EXT_blend_minmax"))){if(a===THREE.MinEquation)return b.MIN_EXT;if(a===THREE.MaxEquation)return b.MAX_EXT}return 0}function sa(a){
for(var b=0,c=0,d=0,e=0,f=0,g=a.length;f<g;f++){var h=a[f];h.onlyShadow||(h instanceof THREE.DirectionalLight&&b++,h instanceof THREE.PointLight&&c++,h instanceof THREE.SpotLight&&d++,h instanceof THREE.HemisphereLight&&e++)}return{directional:b,point:c,spot:d,hemi:e}}THREE.log("THREE.WebGLRenderer",THREE.REVISION),a=a||{};var ta=void 0!==a.canvas?a.canvas:document.createElement("canvas"),ua=window.devicePixelRatio||1,va=void 0!==a.precision?a.precision:"highp",wa=va,xa=void 0!==a.alpha&&a.alpha,ya=void 0===a.premultipliedAlpha||a.premultipliedAlpha,za=void 0!==a.antialias&&a.antialias,Aa=void 0===a.stencil||a.stencil,Ba=void 0===a.preserveDrawingBuffer||a.preserveDrawingBuffer,Ca=void 0!==a.logarithmicDepthBuffer&&a.logarithmicDepthBuffer,Da=!1,Ea=new THREE.Color(0),Fa=0,Ga=-1!=window.navigator.userAgent.indexOf("Firefox")&&-1!=window.navigator.userAgent.indexOf("Mac OS"),Ha=[],Ia={},Ja=[],Ka=new THREE.Matrix4,La=new THREE.Matrix3,Ma=[],Na=[];this.domElement=ta,this.context=null,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.gammaInput=!1,this.gammaOutput=!1,this.maxMorphTargets=8,this.maxMorphNormals=4,this.autoScaleCubemaps=!0,this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,faces:0,points:0}};var Oa,Pa,Qa,Ra,Sa=this,Ta=[],Ua=null,Va=null,Wa=-1,Xa=null,Ya="",Za=0,$a="",_a="",ab=0,bb=0,cb=0,db=ta.width,eb=ta.height,fb={},gb=new THREE.Frustum,hb=new THREE.Matrix4,ib=new THREE.Matrix4,jb=new THREE.Vector3,kb=new THREE.Vector3,lb=!0,mb={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],anglesCos:[],exponents:[]},hemi:{length:0,skyColors:[],groundColors:[],positions:[]}};try{var nb={alpha:xa,premultipliedAlpha:ya,antialias:za,stencil:Aa,preserveDrawingBuffer:Ba};if(null===(Oa=ta.getContext("webgl",nb)||ta.getContext("experimental-webgl",nb)))throw null!==ta.getContext("webgl")?"Error creating WebGL context with your selected attributes.":"Error creating WebGL context.";0==Oa.getShaderPrecisionFormat(Oa.FRAGMENT_SHADER,Oa.HIGH_FLOAT).precision&&(wa="mediump"),Oa=Cc(Oa),ta.addEventListener("webglcontextlost",function(a){a.preventDefault(),sb(),rb(),Ia={}},!1)}catch(a){return void THREE.error(a)}var ob=new THREE.WebGLState(Oa,ra);void 0===Oa.getShaderPrecisionFormat&&(Oa.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}});var pb=new THREE.WebGLExtensions(Oa);pb.get("OES_texture_float"),pb.get("OES_texture_float_linear"),pb.get("OES_texture_half_float"),pb.get("OES_texture_half_float_linear"),pb.get("OES_standard_derivatives"),pb.get("EXT_shader_texture_lod"),pb.get("EXT_texture_filter_anisotropic"),pb.get("WEBGL_compressed_texture_s3tc"),Pa=pb.get("WEBGL_draw_buffers"),Qa=pb.get("ANGLE_instanced_arrays"),Ra=pb.get("OES_vertex_array_object"),Ca&&pb.get("EXT_frag_depth");var qb=function(a,b,c,d){!0===ya&&(a*=d,b*=d,c*=d),Oa.clearColor(a,b,c,d)},rb=function(){Oa.clearColor(0,0,0,1),Oa.clearDepth(1),Oa.clearStencil(0),Oa.enable(Oa.DEPTH_TEST),Oa.depthFunc(Oa.LEQUAL),Oa.frontFace(Oa.CCW),Oa.cullFace(Oa.BACK),Oa.enable(Oa.CULL_FACE),Oa.enable(Oa.BLEND),Oa.blendEquation(Oa.FUNC_ADD),Oa.blendFunc(Oa.SRC_ALPHA,Oa.ONE_MINUS_SRC_ALPHA),Oa.viewport(bb,cb,db,eb),qb(Ea.r,Ea.g,Ea.b,Fa)},sb=function(){Ua=null,Xa=null,Ya="",Wa=-1,lb=!0,ob.reset(),ob.disableUnusedAttributes()};rb(),this.context=Oa,this.state=ob;var tb=Oa.getParameter(Oa.MAX_TEXTURE_IMAGE_UNITS),ub=Oa.getParameter(Oa.MAX_VERTEX_TEXTURE_IMAGE_UNITS),vb=Oa.getParameter(Oa.MAX_TEXTURE_SIZE),wb=Oa.getParameter(Oa.MAX_CUBE_MAP_TEXTURE_SIZE),xb=ub>0,yb=Oa.getShaderPrecisionFormat(Oa.VERTEX_SHADER,Oa.HIGH_FLOAT),zb=Oa.getShaderPrecisionFormat(Oa.VERTEX_SHADER,Oa.MEDIUM_FLOAT),Ab=Oa.getShaderPrecisionFormat(Oa.FRAGMENT_SHADER,Oa.HIGH_FLOAT),Bb=Oa.getShaderPrecisionFormat(Oa.FRAGMENT_SHADER,Oa.MEDIUM_FLOAT),Cb=function(){var a;return function(){if(void 0!==a)return a;if(a=[],pb.get("WEBGL_compressed_texture_pvrtc")||pb.get("WEBGL_compressed_texture_s3tc"))for(var b=Oa.getParameter(Oa.COMPRESSED_TEXTURE_FORMATS),c=0;c<b.length;c++)a.push(b[c]);return a}}(),Db=yb.precision>0,Eb=zb.precision>0;"highp"!==va||Db||(Eb?(va="mediump",THREE.warn("WebGLRenderer: highp not supported, using mediump")):(va="lowp",THREE.warn("WebGLRenderer: highp and mediump not supported, using lowp"))),"mediump"!==va||Eb||(va="lowp",THREE.warn("WebGLRenderer: mediump not supported, using lowp")),Db=Ab.precision>0,Eb=Bb.precision>0,"highp"!==wa||Db||(Eb?(wa="mediump",THREE.warn("WebGLRenderer: highp not supported, using mediump")):(wa="lowp",THREE.warn("WebGLRenderer: highp and mediump not supported, using lowp"))),"mediump"!==wa||Eb||(wa="lowp",THREE.warn("WebGLRenderer: mediump not supported, using lowp")),this.getContext=function(){return Oa},this.forceContextLoss=function(){pb.get("WEBGL_lose_context").loseContext()},this.supportsVertexTextures=function(){return xb},this.supportsFloatTextures=function(){return pb.get("OES_texture_float")},this.supportsHalfFloatTextures=function(){return pb.get("OES_texture_half_float_linear")},this.supportsStandardDerivatives=function(){return pb.get("OES_standard_derivatives")},this.supportsCompressedTextureS3TC=function(){return pb.get("WEBGL_compressed_texture_s3tc")},this.supportsMRT=function(){return!Ga&&Pa},this.supportsInstancedArrays=function(){return!!Qa},this.supportsBlendMinMax=function(){return pb.get("EXT_blend_minmax")},this.getMaxAnisotropy=function(){var a;return function(){if(void 0!==a)return a;var b=pb.get("EXT_texture_filter_anisotropic");return a=null!==b?Oa.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0}}(),this.getPixelRatio=function(){return ua},this.setPixelRatio=function(a){ua=a},this.getCurrentFramebuffer=function(){return Va},this.setIdBufferSource=function(a){switch(a){case 0:Da=!1;break;case 1:Da=!0;break;default:return!1}return!0},this.setSize=function(a,b,c){ta.width=a*ua,ta.height=b*ua,!1!==c&&(ta.style.width=a+"px",ta.style.height=b+"px"),this.setViewport(0,0,a,b)},this.setViewport=function(a,b,c,d){bb=a*ua,cb=b*ua,db=c*ua,eb=d*ua,Oa.viewport(bb,cb,db,eb)};var Fb=[];this.pushViewport=function(){Fb.push(bb),Fb.push(cb),Fb.push(db),Fb.push(eb)},this.popViewport=function(){var a=Fb.length-4;bb=Fb[a],cb=Fb[a+1],db=Fb[a+2],eb=Fb[a+3],Oa.viewport(bb,cb,db,eb),Fb.length=a},this.setScissor=function(a,b,c,d){Oa.scissor(a*ua,b*ua,c*ua,d*ua)},this.enableScissorTest=function(a){a?Oa.enable(Oa.SCISSOR_TEST):Oa.disable(Oa.SCISSOR_TEST)},this.getClearColor=function(){return Ea},this.setClearColor=function(a,b){Ea.set(a),Fa=void 0!==b?b:1,qb(Ea.r,Ea.g,Ea.b,Fa)},this.getClearAlpha=function(){return Fa},this.setClearAlpha=function(a){Fa=a,qb(Ea.r,Ea.g,Ea.b,Fa)},this.clear=function(a,b,c){var d=0;(void 0===a||a)&&(d|=Oa.COLOR_BUFFER_BIT),(void 0===b||b)&&(d|=Oa.DEPTH_BUFFER_BIT),(void 0===c||c)&&(d|=Oa.STENCIL_BUFFER_BIT),Oa.clear(d)},this.clearColor=function(){Oa.clear(Oa.COLOR_BUFFER_BIT)},this.clearDepth=function(){Oa.clear(Oa.DEPTH_BUFFER_BIT)},this.clearStencil=function(){Oa.clear(Oa.STENCIL_BUFFER_BIT)},this.clearTarget=function(a,b,c,d){this.setRenderTarget(a),this.clear(b,c,d)},this.resetGLState=sb;var Gb=function a(b){b.target.traverse(function(b){b.removeEventListener("remove",a),Q(b)})},Hb=function a(b){var c=b.target;c.removeEventListener("dispose",a),Mb(c)},Ib=function a(b){var c=b.target;c.removeEventListener("dispose",a),Nb(c),Sa.info.memory.textures--},Jb=function a(b){var c=b.target;c.removeEventListener("dispose",a),Ob(c),Sa.info.memory.textures--},Kb=function a(b){var c=b.target;c.removeEventListener("dispose",a),Pb(c)},Lb=function(a){if(void 0!==a.__webglVertexBuffer&&(Oa.deleteBuffer(a.__webglVertexBuffer),a.__webglVertexBuffer=void 0),void 0!==a.__webglNormalBuffer&&(Oa.deleteBuffer(a.__webglNormalBuffer),a.__webglNormalBuffer=void 0),void 0!==a.__webglTangentBuffer&&(Oa.deleteBuffer(a.__webglTangentBuffer),a.__webglTangentBuffer=void 0),void 0!==a.__webglColorBuffer&&(Oa.deleteBuffer(a.__webglColorBuffer),a.__webglColorBuffer=void 0),void 0!==a.__webglUVBuffer&&(Oa.deleteBuffer(a.__webglUVBuffer),a.__webglUVBuffer=void 0),void 0!==a.__webglUV2Buffer&&(Oa.deleteBuffer(a.__webglUV2Buffer),a.__webglUV2Buffer=void 0),void 0!==a.__webglSkinIndicesBuffer&&(Oa.deleteBuffer(a.__webglSkinIndicesBuffer),a.__webglSkinIndicesBuffer=void 0),void 0!==a.__webglSkinWeightsBuffer&&(Oa.deleteBuffer(a.__webglSkinWeightsBuffer),a.__webglSkinWeightsBuffer=void 0),void 0!==a.__webglFaceBuffer&&(Oa.deleteBuffer(a.__webglFaceBuffer),a.__webglFaceBuffer=void 0),void 0!==a.__webglLineBuffer&&(Oa.deleteBuffer(a.__webglLineBuffer),a.__webglLineBuffer=void 0),void 0!==a.__webglLineDistanceBuffer&&(Oa.deleteBuffer(a.__webglLineDistanceBuffer),a.__webglLineDistanceBuffer=void 0),void 0!==a.__webglCustomAttributesList){for(var b in a.__webglCustomAttributesList)Oa.deleteBuffer(a.__webglCustomAttributesList[b].buffer);a.__webglCustomAttributesList=void 0}Sa.info.memory.geometries--},Mb=function(a){a.__webglInit=void 0;var b,c,d,e;if(a instanceof THREE.BufferGeometry){if(void 0!==a.vbbuffer&&(Oa.deleteBuffer(a.vbbuffer),a.vbbuffer=void 0),void 0!==a.ibbuffer&&(Oa.deleteBuffer(a.ibbuffer),a.ibbuffer=void 0),void 0!==a.iblinesbuffer&&(Oa.deleteBuffer(a.iblinesbuffer),a.iblinesbuffer=void 0),a.vaos){for(b=0;b<a.vaos.length;b++)Ra.deleteVertexArrayOES(a.vaos[b].vao);a.vaos=void 0}var f=a.attributes;for(var g in f)void 0!==f[g].buffer&&(Oa.deleteBuffer(f[g].buffer),f[g].buffer=void 0);Sa.info.memory.geometries--}else{var h=Ub[a.id];if(void 0!==h){for(b=0,c=h.length;b<c;b++){var i=h[b];if(void 0!==i.numMorphTargets){for(d=0,e=i.numMorphTargets;d<e;d++)Oa.deleteBuffer(i.__webglMorphTargetsBuffers[d]);delete i.__webglMorphTargetsBuffers}if(void 0!==i.numMorphNormals){for(d=0,e=i.numMorphNormals;d<e;d++)Oa.deleteBuffer(i.__webglMorphNormalsBuffers[d]);delete i.__webglMorphNormalsBuffers}Lb(i)}delete Ub[a.id]}else Lb(a)}};this.deallocateGeometry=Mb;var Nb=function(a){if(a.__webglTextureCube)Oa.deleteTexture(a.__webglTextureCube),a.__webglTextureCube=void 0;else{if(!a.__webglInit)return;Oa.deleteTexture(a.__webglTexture),a.__webglInit=void 0,a.__webglTexture=void 0}},Ob=function(a){a&&a.__webglTexture&&(Oa.deleteTexture(a.__webglTexture),Oa.deleteFramebuffer(a.__webglFramebuffer),Oa.deleteRenderbuffer(a.__webglRenderbuffer))},Pb=function(a){var b=!1;a.program=void 0,a.programs.forEach(function(a){var c;if(void 0!==a&&void 0!=(c=a.program)){var d,e,f;for(d=0,e=Ta.length;d<e;d++)if((f=Ta[d])&&f.program===c){f.usedTimes--,0===f.usedTimes&&(Ta[d]=void 0,Oa.deleteProgram(c),Sa.info.memory.programs--,b=!0);break}}},!1),a.programs.length=0,!0===b&&(Ta=Ta.filter(function(a){return void 0!==a}))};this.renderBufferDirect=function(a,b,c,d,e,f,g){if(!1!==d.visible&&(!d.isEdgeMaterial||e.iblines)){q(f.geometry);var h=V(a,b,c,d,f),i=e.attributes,j=!1,k=d.wireframe?1:0,l="direct_"+e.id+(g?"/"+g:"")+"_"+h.id+"_"+k;l!==Ya&&(Ya=l,j=!0);var m=s(d,h,e,g||0);if(j=j&&!m,j&&ob.initAttributes(),f instanceof THREE.Mesh){var n,o=i.index;if(o){var p,r,t=o.array?o.array:e.ib;d.isEdgeMaterial&&(o=i.indexlines,t=e.iblines),o.bytesPerItem?4===(r=o.bytesPerItem)&&pb.get("OES_element_index_uint"):r=t instanceof Uint32Array&&pb.get("OES_element_index_uint")?4:2,p=4===r?Oa.UNSIGNED_INT:Oa.UNSIGNED_SHORT;var v=d.isEdgeMaterial?null:e.offsets;v&&v.length>1&&(j=!0);var w=0;do{var x,y,z;v&&v.length?(x=v[w].index,y=v[w].start,z=v[w].count):(x=0,y=0,z=t.length),j&&u(d,h,e,x,o,g),n=Oa.TRIANGLES,e.isPoints?n=Oa.POINTS:(e.isLines||d.isEdgeMaterial)&&(n=Oa.LINES),e.numInstances?Qa.drawElementsInstancedANGLE(n,z,p,y*r,e.numInstances):Oa.drawElements(n,z,p,y*r)}while(v&&++w<v.length)}else{j&&u(d,h,e,0,void 0,g);var A=e.attributes.position;n=Oa.TRIANGLES,e.isPoints?n=Oa.POINTS:(e.isLines||d.isEdgeMaterial)&&(n=Oa.LINES),e.numInstances?Qa.drawArraysInstancedANGLE(n,0,A.array.length/3,e.numInstances):Oa.drawArrays(n,0,A.array.length/A.itemSize)}}else THREE.log("Only THREE.Mesh can be rendered by the Firefly renderer. Use THREE.Mesh to draw lines.");m&&Ra.bindVertexArrayOES(null)}},this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){N(f);var g=V(a,b,c,d,f),h=g.attributes,i=!1,j=d.wireframe?1:0,k=e.id+"_"+g.id+"_"+j;if(k!==Ya&&(Ya=k,i=!0),i&&ob.initAttributes(),!d.morphTargets&&h.position>=0&&i&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglVertexBuffer),ob.enableAttribute(h.position),Oa.vertexAttribPointer(h.position,3,Oa.FLOAT,!1,0,0)),i){if(e.__webglCustomAttributesList)for(var l=0,m=e.__webglCustomAttributesList.length;l<m;l++){var n=e.__webglCustomAttributesList[l];h[n.buffer.belongsToAttribute]>=0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,n.buffer),ob.enableAttribute(h[n.buffer.belongsToAttribute]),Oa.vertexAttribPointer(h[n.buffer.belongsToAttribute],n.size,Oa.FLOAT,!1,0,0))}h.color>=0&&(f.geometry.colors.length>0||f.geometry.faces.length>0?(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglColorBuffer),ob.enableAttribute(h.color),Oa.vertexAttribPointer(h.color,3,Oa.FLOAT,!1,0,0)):d.defaultAttributeValues&&Oa.vertexAttrib3fv(h.color,d.defaultAttributeValues.color)),h.normal>=0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglNormalBuffer),ob.enableAttribute(h.normal),Oa.vertexAttribPointer(h.normal,3,Oa.FLOAT,!1,0,0)),h.tangent>=0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglTangentBuffer),ob.enableAttribute(h.tangent),Oa.vertexAttribPointer(h.tangent,4,Oa.FLOAT,!1,0,0)),h.uv>=0&&(f.geometry.faceVertexUvs[0]?(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglUVBuffer),ob.enableAttribute(h.uv),Oa.vertexAttribPointer(h.uv,2,Oa.FLOAT,!1,0,0)):d.defaultAttributeValues&&Oa.vertexAttrib2fv(h.uv,d.defaultAttributeValues.uv)),h.uv2>=0&&(f.geometry.faceVertexUvs[1]?(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglUV2Buffer),ob.enableAttribute(h.uv2),Oa.vertexAttribPointer(h.uv2,2,Oa.FLOAT,!1,0,0)):d.defaultAttributeValues&&Oa.vertexAttrib2fv(h.uv2,d.defaultAttributeValues.uv2)),h.lineDistance>=0&&(Oa.bindBuffer(Oa.ARRAY_BUFFER,e.__webglLineDistanceBuffer),ob.enableAttribute(h.lineDistance),Oa.vertexAttribPointer(h.lineDistance,1,Oa.FLOAT,!1,0,0))}if(ob.disableUnusedAttributes(),f instanceof THREE.Mesh){var o=e.__typeArray===Uint32Array?Oa.UNSIGNED_INT:Oa.UNSIGNED_SHORT;d.wireframe?(ob.setLineWidth(d.wireframeLinewidth*ua),i&&Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),Oa.drawElements(Oa.LINES,e.__webglLineCount,o,0)):(i&&Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER,e.__webglFaceBuffer),Oa.drawElements(Oa.TRIANGLES,e.__webglFaceCount,o,0))}else if(f instanceof THREE.Line){var p=f.mode===THREE.LineStrip?Oa.LINE_STRIP:Oa.LINES;ob.setLineWidth(d.linewidth*ua),Oa.drawArrays(p,0,e.__webglLineCount)}else f instanceof THREE.PointCloud&&Oa.drawArrays(Oa.POINTS,0,e.__webglPointCount)}},this.render=function(a,b,c,d,e){if(b instanceof THREE.Camera==!1)return void THREE.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");Ya="",Wa=-1,Xa=null,void 0!==e&&(Ha.length=0,lb=!0);var f=a.fog;!0===a.autoUpdate&&a.updateMatrixWorld(),void 0===b.parent&&b.updateMatrixWorld(),b.matrixWorldInverse.getInverse(b.matrixWorld),b.worldUpTransform?ib.multiplyMatrices(b.worldUpTransform,b.matrixWorld):ib.copy(b.matrixWorld),hb.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse),gb.setFromMatrix(hb);var g=a instanceof C&&a.renderImmediate;if(g||(Ma.length=0,Na.length=0,z(a,!0===Sa.sortObjects,!0===a.forceVisible),!0===Sa.sortObjects&&(Ma.sort(w),Na.sort(v))),lb&&(e&&e.length&&(Ha=e.slice()),ka(Ha)),this.setRenderTarget(c),this.resetGLState(),(this.autoClear||d)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil),a.overrideMaterial){var h=a.overrideMaterial;U(h),g?G(a,"",b,Ha,f,h):(B(Ma,b,Ha,f,h),B(Na,b,Ha,f,h))}else g?G(a,"",b,Ha,f,null):(ob.setBlending(THREE.NoBlending),B(Ma,b,Ha,f,null),B(Na,b,Ha,f,null));c&&c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter&&pa(c),this.resetGLState(),ob.setDepthTest(!0),ob.setDepthWrite(!0)},this.clearBlend=function(){ob.setBlending(THREE.NoBlending)},this.setProgramPrefix=function(a,b,c){Za=a,$a=b,_a=c},this.getProgramPrefix=function(){return{programPrefix:Za,vertexPrefix:$a,fragmentPrefix:_a}};var Qb,Rb,Sb,Tb,Ub={},Vb=0,Wb={MeshDepthMaterial:"depth",MeshNormalMaterial:"normal",MeshBasicMaterial:"firefly_basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"firefly_phong",LineBasicMaterial:"firefly_basic",LineDashedMaterial:"dashed",PointCloudMaterial:"firefly_basic"};this.setFaceCulling=function(a,b){a===THREE.CullFaceNone?Oa.disable(Oa.CULL_FACE):(b===THREE.FrontFaceDirectionCW?Oa.frontFace(Oa.CW):Oa.frontFace(Oa.CCW),a===THREE.CullFaceBack?Oa.cullFace(Oa.BACK):a===THREE.CullFaceFront?Oa.cullFace(Oa.FRONT):Oa.cullFace(Oa.FRONT_AND_BACK),Oa.enable(Oa.CULL_FACE))},this.setMaterialFaces=function(a){ob.setDoubleSided(a.side===THREE.DoubleSide),ob.setFlipSided(a.side===THREE.BackSide)},this.uploadTexture=function(a){void 0===a.__webglInit&&(a.__webglInit=!0,a.addEventListener("dispose",Ib),a.__webglTexture=Oa.createTexture(),Sa.info.memory.textures++),Oa.bindTexture(Oa.TEXTURE_2D,a.__webglTexture),Oa.pixelStorei(Oa.UNPACK_FLIP_Y_WEBGL,a.flipY),Oa.pixelStorei(Oa.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha),Oa.pixelStorei(Oa.UNPACK_ALIGNMENT,a.unpackAlignment),a.image=ma(a.image,vb);var b=a.image,c=THREE.Math.isPowerOfTwo(b.width)&&THREE.Math.isPowerOfTwo(b.height),d=ra(a.format),e=ra(a.type);la(Oa.TEXTURE_2D,a,c);var f,g,h,i=a.mipmaps;if(a instanceof THREE.DataTexture)if(i.length>0&&c){for(g=0,h=i.length;g<h;g++)f=i[g],Oa.texImage2D(Oa.TEXTURE_2D,g,d,f.width,f.height,0,d,e,f.data);a.generateMipmaps=!1}else Oa.texImage2D(Oa.TEXTURE_2D,0,d,b.width,b.height,0,d,e,b.data);else if(a instanceof THREE.CompressedTexture){for(g=0,h=i.length;g<h;g++)f=i[g],a.format!==THREE.RGBAFormat&&a.format!==THREE.RGBFormat?Cb().indexOf(d)>-1?Oa.compressedTexImage2D(Oa.TEXTURE_2D,g,d,f.width,f.height,0,f.data):THREE.warn("Attempt to load unsupported compressed texture format"):Oa.texImage2D(Oa.TEXTURE_2D,g,d,f.width,f.height,0,d,e,f.data);if(i.length>1&&Cb().indexOf(d)>-1)for(var j,k=f.width>>1,l=f.height>>1,m=i.length;k>=1||l>=1;)j=4==f.width&&4==f.height?f.data:new DataView(f.data.buffer,f.data.byteOffset,f.data.byteLength*(Math.max(k,4)*Math.max(l,4))/(f.width*f.height)),Oa.compressedTexImage2D(Oa.TEXTURE_2D,m,d,Math.max(k,1),Math.max(l,1),0,j),k>>=1,l>>=1,++m}else if(i.length>0&&c){for(g=0,h=i.length;g<h;g++)f=Cc(i[g]),Oa.texImage2D(Oa.TEXTURE_2D,g,d,d,e,f);a.generateMipmaps=!1}else Oa.texImage2D(Oa.TEXTURE_2D,0,d,d,e,Cc(a.image));a.generateMipmaps&&c&&Oa.generateMipmap(Oa.TEXTURE_2D),a.needsUpdate=!1,a.onUpdate&&a.onUpdate()},this.setTexture=function(a,b){Oa.activeTexture(Oa.TEXTURE0+b),a.needsUpdate?Sa.uploadTexture(a):a.__webglTexture&&Oa.bindTexture(Oa.TEXTURE_2D,a.__webglTexture)},this.initFrameBufferMRT=function(a,b){var c=a[0],d=!1;if(c&&!c.__webglFramebuffer){void 0===c.depthBuffer&&(c.depthBuffer=!0),void 0===c.stencilBuffer&&(c.stencilBuffer=!0),c.__webglFramebuffer=Oa.createFramebuffer(),Oa.bindFramebuffer(Oa.FRAMEBUFFER,c.__webglFramebuffer);var e;c.shareDepthFrom?e=c.__webglRenderbuffer=c.shareDepthFrom.__webglRenderbuffer:c.depthBuffer&&!c.stencilBuffer?(e=c.__webglRenderbuffer=Oa.createRenderbuffer(),Oa.bindRenderbuffer(Oa.RENDERBUFFER,e),Oa.renderbufferStorage(Oa.RENDERBUFFER,Oa.DEPTH_COMPONENT16,c.width,c.height)):c.depthBuffer&&c.stencilBuffer&&(e=c.__webglRenderbuffer=Oa.createRenderbuffer(),Oa.bindRenderbuffer(Oa.RENDERBUFFER,e),Oa.renderbufferStorage(Oa.RENDERBUFFER,Oa.DEPTH_STENCIL,c.width,c.height)),c.depthBuffer&&!c.stencilBuffer?Oa.framebufferRenderbuffer(Oa.FRAMEBUFFER,Oa.DEPTH_ATTACHMENT,Oa.RENDERBUFFER,e):c.depthBuffer&&c.stencilBuffer&&Oa.framebufferRenderbuffer(Oa.FRAMEBUFFER,Oa.DEPTH_STENCIL_ATTACHMENT,Oa.RENDERBUFFER,e),d=!0}var f=Va;Oa.bindFramebuffer(Oa.FRAMEBUFFER,c.__webglFramebuffer);var g;for(g=0;g<a.length;g++){var h=a[g];if(h&&!h.__webglTexture){var i=THREE.Math.isPowerOfTwo(h.width)&&THREE.Math.isPowerOfTwo(h.height),j=ra(h.format),k=ra(h.type);h.addEventListener("dispose",Jb),h.__webglTexture=Oa.createTexture(),Sa.info.memory.textures++,Oa.bindTexture(Oa.TEXTURE_2D,h.__webglTexture),la(Oa.TEXTURE_2D,h,i),Oa.texImage2D(Oa.TEXTURE_2D,0,j,h.width,h.height,0,j,k,null),i&&h.generateMipmaps&&Oa.generateMipmap(Oa.TEXTURE_2D)}Oa.framebufferTexture2D(Oa.FRAMEBUFFER,Oa.COLOR_ATTACHMENT0+g,Oa.TEXTURE_2D,h&&h.__webglTexture,0)}if(this.supportsMRT()){for(var l=Oa.getParameter(Pa.MAX_COLOR_ATTACHMENTS_WEBGL);g<l;)Oa.framebufferTexture2D(Oa.FRAMEBUFFER,Oa.COLOR_ATTACHMENT0+g,Oa.TEXTURE_2D,null,0),g++;var m=[Pa.COLOR_ATTACHMENT0_WEBGL];for(g=1;g<a.length;g++)m.push(Pa.COLOR_ATTACHMENT0_WEBGL+g);Pa.drawBuffersWEBGL(m)}if(b){var n=Oa.checkFramebufferStatus(Oa.FRAMEBUFFER);n!==Oa.FRAMEBUFFER_COMPLETE&&(THREE.log("Can't use multiple render targets. Falling back to two passes. "+n),delete c.__webglFramebuffer,b=!1)}return Oa.bindFramebuffer(Oa.FRAMEBUFFER,f),d&&(Oa.bindTexture(Oa.TEXTURE_2D,null),Oa.bindRenderbuffer(Oa.RENDERBUFFER,null),Oa.bindFramebuffer(Oa.FRAMEBUFFER,null)),b},this.setRenderTarget=function(a){var b;if(Array.isArray(a))this.initFrameBufferMRT(a),b=a[0];else if(a){var c=a.__webglFramebuffer;c&&Va===c||this.initFrameBufferMRT([a]),b=a}var d,e,f,g,h;b?(d=b.__webglFramebuffer,e=b.width,f=b.height,g=0,h=0):(d=null,e=db,f=eb,g=bb,h=cb),d!==Va&&(Oa.bindFramebuffer(Oa.FRAMEBUFFER,d),Oa.viewport(g,h,e,f),Va=d)},this.verifyMRTWorks=function(a){return!!this.supportsMRT()&&this.initFrameBufferMRT(a,!0)},this.readRenderTargetPixels=function(a,b,c,d,e,f){if(!(a instanceof THREE.WebGLRenderTarget))return void THREE.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");if(a.__webglFramebuffer){if(a.format!==THREE.RGBAFormat&&a.format!==THREE.RGBFormat||a.type!==THREE.UnsignedByteType)return void THREE.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not a readable format.");var g=!1;a.__webglFramebuffer!==Va&&(Oa.bindFramebuffer(Oa.FRAMEBUFFER,a.__webglFramebuffer),g=!0),a.canReadPixels||Oa.checkFramebufferStatus(Oa.FRAMEBUFFER)===Oa.FRAMEBUFFER_COMPLETE?Oa.readPixels(b,c,d,e,Oa.RGBA,Oa.UNSIGNED_BYTE,f):THREE.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."),g&&Oa.bindFramebuffer(Oa.FRAMEBUFFER,Va)}}};Na.prototype=Object.create(C.prototype),Na.prototype.constructor=Na,Na.prototype.resetVisStatus=function(){this.visibleStats=0},Na.prototype.forEach=function(a,b,c){for(var d=this.getIndices(),e=this.frags,f=!this.sortByShaderDone,g=e.pageOutGeometryEnabled(),h=e.onDemandLoadingEnabled(),i=this.start,j=this.lastItem;i<j;i++){var k=d?d[i]:i,l=e.getVizmesh(k,this.renderImportance,!0);if(!f||l&&l.material&&l.material.program&&!l.geometry_proxy||(f=!1),h){if(e.isFlagSet(k,Qc)&&b==Sc)continue;if(!c&&b&&e.isFlagSet(k,b)&&(l.geometry||(l.geometry=e.requireGeometry(k),k<this.drawOrderRender&&(this.drawOrderRender=k),!l.geometry&&l.geometry_proxy&&(l.geometry=l.geometry_proxy)),l.geometry)){var m=b==Sc&&e.isFlagSet(k,Rc);if(b==Sc){if(!(void 0==this.drawOrderRender||k<this.drawOrderRender))continue;e.setFlagFragment(k,Rc,!0)}if(!m&&g&&e.pagingProxy){var n=e.getMaterial(k);n&&e.pagingProxy.onGeomTraversed(l.geometry,n.transparent)}}}!(c||l&&l.geometry)||b&&!e.isFlagSet(k,b)||a(l,k)}f&&this.sortByShader()},Na.prototype.applyVisibility=function(){function a(a,b,c,d){var e=!1;j||(j=new THREE.Box3),c.getWorldBounds(d,j);var f=b.intersectsBox(j);if(a&&f===A.OUTSIDE)e=!0;else if(c.pixelCullingEnable()){var g=b.projectedBoxArea(j,f===A.CONTAINS);g*=b.areaConv,g<c.pixelCullingThreshold()&&(e=!0)}return e}function b(b,j){if(!b&&c.useThreeMesh)return void(g&&g(j));if(k||a(h,e,c,j)){if(b?b.visible=!1:THREE.warn("Unexpected null mesh"),d[j]=d[j]&~Sc,c.pageOutGeometryEnabled()){var l=c.geomids[j],m=c.geoms.getGeometry(l);c.pagingProxy&&c.pagingProxy.onGeomCulled(m)}}else{var n=this.evalVisbility(f,d,j);b&&(b.visible=!!n),i=i&&!n}}var c,d,e,f,g,h,i,j,k;return function(a,j,l){i=!0,k=!1,e=j,f=a,g=l,c=this.frags;var m=2===f?this.boundingBoxHidden:this.boundingBox,n=e.intersectsBox(m);if(n===A.OUTSIDE&&(k=!0),h=n!==A.CONTAINS,c.pixelCullingEnable()){var o=this.renderImportance;0==o&&(o=e.projectedBoxArea(m,!h)),o*=e.areaConv,o<c.pixelCullingThreshold()&&(k=!0)}return d=this.frags.vizflags,this.forEach(b.bind(this),null,g),i}}();var ye=500,ze=Wd.MATERIAL_VARIANT,Ae=function(){var a=null,b=[];return function(c,d,e,f,g,h){a||(a=new THREE.Matrix4);var i=e[f],j=c.getGeometry(i),k=c.getMaterial(i),l=g-f;if(1==l)return void h.addSingleFragment(c,i);b.length=0;for(var m=new Ia(j,l),n=f;n<g;n++){var o=e[n];c.getOriginalWorldMatrix(o,a);var p=c.fragments.fragId2dbId[o];m.addInstance(a,p)||b.push(o)}var q=m.finish();if(q){var r=d.getMaterialVariant(k,ze.INSTANCED,c.model);h.addContainerMesh(q,r,e,f,l)}for(n=0;n<b.length;n++)o=b[n],h.addSingleFragment(c,o)}}(),Be=function(a){var b=a||function(a,b){return a<b},c=[],d=[],e=function a(e,f,g){if(f||(f=0),g||(g=d.length),f>=g)return g;if(g===f+1){var h=c[d[f]];return b(h,e)?g:f}var i=parseInt(f+(g-f)/2),j=c[d[i-1]];return b(e,j)?a(e,f,i):b(j,e)?a(e,i,g):i-1};this.add=function(a){var b=e(a);if(b===d.length)return c.push(a),void d.push(c.length-1);c.push(a),d.splice(b,0,c.length-1)},this.size=function(){return d.length},this.get=function(a){return c[d[a]]},this.removeAt=function(a){var b=d[a];c[b]=void 0,d.splice(a,1)},this.toString=function(){for(var a="",b=0,c=this.size();b<c;++b)a+=this.get(b),b<c-1&&(a+=", ");return a}};Ya.prototype.resetBoxRun=function(){this.boxCount=0},Ya.prototype.getNextAvailableFragmentId=function(){return this.nextAvailableFragID++},Ya.prototype.fragmentsHaveBeenAdded=function(){return this.vizflags.length>this.fragments.length},Ya.prototype.getSvfMaterialId=function(a){var b=this.getMaterial(a);return b?b.svfMatId:void 0},Ya.prototype.onDemandLoadingEnabled=function(){return this.pagingProxy&&this.pagingProxy.onDemandLoadingEnabled()},Ya.prototype.pageOutGeometryEnabled=function(){return this.pagingProxy&&this.pagingProxy.pageOutGeometryEnabled()},Ya.prototype.pixelCullingEnable=function(){return this.pagingProxy&&this.pagingProxy.pixelCullingEnable()},Ya.prototype.pixelCullingThreshold=function(){return this.pagingProxy?this.pagingProxy.pixelCullingThreshold():0},Ya.prototype.requireGeometry=function(a){var b=null,c=this.geomids[a];if(c>=0&&(b=this.geoms.getGeometry(c)),null==b){var d=this.fragments.packIds?this.fragments.packIds[a]:a;this.pagingProxy&&this.pagingProxy.loadPackFile(d)}return b},Ya.prototype.promiseGeometry=function(a){function b(a,b){var c;return c=a.then(function(){return c&&(delete c.lmv_loader_promise,c.lmv_geom_canceled)?Promise.reject({canceled:!0}):b},function(a){return c&&(delete c.lmv_loader_promise,c.lmv_geom_canceled)?Promise.reject({canceled:!0}):Promise.reject(a)}),c.lmv_loader_promise=a,c}if(this.getGeometry(a))return b(Promise.resolve(),{model:this.model,fragId:a});var c=this.fragments.packIds?this.fragments.packIds[a]:a;if(!this.pagingProxy||!this.pagingProxy.promisePackFile)return b(Promise.reject({reason:"Not supported"}));var d=this.pagingProxy.promisePackFile(c);return d.hasOwnProperty("lmv_promise_count")||(d.lmv_promise_count=0),++d.lmv_promise_count,this.pagingProxy.pageOut(!1,!1),b(d,{model:this.model,fragId:a})},Ya.prototype.cancelPromisedGeometry=function(a){if(!a)return!1;var b=a.lmv_loader_promise;return!!b&&(!!a.lmv_geom_canceled||(a.lmv_geom_canceled=!0,b.hasOwnProperty("lmv_promise_count")&&--b.lmv_promise_count<=0&&this.pagingProxy&&this.pagingProxy.promisePackFile&&this.pagingProxy.cancelPromisedPackFile(b),!0))},Ya.prototype.setMesh=function(a,b,c){if(this.vizmeshes){var d=this.vizmeshes[a];d&&d.parent&&d.parent.remove(d)}if(this.vizflags.length<=a){this.isFixedSize&&(THREE.warn("Attempting to resize a fragments list that was initialized with fixed data. This will have a performance impact."),this.isFixedSize=!1);var e=Math.ceil(1.5*this.vizflags.length)||1;this.useThreeMesh&&e<this.vizmeshes.length&&(e=this.vizmeshes.length);var f=new Uint16Array(e);if(f.set(this.vizflags),this.vizflags=f,this.transforms){var g=new Float32Array(12*e);g.set(this.transforms),this.transforms=g}if(this.boxes){var h=new Float32Array(6*e);h.set(this.boxes),this.boxes=h}if(this.geomids){var i=new Int32Array(e);i.set(this.geomids),this.geomids=i}if(this.materialids){var j=new Int32Array(e);j.set(this.materialids),this.materialids=j}}if(this.useThreeMesh){var k=new THREE.Mesh(b.geometry,b.material);b.matrix&&(k.matrix&&k.matrix.copy(b.matrix),k.matrixWorld.copy(b.matrix)),k.is2d=b.is2d,k.isLine=b.isLine,k.isWideLine=b.isWideLine,k.isPoint=b.isPoint,k.matrixAutoUpdate=!1,k.frustumCulled=!1,k.fragId=a,k.dbId=0|this.fragments.fragId2dbId[a],k.modelId=this.model.getModelId(),this.vizmeshes[a]=k}else this.geomids[a]=b.geometry.svfid,this.materialids[a]=b.material.id,this.materialmap[b.material.id]||(this.materialmap[b.material.id]=b.material);var l=0;if(b.isLine?l=8:b.isWideLine?l=512:b.isPoint&&(l=256),this.isFixedSize?this.vizflags[a]|=l:this.vizflags[a]|=Mc|l,c){var m=b.matrix,n=12*a,o=m.elements,p=this.transforms;p[n]=o[0],p[n+1]=o[1],p[n+2]=o[2],p[n+3]=o[4],p[n+4]=o[5],p[n+5]=o[6],p[n+6]=o[8],p[n+7]=o[9],p[n+8]=o[10],p[n+9]=o[12],p[n+10]=o[13],p[n+11]=o[14];var q=new THREE.Box3;b.geometry&&b.geometry.boundingBox?q.copy(b.geometry.boundingBox):this.geoms.getModelBox(this.geomids[a],q),q.applyMatrix4(m);var r=6*a,s=this.boxes;s[r]=q.min.x,s[r+1]=q.min.y,s[r+2]=q.min.z,s[r+3]=q.max.x,s[r+4]=q.max.y,s[r+5]=q.max.z}},Ya.prototype.isFlagSet=function(a,b){return!!(this.vizflags[a]&b)},Ya.prototype.setFlagFragment=function(a,b,c){var d=this.vizflags[a];return!!(d&b)!=c&&(this.vizflags[a]=c?d|b:d&~b,!0)},Ya.prototype.setFlagGlobal=function(a,b){var c=this.vizflags,d=0,e=c.length;if(b)for(;d<e;d++)c[d]=c[d]|a;else for(var f=~a;d<e;d++)c[d]=c[d]&f},Ya.prototype.hideLines=function(a){this.hideFragments(8,a),this.hideFragments(512,a)},Ya.prototype.hidePoints=function(a){this.hideFragments(256,a)},Ya.prototype.hideFragments=function(a,b){var c=Oc,d=this.vizflags,e=0,f=d.length;if(b)for(;e<f;e++)d[e]&a&&(d[e]=d[e]|c);else for(var g=~c;e<f;e++)d[e]&a&&(d[e]=d[e]&g);this.allVisibleDirty=!0},Ya.prototype.isFragVisible=function(a){return 1==(7&this.vizflags[a])},Ya.prototype.isFragOff=function(a){return!!(this.vizflags[a]&Oc)},Ya.prototype.isLine=function(a){return!!(8&this.vizflags[a])},Ya.prototype.isWideLine=function(a){return this.isFlagSet(a,512)},Ya.prototype.isPoint=function(a){return this.isFlagSet(a,256)},Ya.prototype.areAllVisible=function(){if(this.allVisibleDirty){for(var a=this.vizflags,b=!0,c=0,d=a.length;c<d;c++)if(0==(1&a[c])){b=!1;break}this.allVisible=b,this.allVisibleDirty=!1}return this.allVisible};var Ce=function(){var a=null,b=null,c=parseInt("00FFFFFF",16),d=parseInt("FF000000",16);return function(e,f){return a||(a=new THREE.Color,b=new THREE.Color),a.set(e&c),Za(a),f&&(b.setRGB(f.x,f.y,f.z),a.lerp(b,f.w)),Za(a).getHex()|e&d}}();Ya.prototype.getVizmesh=function(){function a(){d||(d=new THREE.Mesh(void 0,void 0,!0),d.isTemp=!0,d.dbId=0,d.modelId=0,d.fragId=-1,d.hide=!1,d.isLine=!1,d.isWideLine=!1,d.isPoint=!1,e=new THREE.MeshLambertMaterial({color:0,depthWrite:!1,emissive:13421772}),e.cutplanes=null,f=new THREE.Box3,g=new THREE.Vector3,h=new THREE.Vector3,i=new Float32Array([1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,-1]),j=new THREE.BufferGeometry,j.addAttribute("position",new THREE.BufferAttribute(i,3)))}function b(a,b,c,d){var e=a*b,f=d.boxes;c.min.x=f[e],c.min.y=f[e+1],c.min.z=f[e+2],c.max.x=f[e+3],c.max.y=f[e+4],c.max.z=f[e+5]}function c(a,c,d){if(!d.boxTransform[c]){b(c,6,f,d);var e=new THREE.Matrix4;h.subVectors(f.max,f.min),h.multiplyScalar(.5),
e.makeScale(h.x,h.y,h.z),g.addVectors(f.max,f.min),g.multiplyScalar(.5);var i=e.elements;i[12]=g.x,i[13]=g.y,i[14]=g.z,d.boxTransform[c]=e}a.geometry_proxy=j,a.matrixWorld.copy(d.boxTransform[c])}var d,e,f,g,h,i,j;return function(b,f,g){if(this.model.is2d()&&$a(this,b),this.useThreeMesh)return this.vizmeshes[b];a(),this.getWorldMatrix(b,d.matrixWorld),d.visible=!0,d.hide=this.isFragOff(b),d.fragId=b,d.dbId=this.getDbIds(b),d.themingColor=this.db2ThemingColor[d.dbId],d.modelId=this.model.getModelId(),d.geometry=this.getGeometry(b);var h=!1;if(!h){var i=this.pagingProxy?this.pagingProxy.options.debug.boxProxyMaxCount:0;if(!d.geometry&&this.boxCount<i){var j=this.pagingProxy?this.pagingProxy.options.debug.boxProxyMinScreen:.1;(void 0===f||0==f||void 0!==f&&f>j)&&(h=!0)}}return h?(c(d,b,this),g||(d.geometry=d.geometry_proxy),this.boxCount++,d.material=e,d.isLine=!1,d.isWideLine=!1,d.isPoint=!1):(d.material=this.getMaterial(b),d.isLine=this.isLine(b),d.isWideLine=this.isWideLine(b),d.isPoint=this.isPoint(b),d.geometry&&this.boxTransform[b]&&(this.boxTransform[b]=null)),d}}(),Ya.prototype.promiseVizmesh=function(a){return this.promiseGeometry(a)},Ya.prototype.cancelPromisedVizmesh=function(a){return this.cancelPromisedGeometry(a)},Ya.prototype.getMaterialId=function(a){return this.useThreeMesh?this.vizmeshes[a].material.id:this.materialids[a]},Ya.prototype.getMaterial=function(a){return this.useThreeMesh?this.vizmeshes[a].material:this.materialmap[this.materialids[a]]},Ya.prototype.getGeometry=function(a){var b;return this.useThreeMesh?(b=this.vizmeshes[a])?b.geometry:null:this.geoms.getGeometry(this.geomids[a])},Ya.prototype.lockGeometry=function(a){return!!this.useThreeMesh||this.geoms.lockGeometry(this.geomids[a])},Ya.prototype.unlockGeometry=function(a){return!!this.useThreeMesh||this.geoms.unlockGeometry(this.geomids[a])},Ya.prototype.getLockCount=function(a){return this.useThreeMesh?0:this.geoms.getLockCount(this.geomids[a])},Ya.prototype.getGeometryId=function(a){return this.useThreeMesh?a:this.geomids[a]},Ya.prototype.setMaterial=function(a,b){this.useThreeMesh?this.vizmeshes[a].material=b:(this.materialids[a]=b.id,this.materialmap[b.id]=b)},Ya.prototype.getCount=function(){return this.vizmeshes?this.vizmeshes.length:this.vizflags.length},Ya.prototype.getDbIds=function(a){return this.fragments.fragId2dbId[a]},Ya.prototype.dispose=function(a){if(this.useThreeMesh)for(var b={type:"dispose"},c={type:"removed"},d=0;d<this.vizmeshes.length;d++){var e=this.vizmeshes[d];e&&(e.dispatchEvent(c),e.geometry.dispatchEvent(b))}else this.geoms.dispose(a)},Ya.prototype.setVisibility=function(a,b){this.setFlagFragment(a,Mc,b),this.allVisibleDirty=!0},Ya.prototype.setFragOff=function(a,b){this.setFlagFragment(a,Oc,b),this.allVisibleDirty=!0},Ya.prototype.setAllVisibility=function(a){if(this.model.is2d()){var b=this.fragments;if(b&&b.dbId2fragId)for(var c in b.dbId2fragId)this.setObject2DGhosted(c,!a)}else this.setFlagGlobal(Mc,a),this.allVisible=a,this.allVisibleDirty=!1},Ya.prototype.updateAnimTransform=function(a,b,c,d){var e,f=this.animxforms;if(!f){var g=this.getCount();f=this.animxforms=new Float32Array(10*g);for(var h=0;h<g;h++)e=10*h,f[e]=1,f[e+1]=1,f[e+2]=1,f[e+3]=0,f[e+4]=0,f[e+5]=0,f[e+6]=1,f[e+7]=0,f[e+8]=0,f[e+9]=0}e=10*a;var i=!1;b&&(f[e]=b.x,f[e+1]=b.y,f[e+2]=b.z,i=!0),c&&(f[e+3]=c.x,f[e+4]=c.y,f[e+5]=c.z,f[e+6]=c.w,i=!0),d&&(f[e+7]=d.x,f[e+8]=d.y,f[e+9]=d.z,i=!0),this.setFlagFragment(a,Pc,i),i||(f[e]=1,f[e+1]=1,f[e+2]=1,f[e+3]=0,f[e+4]=0,f[e+5]=0,f[e+6]=1,f[e+7]=0,f[e+8]=0,f[e+9]=0)},Ya.prototype.getAnimTransform=function(a,b,c,d){if(!this.animxforms)return!1;if(!this.isFlagSet(a,Pc))return!1;var e=10*a,f=this.animxforms;return b&&(b.x=f[e],b.y=f[e+1],b.z=f[e+2]),c&&(c.x=f[e+3],c.y=f[e+4],c.z=f[e+5],c.w=f[e+6]),d&&(d.x=f[e+7],d.y=f[e+8],d.z=f[e+9]),!0},Ya.prototype.getOriginalWorldMatrix=function(a,b){var c=12*a,d=b.elements,e=this.transforms;if(e)d[0]=e[c],d[1]=e[c+1],d[2]=e[c+2],d[3]=0,d[4]=e[c+3],d[5]=e[c+4],d[6]=e[c+5],d[7]=0,d[8]=e[c+6],d[9]=e[c+7],d[10]=e[c+8],d[11]=0,d[12]=e[c+9],d[13]=e[c+10],d[14]=e[c+11],d[15]=1;else if(this.useThreeMesh){var f=this.getVizmesh(a);f?b.copy(f.matrixWorld):b.identity()}else b.identity()},Ya.prototype.getWorldMatrix=function(){function a(){b=new THREE.Matrix4,c=new THREE.Vector3,d=new THREE.Quaternion,e=new THREE.Vector3}var b,c,d,e;return function(f,g){b||a(),this.getOriginalWorldMatrix(f,g),this.isFlagSet(f,Pc)&&(this.getAnimTransform(f,e,d,c),b.compose(c,d,e),g.multiplyMatrices(b,g))}}(),Ya.prototype.getWorldBounds=function(){function a(){b=new THREE.Matrix4}var b;return function(c,d){if(b||a(),this.boxes&&!this.isFlagSet(c,Pc)){var e=this.boxes,f=6*c;return d.min.x=e[f],d.min.y=e[f+1],d.min.z=e[f+2],d.max.x=e[f+3],d.max.y=e[f+4],void(d.max.z=e[f+5])}if(this.useThreeMesh){var g=this.getVizmesh(c);g&&g.geometry&&d.copy(g.geometry.boundingBox)}else this.geoms.getModelBox(this.geomids[c],d);d.empty()||(this.getWorldMatrix(c,b),d.applyMatrix4(b))}}(),Ya.prototype.setThemingColor=function(a,b){this.db2ThemingColor[a]=b,_a(this,a)},Ya.prototype.clearThemingColors=function(){if(this.model.is2d())for(var a=1,b=this.fragments.dbId2fragId.length;a<b;a++)_a(this,a);this.db2ThemingColor.length=0},Ya.prototype.setObject2DGhosted=function(a,b){this.dbIdIsGhosted[a]=b,_a(this,a)},Ya.prototype.setObject2DVisible=function(a,b){this.dbIdIsHidden[a]=!b,_a(this,a)},Ya.prototype.getMemoryInfo=function(){return this.pagingProxy?this.pagingProxy.getMemoryInfo():null},ab.prototype.getWorldMatrix=function(a){this.frags.getWorldMatrix(this.fragId,a)},ab.prototype.getOriginalWorldMatrix=function(a){this.frags.getOriginalWorldMatrix(this.fragId,a)},ab.prototype.getWorldBounds=function(a){return this.frags.getWorldBounds(this.fragId,a)},ab.prototype.getAnimTransform=function(){return this.scale||(this.scale=new THREE.Vector3(1,1,1),this.quaternion=new THREE.Quaternion(0,0,0,1),this.position=new THREE.Vector3(0,0,0)),this.frags.getAnimTransform(this.fragId,this.scale,this.quaternion,this.position)},ab.prototype.updateAnimTransform=function(){this.scale||(this.scale=new THREE.Vector3(1,1,1),this.quaternion=new THREE.Quaternion(0,0,0,1),this.position=new THREE.Vector3(0,0,0)),this.frags.updateAnimTransform(this.fragId,this.scale,this.quaternion,this.position)},ab.prototype.getMaterial=function(){return this.frags.getMaterial(this.fragId)},ab.prototype.setMaterial=function(a){return this.frags.setMaterial(this.fragId,a)};var De={FragmentPointer:ab,FragmentList:Ya},Ee=1,Fe=[1,1,2,4],Ge="\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",He={uniforms:{tDiffuse:{type:"t",value:null},cameraNear:{type:"f",value:1},cameraInvNearFar:{type:"f",value:100},resolution:{type:"v2",value:new THREE.Vector2(1/512,1/512)}},vertexShader:Ge,fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraInvNearFar;\n#include<pack_depth>\nvoid main() {\n    vec2 ssP = vec2(gl_FragCoord.xy);\n    ssP = ssP * 2.0 + mod(ssP, 2.0);\n    ssP = (ssP + 0.5) * resolution * 0.5;\n    float depth = texture2D(tDiffuse, ssP).z;\n    if (depth != 0.0)\n        depth = (depth + cameraNear) * cameraInvNearFar;\n    gl_FragColor = packDepth(depth);\n}\n"},Ie={uniforms:{tDiffuse:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(1/512,1/512)}},vertexShader:Ge,fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvoid main() {\n    vec2 ssP = vec2(gl_FragCoord.xy);\n    ssP = ssP * 2.0 + mod(ssP, 2.0);\n    ssP = (ssP + 0.5) * resolution * 0.5;\n    gl_FragColor = texture2D(tDiffuse, ssP);\n}\n"},Je=new Float32Array(1),Ke=new Uint32Array(Je.buffer),Le=new Uint16Array(1),Me=new Uint16Array(1),Ne=function(a){Je[0]=a;var b=Ke[0],c=0;if(0==(2147483647&b))Me[c++]=b>>16;else{var d=2147483648&b,e=2139095040&b,f=8388607&b;if(0===e)Me[c++]=d>>16;else if(2139095040==e)Me[c++]=0===f?d>>16|31744:65024;else{var g,h,i=d>>16,j=(0|e>>23)-127+15;j>=31?Me[c++]=d>>16|31744:j<=0?(14-j>24?g=0:(f|=8388608,g=f>>14-j,Le[0]=g,g=Le[0],f>>13-j&1&&(g+=1)),Me[c++]=i|g):(h=j<<10,Le[0]=h,h=Le[0],g=f>>13,Le[0]=g,g=Le[0],Me[c++]=4096&f?1+(i|h|g):i|h|g)}}return Me[0]},Oe=function(a){var b,c=65535&a;if(0==(32767&c))b=c<<16;else{var d=32768&c,e=31744&c,f=1023&c;if(0===e){var g=-1;do{g++,f<<=1}while(0==(1024&f));var h=d<<16,i=(e<<16>>26)-15+127-g,j=i<<23,k=(1023&f)<<13;b=h|j|k}else 31744==e?b=0===f?d<<16|2139095040:4290772992:(h=d<<16,i=(e<<16>>26)-15+127,j=i<<23,k=f<<13,b=h|j|k)}return Ke[0]=b,Je[0]},Pe=function(a){if(a>59389||a<0)return THREE.log("out of range"),Ne(NaN);if(0===a)return 0;var b=!1;a>29694&&(b=!0,a-=29694);var c=0|Math.abs(a/1024),d=Math.pow(2,c-13),e=d+(a-1024*c)*d/1024;return b&&(e=-e),Ne(e)},Qe=function(a){if(0===a)return 0;var b=Oe(a),c=!1;b<0&&(c=!0,b=-b);var d=0|Math.floor(Math.log(b)/Math.log(2)),e=Math.pow(2,d),f=(b-e)/e*1024+1024*(d+13);return c&&(f+=29694),f},Re=function(){for(var a=[-1/255,-.17,-75,-1789,-.005],b=0;b<a.length;b++)THREE.log("input",a[b],"encoded",Ne(a[b]),"decoded",Oe(Ne(a[b])));for(var b=0;b<59390;b++){var c=Qe(Pe(b));c!==b&&THREE.log("Roundtrip failed for",b,c)}},Se={FloatToHalf:Ne,HalfToFloat:Oe,HALF_INT_MAX:59390,IntToHalf:Pe,HalfToInt:Qe,HalfTest:Re};db.prototype={constructor:db,copy:function(){return new db(level,x,y)},isValid:function(){return Number.isInteger(this.level)&&this.level>=0&&Number.isInteger(this.x)&&Number.isInteger(this.y)},getChild:function(a){var b=1&a?1:0,c=2&a?1:0;return new db(this.level+1,2*this.x+b,2*this.y+c)},getParent:function(){return 0==this.level?null:new db(this.level-1,Math.floor(this.x/2),Math.floor(this.y/2))},getParentAtLevel:function(a){if(a<0||a>this.level)return null;var b=this.level-a;return new db(a,Math.floor(this.x>>b),Math.floor(this.y>>b))},toString:function(){return"("+this.level+", "+this.x+", "+this.y+")"},equals:function(a,b,c){return a instanceof db?this.equals(a.level,a.x,a.y):this.level===a&&this.x===b&&this.y===c}};var Te=function(a){var b=((1<<2*a.level)-1)/3,c=1<<a.level;return b+a.y*c+a.x},Ue=function(a){for(var b=new db(0,0,0);Te(b)<=a;)b.level++;b.level--;var c=a-Te(b),d=1<<b.level;return b.y=Math.floor(c/d),b.x=c%d,b},Ve={TileCoords:db,tile2Index:Te,index2Tile:Ue},We=function(a){this.elements=a?new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]):new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])};We.prototype={constructor:We,set:function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){var q=this.elements;return q[0]=a,q[4]=b,q[8]=c,q[12]=d,q[1]=e,q[5]=f,q[9]=g,q[13]=h,q[2]=i,q[6]=j,q[10]=k,q[14]=l,q[3]=m,q[7]=n,q[11]=o,q[15]=p,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},copy:function(a){return this.elements.set(a.elements),this},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,i=e+e,j=c*g,k=c*h,l=c*i,m=d*h,n=d*i,o=e*i,p=f*g,q=f*h,r=f*i;return b[0]=1-(m+o),b[4]=k-r,b[8]=l+q,b[1]=k+r,b[5]=1-(j+o),b[9]=n-p,b[2]=l-q,b[6]=n+p,b[10]=1-(j+m),b[3]=0,b[7]=0,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,this},multiply:function(a){return this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],i=c[12],j=c[1],k=c[5],l=c[9],m=c[13],n=c[2],o=c[6],p=c[10],q=c[14],r=c[3],s=c[7],t=c[11],u=c[15],v=d[0],w=d[4],x=d[8],y=d[12],z=d[1],A=d[5],B=d[9],C=d[13],D=d[2],E=d[6],F=d[10],G=d[14],H=d[3],I=d[7],J=d[11],K=d[15];return e[0]=f*v+g*z+h*D+i*H,e[4]=f*w+g*A+h*E+i*I,e[8]=f*x+g*B+h*F+i*J,e[12]=f*y+g*C+h*G+i*K,e[1]=j*v+k*z+l*D+m*H,e[5]=j*w+k*A+l*E+m*I,e[9]=j*x+k*B+l*F+m*J,e[13]=j*y+k*C+l*G+m*K,e[2]=n*v+o*z+p*D+q*H,e[6]=n*w+o*A+p*E+q*I,e[10]=n*x+o*B+p*F+q*J,e[14]=n*y+o*C+p*G+q*K,e[3]=r*v+s*z+t*D+u*H,e[7]=r*w+s*A+t*E+u*I,e[11]=r*x+s*B+t*F+u*J,e[15]=r*y+s*C+t*G+u*K,this},multiplyToArray:function(a,b,c){var d=this.elements;return this.multiplyMatrices(a,b),c[0]=d[0],c[1]=d[1],c[2]=d[2],c[3]=d[3],c[4]=d[4],c[5]=d[5],c[6]=d[6],c[7]=d[7],c[8]=d[8],c[9]=d[9],c[10]=d[10],c[11]=d[11],c[12]=d[12],c[13]=d[13],c[14]=d[14],c[15]=d[15],this},multiplyScalar:function(a){var b=this.elements;return b[0]*=a,b[4]*=a,b[8]*=a,b[12]*=a,b[1]*=a,b[5]*=a,b[9]*=a,b[13]*=a,b[2]*=a,b[6]*=a,b[10]*=a,b[14]*=a,b[3]*=a,b[7]*=a,b[11]*=a,b[15]*=a,this},determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],i=a[13],j=a[2],k=a[6],l=a[10],m=a[14];return a[3]*(+e*h*k-d*i*k-e*g*l+c*i*l+d*g*m-c*h*m)+a[7]*(+b*h*m-b*i*l+e*f*l-d*f*m+d*i*j-e*h*j)+a[11]*(+b*i*k-b*g*m-e*f*k+c*f*m+e*g*j-c*i*j)+a[15]*(-d*g*j-b*h*k+b*g*l+d*f*k-c*f*l+c*h*j)},transpose:function(){var a,b=this.elements;return a=b[1],b[1]=b[4],b[4]=a,a=b[2],b[2]=b[8],b[8]=a,a=b[6],b[6]=b[9],b[9]=a,a=b[3],b[3]=b[12],b[12]=a,a=b[7],b[7]=b[13],b[13]=a,a=b[11],b[11]=b[14],b[14]=a,this},flattenToArrayOffset:function(a,b){var c=this.elements;return a[b]=c[0],a[b+1]=c[1],a[b+2]=c[2],a[b+3]=c[3],a[b+4]=c[4],a[b+5]=c[5],a[b+6]=c[6],a[b+7]=c[7],a[b+8]=c[8],a[b+9]=c[9],a[b+10]=c[10],a[b+11]=c[11],a[b+12]=c[12],a[b+13]=c[13],a[b+14]=c[14],a[b+15]=c[15],a},setPosition:function(a){var b=this.elements;return b[12]=a.x,b[13]=a.y,b[14]=a.z,this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],i=d[1],j=d[5],k=d[9],l=d[13],m=d[2],n=d[6],o=d[10],p=d[14],q=d[3],r=d[7],s=d[11],t=d[15];c[0]=k*p*r-l*o*r+l*n*s-j*p*s-k*n*t+j*o*t,c[4]=h*o*r-g*p*r-h*n*s+f*p*s+g*n*t-f*o*t,c[8]=g*l*r-h*k*r+h*j*s-f*l*s-g*j*t+f*k*t,c[12]=h*k*n-g*l*n-h*j*o+f*l*o+g*j*p-f*k*p,c[1]=l*o*q-k*p*q-l*m*s+i*p*s+k*m*t-i*o*t,c[5]=g*p*q-h*o*q+h*m*s-e*p*s-g*m*t+e*o*t,c[9]=h*k*q-g*l*q-h*i*s+e*l*s+g*i*t-e*k*t,c[13]=g*l*m-h*k*m+h*i*o-e*l*o-g*i*p+e*k*p,c[2]=j*p*q-l*n*q+l*m*r-i*p*r-j*m*t+i*n*t,c[6]=h*n*q-f*p*q-h*m*r+e*p*r+f*m*t-e*n*t,c[10]=f*l*q-h*j*q+h*i*r-e*l*r-f*i*t+e*j*t,c[14]=h*j*m-f*l*m-h*i*n+e*l*n+f*i*p-e*j*p,c[3]=k*n*q-j*o*q-k*m*r+i*o*r+j*m*s-i*n*s,c[7]=f*o*q-g*n*q+g*m*r-e*o*r-f*m*s+e*n*s,c[11]=g*j*q-f*k*q-g*i*r+e*k*r+f*i*s-e*j*s,c[15]=f*k*m-g*j*m+g*i*n-e*k*n-f*i*o+e*j*o;var u=e*c[0]+i*c[4]+m*c[8]+q*c[12];if(0==u){var v="Matrix4.getInverse(): can't invert matrix, determinant is 0";if(b)throw new Error(v);return console.warn(v),this.identity(),this}return this.multiplyScalar(1/u),this},scale:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z;return b[0]*=c,b[4]*=d,b[8]*=e,b[1]*=c,b[5]*=d,b[9]*=e,b[2]*=c,b[6]*=d,b[10]*=e,b[3]*=c,b[7]*=d,b[11]*=e,this},makeTranslation:function(a,b,c){return this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1),this},makeRotationX:function(a){var b=Math.cos(a),c=Math.sin(a);return this.set(1,0,0,0,0,b,-c,0,0,c,b,0,0,0,0,1),this},makeRotationY:function(a){var b=Math.cos(a),c=Math.sin(a);return this.set(b,0,c,0,0,1,0,0,-c,0,b,0,0,0,0,1),this},makeRotationZ:function(a){var b=Math.cos(a),c=Math.sin(a);return this.set(b,-c,0,0,c,b,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,i=e*f,j=e*g;return this.set(i*f+c,i*g-d*h,i*h+d*g,0,i*g+d*h,j*g+c,j*h-d*f,0,i*h-d*g,j*h+d*f,e*h*h+c,0,0,0,0,1),this},makeScale:function(a,b,c){return this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1),this},compose:function(a,b,c){return this.makeRotationFromQuaternion(b),this.scale(c),this.setPosition(a),this},transformPoint:function(a){var b=a.x,c=a.y,d=a.z,e=this.elements;return a.x=e[0]*b+e[4]*c+e[8]*d+e[12],a.y=e[1]*b+e[5]*c+e[9]*d+e[13],a.z=e[2]*b+e[6]*c+e[10]*d+e[14],a},transformDirection:function(a){var b=a.x,c=a.y,d=a.z,e=this.elements;a.x=e[0]*b+e[4]*c+e[8]*d,a.y=e[1]*b+e[5]*c+e[9]*d,a.z=e[2]*b+e[6]*c+e[10]*d;var f=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);if(f>0){var g=1/f;a.x*=g,a.y*=g,a.z*=g}return a},fromArray:function(a){return this.elements.set(a),this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){return new We(this.elements instanceof Float64Array).fromArray(this.elements)}};var Xe=Ve,Ye=0,Ze=1,$e=2,_e=function(a,b){this.timeStamp=a,this.mesh=b,this.state=Ye},af={ModelIteratorTexQuad:hb,TexQuadConfig:gb},bf={LEAF_OBJECT:0,FIRST_OBJECT:1,LAST_OBJECT:2};ib.prototype.setFlagNode=function(a,b,c){var d=this.nodeAccess.getNodeFlags(a);return!!(d&b)!=c&&(c?this.nodeAccess.setNodeFlags(a,d|b):this.nodeAccess.setNodeFlags(a,d&~b),!0)},ib.prototype.setFlagGlobal=function(a,b){var c=this.nodeAccess,d=0,e=c.numNodes;if(b)for(;d<e;d++)c.setNodeFlags(d,c.getNodeFlags(d)|a);else for(var f=~a;d<e;d++)c.setNodeFlags(d,c.getNodeFlags(d)&f)},ib.prototype.setNodeOff=function(a,b){var c=this.setFlagNode(a,1073741824,b);return c&&(b?this.numOff++:this.numOff--),c},ib.prototype.isNodeOff=function(a){return!!(1073741824&this.nodeAccess.getNodeFlags(a))},ib.prototype.setNodeHidden=function(a,b){var c=this.setFlagNode(a,2147483648,b);return c&&(b?this.numHidden++:this.numHidden--),c},ib.prototype.isNodeHidden=function(a){return!!(2147483648&this.nodeAccess.getNodeFlags(a))},ib.prototype.getNodeType=function(a){return 7&this.nodeAccess.getNodeFlags(a)},ib.prototype.isNodeSelectable=function(a){return!(536870912&this.nodeAccess.getNodeFlags(a))},ib.prototype.getNodeParentId=function(a){return this.nodeAccess.getParentId(a)},ib.prototype.getRootId=function(){return this.nodeAccess.rootId},ib.prototype.getNodeName=function(a){return this.nodeAccess.name(a)},ib.prototype.getChildCount=function(a){return this.nodeAccess.getNumChildren(a)},ib.prototype.getNodeBox=function(a,b){this.nodeAccess.getNodeBox(a,b)},ib.prototype.getNodeIndex=function(a){return this.nodeAccess.getIndex(a)},ib.prototype.enumNodeFragments=function(a,b,c){function d(a){f.nodeAccess.enumNodeFragments(a,b),c&&f.enumNodeChildren(a,function(a){d(a)})}var e;"number"==typeof a?e=a:a&&(e=a.dbId);var f=this;d(e)},ib.prototype.enumNodeChildren=function(a,b,c){function d(a){f.nodeAccess.enumNodeChildren(a,function(a){b(a),c&&d(a)})}var e;"number"==typeof a?e=a:a&&(e=a.dbId);var f=this;c&&b(e),d(e)},ib.prototype.findNodeForSelection=function(a,b){if(b===bf.LEAF_OBJECT)return a;var c,d,e=a;if(b===bf.FIRST_OBJECT){var f=[];for(c=a;c;)f.push(c),c=this.getNodeParentId(c);for(var g=f.length-1;g>=0;g--)if(5!==(d=this.getNodeType(f[g]))&&2!==d&&3!==d){e=f[g];break}}else if(b===bf.LAST_OBJECT)for(c=a;c;){if(4===(d=this.getNodeType(c))){e=c;break}c=this.getNodeParentId(c)}return e};var cf=16777216,df=33554432,ef=16777215,ff=-1<<30,gf=5;kb.prototype.getIndex=function(a){var b=this.dbIdToIndex[a];if(b)return b;b=this.nextNode++,this.nodes.push(a);for(var c=1;c<gf;c++)this.nodes.push(0);return this.dbIdToIndex[a]=b,b},kb.prototype.setNode=function(a,b,c,d,e,f){var g=this.getIndex(a),h=g*gf,i=e.length,j=f&&f.length;j&&(i+=f.length),this.nodes[h+1]=b,this.nodes[h+2]=this.nextChild,this.nodes[h+3]=j?-i:i,this.nodes[h+4]=d;var k;for(k=0;k<e.length;k++)this.children[this.nextChild++]=this.getIndex(e[k]);if(j)for(k=0;k<f.length;k++)this.children[this.nextChild++]=-f[k]-1;this.nextChild>this.children.length&&console.error("Child index out of bounds -- should not happen"),this.processName(g,c)},kb.prototype.processName=function(a,b){var c,d,e=-1,f=-1;if(b&&(f=b.lastIndexOf("]"),-1!==(e=b.lastIndexOf("["))&&-1!==f||(e=b.lastIndexOf(":"),f=b.length)),e>=0&&f>e){c=b.slice(0,e+1);var g=b.slice(e+1,f);d=parseInt(g,10),d&&d+""===g||(c=b,d=0)}else c=b,d=0;var h=this.s2i[c];void 0===h&&(this.strings.push(c),h=this.strings.length-1,this.s2i[c]=h),this.names[a]=h,this.nameSuffixes[a]=d},kb.prototype.flatten=function(a,b,c,d,e,f){this.nodes=lb(this.nodes),this.children=lb(this.children),this.names=lb(this.names),this.nameSuffixes=lb(this.nameSuffixes),this.s2i=null},mb.prototype.getNumNodes=function(a){return this.numNodes},mb.prototype.getIndex=function(a){return this.dbIdToIndex[a]},mb.prototype.name=function(a){var b=this.dbIdToIndex[a],c=this.strings[this.names[b]],d=this.nameSuffixes[b];if(d){return"["===c.charAt(c.length-1)?c+d+"]":c+d}return c},mb.prototype.getParentId=function(a){return this.nodes[this.dbIdToIndex[a]*gf+1]},mb.prototype.getNodeFlags=function(a){return this.nodes[this.dbIdToIndex[a]*gf+4]},mb.prototype.setNodeFlags=function(a,b){this.nodes[this.dbIdToIndex[a]*gf+4]=b},mb.prototype.getNumChildren=function(a){var b=this.dbIdToIndex[a],c=this.nodes[b*gf+3];if(c>=0)return c;var d=this.nodes[b*gf+2];c=Math.abs(c);for(var e=0,f=0;f<c;f++){if(this.children[d+f]<0)break;e++}return e},mb.prototype.getNumFragments=function(a){var b=this.dbIdToIndex[a],c=this.nodes[b*gf+3];if(c>=0)return 0;var d=this.nodes[b*gf+2];c=Math.abs(c);for(var e=0,f=c-1;f>=0;f--){if(this.children[d+f]>=0)break;e++}return e},mb.prototype.getNodeBox=function(a,b){for(var c=6*this.getIndex(a),d=0;d<6;d++)b[d]=this.nodeBoxes[c+d]},mb.prototype.getVisibleIds=function(){return this.visibleIds||(this.visibleIds=Object.keys(this.dbIdToIndex).map(function(a){return parseInt(a)})),this.visibleIds},mb.prototype.enumNodeChildren=function(a,b){var c=this.dbIdToIndex[a],d=this.nodes[c*gf+2],e=this.nodes[c*gf+3];e=Math.abs(e);for(var f=0;f<e;f++){var g=this.children[d+f];if(g<0)break;b(this.nodes[g*gf+0],a,c)}},mb.prototype.enumNodeFragments=function(a,b){var c=this.dbIdToIndex[a],d=this.nodes[c*gf+2],e=this.nodes[c*gf+3];if(e<0){e=-e;for(var f=0;f<e;f++){var g=this.children[d+f];g>0||b(-g-1,a,c)}}},mb.prototype.computeBoxes=function(a){function b(a,b,c){var f=e.getIndex(a);d(a,f);for(var h=6*c,i=6*f,j=0;j<3;j++)g[h+j]>g[i+j]&&(g[h+j]=g[i+j]),g[h+j+3]<g[i+j+3]&&(g[h+j+3]=g[i+j+3])}function c(b,c,d){for(var e=6*b,f=6*d,h=0;h<3;h++)g[f+h]>a[e+h]&&(g[f+h]=a[e+h]),g[f+h+3]<a[e+h+3]&&(g[f+h+3]=a[e+h+3])}function d(a,d){var f=6*d;g[f]=g[f+1]=g[f+2]=1/0,g[f+3]=g[f+4]=g[f+5]=-1/0,e.getNumChildren(a)&&e.enumNodeChildren(a,b,!0),e.getNumFragments(a)&&e.enumNodeFragments(a,c)}var e=this,f=e.getIndex(e.rootId),g=e.nodeBoxes;d(e.rootId,f)},nb.prototype.setLeftChild=function(a,b){this.nodesI[a*this.node_stride+6]=b},nb.prototype.getLeftChild=function(a){return this.nodesI[a*this.node_stride+6]},nb.prototype.setPrimStart=function(a,b){this.is_lean_node?this.nodesI[a*this.node_stride+6]=b:this.nodesI[a*this.node_stride+8]=b},nb.prototype.getPrimStart=function(a){return this.is_lean_node?this.nodesI[a*this.node_stride+6]:this.nodesI[a*this.node_stride+8]},nb.prototype.setPrimCount=function(a,b){this.nodesS[a*this.node_stride_short+14]=b},nb.prototype.getPrimCount=function(a){return this.nodesS[a*this.node_stride_short+14]},nb.prototype.setFlags=function(a,b,c,d){this.nodesS[a*this.node_stride_short+15]=d<<3|c<<2|3&b},nb.prototype.getFlags=function(a){return this.nodesS[a*this.node_stride_short+15]},nb.prototype.setBox0=function(a,b){var c=a*this.node_stride,d=this.nodesF;d[c]=b[0],d[c+1]=b[1],d[c+2]=b[2],d[c+3]=b[3],d[c+4]=b[4],d[c+5]=b[5]},nb.prototype.getBoxThree=function(a,b){var c=a*this.node_stride,d=this.nodesF;b.min.x=d[c],b.min.y=d[c+1],b.min.z=d[c+2],b.max.x=d[c+3],b.max.y=d[c+4],b.max.z=d[c+5]},nb.prototype.setBoxThree=function(a,b){var c=a*this.node_stride,d=this.nodesF;d[c]=b.min.x,d[c+1]=b.min.y,d[c+2]=b.min.z,d[c+3]=b.max.x,d[c+4]=b.max.y,d[c+5]=b.max.z},nb.prototype.makeEmpty=function(a){var b=a*this.node_stride,c=this.nodesI;c[b+6]=-1,c[b+7]=0,this.is_lean_node||(c[b+8]=-1)},nb.prototype.realloc=function(a){if(this.nodeCount+a>this.nodeCapacity){var b=0|3*this.nodeCapacity/2;b<this.nodeCount+a&&(b=this.nodeCount+a);var c=new ArrayBuffer(b*this.bytes_per_node),d=new Int32Array(c);d.set(this.nodesI),this.nodeCapacity=b,this.nodesRaw=c,this.nodesF=new Float32Array(c),this.nodesI=d,this.nodesS=new Uint16Array(c)}},nb.prototype.nextNodes=function(a){this.realloc(a);var b=this.nodeCount;this.nodeCount+=a;for(var c=0;c<a;c++)this.makeEmpty(b+c);return b},nb.prototype.getRawData=function(){return this.nodesRaw.slice(0,this.nodeCount*this.bytes_per_node)};var hf=3,jf=1e-5,kf=1e-5,lf=15,mf=16,nf=function(){function a(a,b,c,d){a[b]=.5*(c[d]+c[d+3]),a[b+1]=.5*(c[d+1]+c[d+4]),a[b+2]=.5*(c[d+2]+c[d+5])}function b(a,b,c){a[0]>b[c]&&(a[0]=b[c]),a[3]<b[c]&&(a[3]=b[c]),a[1]>b[c+1]&&(a[1]=b[c+1]),a[4]<b[c+1]&&(a[4]=b[c+1]),a[2]>b[c+2]&&(a[2]=b[c+2]),a[5]<b[c+2]&&(a[5]=b[c+2])}function c(a,b,c){a[0]>b[c]&&(a[0]=b[c]),a[1]>b[c+1]&&(a[1]=b[c+1]),a[2]>b[c+2]&&(a[2]=b[c+2]),a[3]<b[c+3]&&(a[3]=b[c+3]),a[4]<b[c+4]&&(a[4]=b[c+4]),a[5]<b[c+5]&&(a[5]=b[c+5])}function d(a,b){a[0]>b[0]&&(a[0]=b[0]),a[1]>b[1]&&(a[1]=b[1]),a[2]>b[2]&&(a[2]=b[2]),a[3]<b[3]&&(a[3]=b[3]),a[4]<b[4]&&(a[4]=b[4]),a[5]<b[5]&&(a[5]=b[5])}function e(a,b,c,d){for(var e=0;e<3;e++)a[b+e]=c[d+3+e]-c[d+e]}function f(a,b){a[0]=b[0],a[1]=b[1],a[2]=b[2],a[3]=b[3],a[4]=b[4],a[5]=b[5]}function g(a){a[0]=s,a[1]=s,a[2]=s,a[3]=-s,a[4]=-s,a[5]=-s}function h(a,b){var c=a[b+3]-a[b],d=a[b+4]-a[b+1],e=a[b+5]-a[b+2];return c<0||d<0||e<0?0:2*(c*d+d*e+e*c)}function i(a){var b=a[3]-a[0],c=a[4]-a[1],d=a[5]-a[2];return b<0||c<0||d<0?0:2*(b*c+c*d+d*b)}function j(){this.vb_left=new Float32Array(6),this.vb_right=new Float32Array(6),this.cb_left=new Float32Array(6),this.cb_right=new Float32Array(6),this.num_left=0,this.best_split=-1,this.best_cost=-1,this.num_bins=-1}function k(){this.box_bbox=new Float32Array(6),this.box_centroid=new Float32Array(6),this.num_prims=0}function l(){this.BL=new Float32Array(6),this.CL=new Float32Array(6),this.NL=0,this.AL=0}function m(a,d,e,f,g,h,i){for(var j=a.centroids,k=a.primitives,l=a.finfo.boxes,m=a.finfo.boxStride,n=i*(1-kf)/h[f],o=g[f],p=a.sort_prims,q=d;q<=e;q++){var r=0|k[q],s=n*(j[3*r+f]-o),t=0|s;t<0?t=0:t>=i&&(t=i-1),p[q]=t,u[t].num_prims++,c(u[t].box_bbox,l,r*m),b(u[t].box_centroid,j,3*r)}}function n(a,b,c,e,g,h,j){if(h[e]<a.scene_epsilon)return void(j.best_cost=1/0);var k=mf;k>c-b+1&&(k=c-b+1);var l;for(l=0;l<k;l++)u[l].reset();for(l=0;l<k-1;l++)v[l].reset();j.num_bins=k,m(a,b,c,e,g,h,k),f(v[0].BL,u[0].box_bbox),f(v[0].CL,u[0].box_centroid),v[0].AL=i(v[0].BL),v[0].NL=u[0].num_prims;var n;for(l=1;l<k-1;l++){n=u[l];var o=v[l];f(o.BL,v[l-1].BL),d(o.BL,n.box_bbox),o.AL=i(o.BL),f(o.CL,v[l-1].CL),d(o.CL,n.box_centroid),o.NL=v[l-1].NL+n.num_prims}l=k-1,f(w,u[l].box_bbox),f(x,u[l].box_centroid);var p=i(w),q=u[l].num_prims,r=l,s=p*q+v[l-1].AL*v[l-1].NL;for(f(j.vb_right,w),f(j.cb_right,u[l].box_centroid),f(j.vb_left,v[l-1].BL),f(j.cb_left,v[l-1].CL),j.num_left=v[l-1].NL,l-=1;l>=1;l--){n=u[l],d(w,n.box_bbox),d(x,n.box_centroid),p=i(w),q+=n.num_prims;var t=p*q+v[l-1].AL*v[l-1].NL;t<=s&&(s=t,r=l,f(j.vb_right,w),f(j.cb_right,x),f(j.vb_left,v[l-1].BL),f(j.cb_left,v[l-1].CL),j.num_left=v[l-1].NL)}j.best_split=r,j.best_cost=s}function o(a,b,c,d,e,f,g){var h,i,j=a.primitives,k=a.sort_prims,l=0,m=0|b,n=0|g.best_split;for(h=b;h<=c;h++){var o=0|j[h];k[h]<n?j[m++]=o:k[l++]=o}for(i=0;i<l;i++)j[m+i]=k[i]}function p(a,c,d,f,h,i,j,k){var l=a.primitives,m=a.centroids,n=h-f+1;n>a.frags_per_inner_node&&(n=a.frags_per_inner_node),n>k&&(n=k),c.setPrimStart(d,f),c.setPrimCount(d,n),f+=n,g(i);for(var o=f;o<=h;o++)b(i,m,3*l[o]);e(j,0,i,0);var p=0;return j[1]>j[0]&&(p=1),j[2]>j[p]&&(p=2),p}function q(a,b,c,d,f,g,h,i){e(y,0,g,0);var k=a.nodes,l=h?a.frags_per_leaf_node_transparent:a.frags_per_leaf_node,m=h?a.frags_per_inner_node_transparent:a.frags_per_inner_node,q=a.max_polys_per_node,r=0;y[1]>y[0]&&(r=1),y[2]>y[r]&&(r=2),k.setBox0(b,f);var s=0,t=0,u=d-c+1;if(a.finfo.hasPolygonCounts&&a.frags_per_inner_node)for(var v=u<=a.frags_per_inner_node?d:c+a.frags_per_inner_node-1,w=c;w<=v&&(s+=a.finfo.getPolygonCount(a.primitives[w]),t++,!(s>q));w++);if(u<=l&&s<q||1===u||i>lf||y[r]<a.scene_epsilon)return k.setLeftChild(b,-1),k.setPrimStart(b,c),k.setPrimCount(b,d-c+1),void k.setFlags(b,0,0,h?1:0);m&&(r=p(a,k,b,c,d,g,y,t),c+=k.getPrimCount(b));var x=new j;if(n(a,c,d,r,g,y,x),x.num_bins<0)return void k.setPrimCount(b,k.getPrimCount(b)+d-c+1);o(a,c,d,r,g,y,x);var z=k.nextNodes(2),A=.5*(x.vb_left[3+r]+x.vb_left[r]),B=.5*(x.vb_right[3+r]+x.vb_right[r]);k.setFlags(b,r,A<B?0:1,h?1:0),k.setLeftChild(b,z),a.recursion_stack.push([a,z+1,c+x.num_left,d,x.vb_right,x.cb_right,h,i+1]),a.recursion_stack.push([a,z,c,c+x.num_left-1,x.vb_left,x.cb_left,h,i+1])}function r(d){var f=d.boxv_o,h=d.boxc_o,i=d.boxv_t,j=d.boxc_t;g(f),g(h),g(i),g(j);for(var k=d.centroids,l=d.finfo.boxes,m=d.finfo.boxStride,n=0,o=d.prim_count;n<o;n++){var p=d.primitives[n];a(k,3*p,l,m*p),n>=d.first_transparent?(b(j,k,3*p),c(i,l,m*p)):(b(h,k,3*p),c(f,l,m*p))}e(y,0,d.boxv_o,0);var q=Math.max(y[0],y[1],y[2]);d.scene_epsilon=jf*q}var s=1/0;j.prototype.reset=function(){this.num_left=0,this.best_split=-1,this.best_cost=-1,this.num_bins=-1},k.prototype.reset=function(){this.num_prims=0,g(this.box_bbox),g(this.box_centroid)},l.prototype.reset=function(){this.NL=0,this.AL=0,g(this.BL),g(this.CL)};var t,u=[];for(t=0;t<mf;t++)u.push(new k);var v=[];for(t=0;t<mf-1;t++)v.push(new l);var w=new Float32Array(6),x=new Float32Array(6),y=new Float32Array(3);return{bvh_subdivide:q,compute_boxes:r,box_area:h}}();ob.prototype.getCount=function(){return this.count},ob.prototype.isTransparent=function(a){return!(!this.materialDefs||!this.materialDefs[this.materials[a]])&&this.materialDefs[this.materials[a]].transparent},ob.prototype.getPolygonCount=function(a){return this.polygonCounts[a]},pb.prototype.sortPrimitives=function(){var a,b,c=new Float32Array(this.work_buf),d=this.primitives,e=0;for(a=0,b=this.prim_count;a<b;a++){d[a]=a;var f=this.finfo.isTransparent(a);f&&e++,c[a]=nf.box_area(this.finfo.boxes,this.finfo.boxStride*a),f&&(c[a]=-c[a])}Array.prototype.sort.call(this.primitives,function(a,b){return c[b]-c[a]}),this.first_transparent=this.prim_count-e},pb.prototype.build=function(a){function b(b,c){a.hasOwnProperty(b)?d[b]=a[b]:d[b]=c}var c=a&&!!a.useSlimNodes,d=this;if(c)b("frags_per_leaf_node",1),b("frags_per_inner_node",0),b("frags_per_leaf_node_transparent",1),b("frags_per_inner_node_transparent",0),b("max_polys_per_node",1/0);else{var e=a.isWeakDevice?.5:1;b("frags_per_leaf_node",0|32*e),b("frags_per_inner_node",0|this.frags_per_leaf_node),b("frags_per_leaf_node_transparent",this.frags_per_leaf_node),b("frags_per_inner_node_transparent",0),b("max_polys_per_node",0|1e4*e)}if(this.nodes&&this.nodes.is_lean_node==c)this.nodes.nodeCount=0;else{for(var f=this.prim_count/this.frags_per_leaf_node,g=1;g<f;)g*=2;this.nodes=new nb(g,!!a&&a.useSlimNodes)}this.sortPrimitives(),nf.compute_boxes(this);var h=this.nodes.nextNodes(2);nf.bvh_subdivide(this,h,0,this.first_transparent-1,this.boxv_o,this.boxc_o,!1,0);for(var i;this.recursion_stack.length;)i=this.recursion_stack.pop(),nf.bvh_subdivide(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7]);for(nf.bvh_subdivide(this,h+1,this.first_transparent,this.prim_count-1,this.boxv_t,this.boxc_t,!0,0);this.recursion_stack.length;)i=this.recursion_stack.pop(),nf.bvh_subdivide(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7])},X(new(function(){function b(){this.callback=function(a,b){},this.level=-1,this.setLevel(a.LogLevels.ERROR)}return b.prototype.initialize=function(a){a&&a.eventCallback&&(this.callback=a.callback)},b.prototype.shutdown=function(){},b.prototype.track=function(a){},b.prototype.logToADP=function(a){return!1},b.prototype.updateRuntimeStats=function(a){},b.prototype.reportRuntimeStats=function(){},b.prototype.setLevel=function(b){function c(){}function d(){var a=Array.prototype.slice.call(arguments).join(" ");e.callback({category:"error",message:a},{adp:!1}),console.error.apply(console,arguments)}if(this.level!==b){this.level=b;var e=this;this.debug=b>=a.LogLevels.DEBUG?console.log.bind(console):c,this.log=b>=a.LogLevels.LOG?console.log.bind(console):c,this.info=b>=a.LogLevels.INFO?console.info.bind(console):c,this.warn=b>=a.LogLevels.WARNING?console.warn.bind(console):c,this.error=b>=a.LogLevels.ERROR?d:c}},b}()))
;var of="varying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvoid computeTangents(vec3 normal, out vec3 u, out vec3 v) {\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e = temp.z;\n    float h = 1.0/(1.0 + e);\n    float hvx = h * temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy, -temp.x);\n    v = vec3(hvxy, e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvoid main() {\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n    vViewPosition = -mvPosition.xyz;\n    vNormal = normalize(normalMatrix * normal);\n    vec3 Tu, Tv;\n    computeTangents(vNormal, Tu, Tv);\n    vTangent = Tu;\n    vBitangent = Tv;\n}\n",pf={uniforms:{surface_albedo:{type:"c",value:new b.Color},surface_roughness:{type:"f",value:0},surface_anisotropy:{type:"f",value:0},surface_rotation:{type:"f",value:0},opaque_albedo:{type:"c",value:new b.Color(.963976,.963976,.954687)},opaque_f0:{type:"f",value:.0529},opaque_luminance_modifier:{type:"c",value:new b.Color},opaque_luminance:{type:"f",value:0}},vertexShader:of,fragmentShader:"varying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#include <common>\n#include <bsdfs>\n#include <lights_pars>\n#include <envmap_pars_fragment>\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\nuniform vec3 opaque_albedo;\nuniform float opaque_f0;\nuniform float opaque_luminance;\nuniform vec3 opaque_luminance_modifier;\nuniform float uEnvExp;\n#if defined(USE_SURFACE_NORMAL_MAP)\nvec3 HeightMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    return normalize(N + (diff.x * T * bumpScale.x + diff.y * B * bumpScale.y));\n}\nvec3 NormalMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 NMap =  2.0 * texture2D( bumpTexture, st ).xyz - 1.0;\n    return normalize(bumpScale.x * (NMap.x * T + NMap.y * B) + NMap.z * N);\n}\n#endif\nvec2 RoughnessToAlpha(float roughness, float anisotropy) {\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nvec3 Fresnel_Schlick(vec3 f0, float cosAngle) {\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 FresnelRough(vec3 f0, float cosAngle, float alpha) {\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\n#if defined(USE_ENVMAP)\nfloat alphaToPhong(float alpha) {\n  return max(0.0, 2.56/alpha - 7.0);\n}\nfloat phongToReflMipIndex(float exponent) {\n  const float EXP_COUNT = 10.0;\n  const float LOG_MIN = 0.0;\n  const float LOG_MAX = 9.0;\n  const float NUM_MIPS = 6.0;\n  float targetLog = log2(exponent);\n  float deltaLog = clamp(targetLog - LOG_MIN, 0.0, LOG_MAX - LOG_MIN);\n  float level = clamp((1.0-(deltaLog + 0.5) / EXP_COUNT), 0.0, 1.0) * NUM_MIPS;\n  return level;\n}\nvec3 decodeRGBM(in vec4 vRGBM) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret / uEnvExp;\n    return ret;\n}\nvec3 sampleReflection(vec3 n, vec3 v, float a) {\n    float mipLevel = phongToReflMipIndex(alphaToPhong(a));\n    v = reflect(-v, n);\n    v = inverseTransformDirection(v, viewMatrix);\n    return decodeRGBM(textureCubeLodEXT(envMap, v, mipLevel));\n}\nuniform samplerCube irrMap;\nvec3 sampleIrradiance(vec3 v) {\n    v = inverseTransformDirection(v, viewMatrix);\n    return decodeRGBM(textureCube(irrMap, v));\n}\nvec3 PrismOpaqueIBL(\n    vec3 N, vec3 V, float NdotV,\n    vec3 surfaceAlbedo,\n    float surfaceRoughness,\n    float opaqueF0,\n    vec3 opaqueAlbedo,\n    float opaqueLuminance,\n    vec3 opaqueLuminanceModifier,\n    float surfaceAnisotropy,\n    float surfaceRotation,\n    vec3 Tu, vec3 Tv\n) {\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = FresnelRough(vec3(opaqueF0), NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, alpha);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n    vec3 envIrradiance = sampleIrradiance(N);\n    vec3 diffuse = (1.0 - F) * opaqueAlbedo * envIrradiance;\n    vec3 emission = opaqueLuminanceModifier * opaqueLuminance;\n    return diffuse + specular + emission;\n}\n#endif\nfloat sqr(float x) {\n    return x * x;\n}\nfloat aSqrd(float maxAlphaSqr, float cosTheta) {\n    if (abs(cosTheta) < 1e-10) {\n        return 1e10;\n    }\n    float tan2 = 1.0/sqr(cosTheta) - 1.0;\n    return maxAlphaSqr * tan2;\n}\nvec3 Rotate(vec3 vec, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\nfloat NDF_GGX(float alphaU, float alphaV, vec3 normal) {\n    float nx2 = sqr(normal.x);\n    float ny2 = sqr(normal.y);\n    float nz2 = sqr(normal.z);\n    float scale = 1.0/(alphaU * alphaV * PI);\n    return scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);\n}\nfloat G1_GGX(float aSqrd) {\n    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\nvec3 MicrofacetLobe(\n    vec3 Hlocal,\n    float NdotL,\n    float NdotH,\n    float NdotV,\n    float VdotH,\n    float roughness,\n    float anisotropy,\n    float rotation,\n    vec3 reflectance\n) {\n    vec2 alpha = RoughnessToAlpha(roughness, anisotropy);\n    Hlocal = Rotate(Hlocal, rotation);\n    vec3 F = Fresnel_Schlick(reflectance, VdotH);\n    float D = NDF_GGX(alpha.x, alpha.y, Hlocal);\n    float alpha2 = max(sqr(alpha.x), sqr(alpha.y));\n    float alpha2NL = aSqrd(alpha2, NdotL);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    float G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);\n    return max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));\n}\nvec3 DiffuseLobe(vec3 diffuseColor) {\n    return diffuseColor * RECIPROCAL_PI;\n}\nvec3 PrismOpaqueBRDF(\n    vec3 Hlocal,\n    float NdotL,\n    float NdotH,\n    float NdotV,\n    float VdotH,\n    vec3 surfaceAlbedo,\n    float surfaceRoughness,\n    float surfaceAnisotropy,\n    float surfaceRotation,\n    float opaqueF0,\n    vec3 opaqueAlbedo\n) {\n    vec3 diffuse = DiffuseLobe(opaqueAlbedo);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n        Hlocal,\n        NdotL,\n        NdotH,\n        NdotV,\n        VdotH,\n        surfaceRoughness,\n        surfaceAnisotropy,\n        surfaceRotation,\n        vec3(opaqueF0)\n    );\n    return (specular + diffuse) * NdotL;\n}\nvec3 getDiscreteLightRadiance(\n    GeometricContext geometry,\n    float NdotV, vec3 Tu, vec3 Tv,\n    vec3 surfaceAlbedo,\n    float surfaceRoughness,\n    float surfaceAnisotropy,\n    float surfaceRotation,\n    float opaqueF0,\n    vec3 opaqueAlbedo\n) {\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    IncidentLight directLight;\n    vec3 accumLight;\n#define ACCUM_LIGHT { vec3 L = directLight.direction; float NdotL = max(0.0, dot(N, L)); vec3 H = normalize(L + V); float NdotH = dot(N, H); float VdotH = dot(V, H); float Hu = dot(H, Tu); float Hv = dot(H, Tv); vec3 Hlocal = vec3(Hu, Hv, NdotH); accumLight += directLight.color * PrismOpaqueBRDF(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, opaqueF0, opaqueAlbedo ); }\n#if NUM_DIR_LIGHTS > 0\n    for (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n        DirectionalLight directionalLight = directionalLights[i];\n        getDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n        ACCUM_LIGHT\n    }\n#endif\n#if NUM_POINT_LIGHTS > 0\n    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n        PointLight pointLight = pointLights[i];\n        getPointDirectLightIrradiance(pointLight, geometry, directLight);\n        ACCUM_LIGHT\n    }\n#endif\n#if (NUM_SPOT_LIGHTS > 0)\n    for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n        SpotLight spotLight = spotLights[i];\n        getSpotDirectLightIrradiance(spotLight, geometry, directLight);\n        ACCUM_LIGHT\n    }\n#endif\n    return accumLight;\n}\nvoid main() {\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(vViewPosition);\n    float NdotV = clamp(dot(N, V), 0.0, 1.0);\n    vec3 Tu = normalize(vTangent);\n    vec3 Tv = normalize(vBitangent);\n#if defined(USE_MAP)\n    vec3 q0 = dFdx(-vViewPosition);\n    vec3 q1 = dFdy(-vViewPosition);\n    vec2 st0 = dFdx(vUv);\n    vec2 st1 = dFdy(vUv);\n    Tu = normalize(q0 * st1.t - q1 * st0.t);\n    Tv = normalize(-q0 * st1.s + q1 * st0.s);\n#if defined(USE_SURFACE_NORMAL_MAP)\n    if (surface_normal_map_bumpmapType == 0) {\n        N = HeightMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    } else {\n        N = NormalMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    }\n#endif\n#endif\n    GeometricContext geometry;\n    geometry.position = -vViewPosition;\n    geometry.normal = N;\n    geometry.viewDir = V;\n    vec3 outRadiance = vec3(0.0);\n    outRadiance += getDiscreteLightRadiance(\n        geometry,\n        NdotV, Tu, Tv,\n        surface_albedo,\n        surface_roughness,\n        surface_anisotropy,\n        surface_rotation,\n        opaque_f0,\n        opaque_albedo\n    );\n#if defined(USE_ENVMAP)\n    outRadiance += PrismOpaqueIBL(\n        N, V, NdotV,\n        surface_albedo,\n        surface_roughness,\n        opaque_f0,\n        opaque_albedo,\n        opaque_luminance,\n        opaque_luminance_modifier,\n        surface_anisotropy,\n        surface_rotation,\n        Tu, Tv\n    );\n#endif\n    outRadiance *= uEnvExp;\n    outRadiance = toneMapping(outRadiance);\n    gl_FragColor = LinearToGamma(vec4(outRadiance, 1.0), float(GAMMA_FACTOR));\n}\n"},qf={uniforms:{surface_albedo:{type:"c",value:new b.Color},surface_roughness:{type:"f",value:0},surface_anisotropy:{type:"f",value:0},surface_rotation:{type:"f",value:0},metal_f0:{type:"c",value:new b.Color(.963976,.963976,.954687)}},vertexShader:of,fragmentShader:"varying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#include <common>\n#include <bsdfs>\n#include <lights_pars>\n#include <envmap_pars_fragment>\nuniform float uEnvExp;\nvec3 decodeRGBM(in vec4 vRGBM) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret / uEnvExp;\n    return ret;\n}\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\nuniform vec3 metal_f0;\n#if defined(USE_SURFACE_NORMAL_MAP)\nvec3 HeightMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    return normalize(N + (diff.x * T * bumpScale.x + diff.y * B * bumpScale.y));\n}\nvec3 NormalMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 NMap =  2.0 * texture2D( bumpTexture, st ).xyz - 1.0;\n    return normalize(bumpScale.x * (NMap.x * T + NMap.y * B) + NMap.z * N);\n}\n#endif\nvec2 RoughnessToAlpha(float roughness, float anisotropy) {\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nvec3 Fresnel_Schlick(vec3 f0, float cosAngle) {\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 FresnelRough(vec3 f0, float cosAngle, float alpha) {\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\n#if defined(USE_ENVMAP)\nfloat alphaToPhong(float alpha) {\n  return max(0.0, 2.56/alpha - 2.56);\n}\nfloat phongToReflMipIndex(float exponent) {\n  const float EXP_COUNT = 10.0;\n  const float LOG_MIN = 0.0;\n  const float LOG_MAX = 9.0;\n  const float NUM_MIPS = 6.0;\n  float targetLog = log2(exponent);\n  float deltaLog = clamp(targetLog - LOG_MIN, 0.0, LOG_MAX - LOG_MIN);\n  float level = clamp((1.0-(deltaLog + 0.5) / EXP_COUNT), 0.0, 1.0) * NUM_MIPS;\n  return level;\n}\nvec3 sampleReflection(vec3 n, vec3 v, float a) {\n    float mipLevel = phongToReflMipIndex(alphaToPhong(a));\n    v = reflect(-v, n);\n    v = inverseTransformDirection(v, viewMatrix);\n    return decodeRGBM(textureCubeLodEXT(envMap, v, mipLevel));\n}\nvec3 PrismMetalIBL(\n    vec3 N, vec3 V, float NdotV,\n    vec3 surfaceAlbedo,\n    float surfaceRoughness,\n    vec3 metalF0,\n    float surfaceAnisotropy,\n    float surfaceRotation,\n    vec3 Tu, vec3 Tv\n) {\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    vec3 F = FresnelRough(metalF0, NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, alpha);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n    return specular;\n}\n#endif\nfloat sqr(float x) {\n    return x * x;\n}\nfloat aSqrd(float maxAlphaSqr, float cosTheta) {\n    if (abs(cosTheta) < 1e-10) {\n        return 1e10;\n    }\n    float tan2 = 1.0/sqr(cosTheta) - 1.0;\n    return maxAlphaSqr * tan2;\n}\nvec3 Rotate(vec3 vec, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\nfloat NDF_GGX(float alphaU, float alphaV, vec3 normal) {\n    float nx2 = sqr(normal.x);\n    float ny2 = sqr(normal.y);\n    float nz2 = sqr(normal.z);\n    float scale = 1.0/(alphaU * alphaV * PI);\n    return scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);\n}\nfloat G1_GGX(float aSqrd) {\n    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\nvec3 MicrofacetLobe(\n    vec3 Hlocal,\n    float NdotL,\n    float NdotH,\n    float NdotV,\n    float VdotH,\n    float roughness,\n    float anisotropy,\n    float rotation,\n    vec3 reflectance\n) {\n    vec2 alpha = RoughnessToAlpha(roughness, anisotropy);\n    Hlocal = Rotate(Hlocal, rotation);\n    vec3 F = Fresnel_Schlick(reflectance, VdotH);\n    float D = NDF_GGX(alpha.x, alpha.y, Hlocal);\n    float alpha2 = max(sqr(alpha.x), sqr(alpha.y));\n    float alpha2NL = aSqrd(alpha2, NdotL);\n    float alpha2NV = aSqrd(alpha2, NdotV);\n    float G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);\n    return max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));\n}\nvec3 PrismMetalBRDF(\n    vec3 Hlocal,\n    float NdotL,\n    float NdotH,\n    float NdotV,\n    float VdotH,\n    vec3 surfaceAlbedo,\n    float surfaceRoughness,\n    float surfaceAnisotropy,\n    float surfaceRotation,\n    vec3 metalF0\n) {\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n        Hlocal,\n        NdotL,\n        NdotH,\n        NdotV,\n        VdotH,\n        surfaceRoughness,\n        surfaceAnisotropy,\n        surfaceRotation,\n        metalF0\n    );\n    return specular * NdotL;\n}\nvec3 getDiscreteLightRadiance(\n    GeometricContext geometry,\n    float NdotV, vec3 Tu, vec3 Tv,\n    vec3 surfaceAlbedo,\n    float surfaceRoughness,\n    float surfaceAnisotropy,\n    float surfaceRotation,\n    vec3 metalF0\n) {\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    IncidentLight directLight;\n    vec3 accumLight;\n#define ACCUM_LIGHT { vec3 L = directLight.direction; float NdotL = max(0.0, dot(N, L)); vec3 H = normalize(L + V); float NdotH = dot(N, H); float VdotH = dot(V, H); float Hu = dot(H, Tu); float Hv = dot(H, Tv); vec3 Hlocal = vec3(Hu, Hv, NdotH); accumLight += directLight.color * PrismMetalBRDF(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, metalF0); }\n#if NUM_DIR_LIGHTS > 0\n    for (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n        DirectionalLight directionalLight = directionalLights[i];\n        getDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n        ACCUM_LIGHT\n    }\n#endif\n#if NUM_POINT_LIGHTS > 0\n    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n        PointLight pointLight = pointLights[i];\n        getPointDirectLightIrradiance(pointLight, geometry, directLight);\n        ACCUM_LIGHT\n    }\n#endif\n#if (NUM_SPOT_LIGHTS > 0)\n    for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n        SpotLight spotLight = spotLights[i];\n        getSpotDirectLightIrradiance(spotLight, geometry, directLight);\n        ACCUM_LIGHT\n    }\n#endif\n    return accumLight;\n}\nvoid main() {\n    vec3 N = normalize(vNormal);\n    vec3 V = normalize(vViewPosition);\n    float NdotV = clamp(dot(N, V), 0.0, 1.0);\n    vec3 Tu = normalize(vTangent);\n    vec3 Tv = normalize(vBitangent);\n#if defined(USE_MAP)\n    vec3 q0 = dFdx(-vViewPosition);\n    vec3 q1 = dFdy(-vViewPosition);\n    vec2 st0 = dFdx(vUv);\n    vec2 st1 = dFdy(vUv);\n    Tu = normalize(q0 * st1.t - q1 * st0.t);\n    Tv = normalize(-q0 * st1.s + q1 * st0.s);\n#if defined(USE_SURFACE_NORMAL_MAP)\n    if (surface_normal_map_bumpmapType == 0) {\n        N = HeightMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    } else {\n        N = NormalMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n    }\n#endif\n#endif\n    GeometricContext geometry;\n    geometry.position = -vViewPosition;\n    geometry.normal = N;\n    geometry.viewDir = V;\n    vec3 outRadiance = vec3(0.0);\n    outRadiance += getDiscreteLightRadiance(\n        geometry,\n        NdotV, Tu, Tv,\n        surface_albedo,\n        surface_roughness,\n        surface_anisotropy,\n        surface_rotation,\n        metal_f0\n    );\n#if defined(USE_ENVMAP)\n    outRadiance += PrismMetalIBL(\n        N, V, NdotV,\n        surface_albedo,\n        surface_roughness,\n        metal_f0,\n        surface_anisotropy,\n        surface_rotation,\n        Tu, Tv\n    );\n#endif\n    outRadiance *= uEnvExp;\n    outRadiance = toneMapping(outRadiance);\n    gl_FragColor = LinearToGamma(vec4(outRadiance, 1.0), float(GAMMA_FACTOR));\n}\n"},rf={uniforms:{surface_albedo:{type:"c",value:new b.Color},surface_roughness:{type:"f",value:.12247},surface_anisotropy:{type:"f",value:0},surface_rotation:{type:"f",value:0},layered_f0:{type:"f",value:.0603},layered_diffuse:{type:"c",value:new b.Color(.9673,.9556,.9137)},layered_fraction:{type:"f",value:.25},layered_bottom_f0:{type:"c",value:new b.Color(.9673,.9556,.9137)},layered_roughness:{type:"f",value:0},layered_anisotropy:{type:"f",value:0},layered_rotation:{type:"f",value:0}},vertexShader:of,fragmentShader:"varying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n#include <common>\n#include <envmap_pars_fragment>\nuniform float uEnvExp;\nvec3 decodeRGBM(in vec4 vRGBM) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret / uEnvExp;\n    return ret;\n}\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\nuniform float layered_f0;\nuniform vec3 layered_diffuse;\nuniform float layered_fraction;\nuniform vec3 layered_bottom_f0;\nuniform float layered_roughness;\nuniform float layered_anisotropy;\nuniform float layered_rotation;\n#if defined(USE_SURFACE_NORMAL_MAP)\nvec3 HeightMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    return normalize(N + (diff.x * T * bumpScale.x + diff.y * B * bumpScale.y));\n}\nvec3 NormalMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 NMap =  2.0 * texture2D( bumpTexture, st ).xyz - 1.0;\n    return normalize(bumpScale.x * (NMap.x * T + NMap.y * B) + NMap.z * N);\n}\n#endif\nvec3 sampleReflection(vec3 n, vec3 v, float mipIndex) {\n    vec3 dir = (2.0 * dot(v, n)) * n - v;\n    dir = inverseTransformDirection(dir, viewMatrix);\n    vec4 sample = textureCubeLodEXT(envMap, dir, mipIndex);\n    return decodeRGBM(sample);\n}\n#define IRR_MIP 10.0\nvec3 sampleIrradiance(vec3 v) {\n    vec4 sample = textureCubeLodEXT(envMap, v, IRR_MIP);\n    return decodeRGBM(sample);\n}\nfloat RoughnessToMip(float roughness) {\n    return max(0.0, 1.38507369694 * log(35.251095837 * roughness));\n}\nvec2 RoughnessToAlpha(float roughness, float anisotropy) {\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nvec3 FresnelRough(vec3 f0, float cosAngle, float alpha) {\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\nvec3 FresnelSchlick(vec3 f0, float cosAngle) {\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 PrismLayeredIBL(vec3 N, vec3 V, float NdotV, vec3 N2, float N2dotV, vec3 surfaceAlbedo, float surfaceRoughness,\n        float layeredF0, float surfaceAnisotropy, float surfaceRotation, vec3 Tu, vec3 Tv, vec3 layeredDiffuse, float layeredRoughness,\n        float layeredAnisotropy, float layeredRotation, vec3 bottomF0, float layeredFraction) {\n    vec3 F = FresnelSchlick(vec3(layeredF0), NdotV);\n    float reflMipIndex = RoughnessToMip(surfaceRoughness);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 topSpecular = F * surfaceAlbedo * envSpecular;\n    vec3 amount = (1.0 - F);\n    vec3 envIrradiance = sampleIrradiance(N);\n    vec3 topDiffuse = layeredDiffuse * envIrradiance;\n    float alpha = RoughnessToAlpha(layeredRoughness, 0.0).x;\n    reflMipIndex = RoughnessToMip(layeredRoughness);\n    envSpecular = sampleReflection(N2, V, reflMipIndex);\n    F = FresnelRough(bottomF0, N2dotV, alpha);\n    vec3 botSpecular = F * envSpecular;\n    return topSpecular + amount * mix(topDiffuse, botSpecular, layeredFraction);\n}\nvoid main() {\n    vec3 n = normalize(vNormal);\n    vec3 v = normalize(vViewPosition);\n    vec3 q0 = dFdx(-vViewPosition);\n    vec3 q1 = dFdy(-vViewPosition);\n    vec2 st0 = dFdx(vUv);\n    vec2 st1 = dFdy(vUv);\n    vec3 tu = normalize(q0 * st1.t - q1 * st0.t);\n    vec3 tv = normalize(-q0 * st1.s + q1 * st0.s);\n#if defined(USE_SURFACE_NORMAL_MAP)\n    if (surface_normal_map_bumpmapType == 0) {\n        n = HeightMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, tu, tv, n);\n    } else {\n        n = NormalMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, tu, tv, n);\n    }\n#endif\n    float ndotv = clamp(dot(n, v), 0.0, 1.0);\n    vec3 outRadianceEnv = PrismLayeredIBL(\n        n, v, ndotv, n, ndotv,\n        surface_albedo,\n        surface_roughness,\n        layered_f0,\n        surface_anisotropy,\n        surface_rotation,\n        tu, tv,\n        layered_diffuse,\n        layered_roughness,\n        layered_anisotropy,\n        layered_rotation,\n        layered_bottom_f0,\n        layered_fraction\n    );\n    outRadianceEnv *= uEnvExp;\n    outRadianceEnv = toneMapping(outRadianceEnv);\n    gl_FragColor = LinearToGamma(vec4(outRadianceEnv, 1.0), float(GAMMA_FACTOR));\n}\n"},sf={opaque:pf,metal:qf,layered:rf},tf={uniforms:{uEnvExp:{type:"f",value:1}},extensions:{derivatives:!0,shaderTextureLOD:!0}},uf=function(a){function b(b){var c=sf[b]||pf,d=Object.assign({},tf,c);return d.uniforms=THREE.UniformsUtils.merge([tf.uniforms,c.uniforms]),a.call(this,d)||this}return c(b,a),Object.defineProperty(b.prototype,"lights",{get:function(){return a.prototype.lights},set:function(b){b&&(this.uniforms=THREE.UniformsUtils.merge([this.uniforms,THREE.UniformsLib.ambient,THREE.UniformsLib.lights])),a.prototype.lights=b},enumerable:!0,configurable:!0}),b}(b.ShaderMaterial),vf=function(a,b){var c=[6.0014,-2.7008,-1.7996,-1.332,3.1029,-5.7721,.3008,-1.0882,5.6268],d=255*a[2]+a[3],e=Math.pow(2,(d-127)/2),f=e/a[1],g=a[0]*f,h=c[0]*g+c[3]*e+c[6]*f,i=c[1]*g+c[4]*e+c[7]*f,j=c[2]*g+c[5]*e+c[8]*f;h<0&&(h=0),i<0&&(i=0),j<0&&(j=0),b[0]=h,b[1]=i,b[2]=j},wf=function(a,b,c){var d=Math.sqrt(a[0]*c)*(1/16),e=Math.sqrt(a[1]*c)*(1/16),f=Math.sqrt(a[2]*c)*(1/16),g=Math.min(Math.max(Math.max(d,e),Math.max(f,1e-6)),1);g=Math.ceil(255*g)/255,b[0]=d/g,b[1]=e/g,b[2]=f/g,b[3]=g},xf=function(a,b){for(var c=new Float32Array(4),d=new Float32Array(4),e=0;e<a.image.length;e++)for(var f=a.image[e],g=0;g<f.mipmaps.length;g++)for(var h=f.mipmaps[g].data,i=0;i<h.length;i+=4)c[0]=h[i]/255,c[1]=h[i+1]/255,c[2]=h[i+2]/255,c[3]=h[i+3]/255,vf(c,d),wf(d,c,b),h[i]=Math.round(255*c[0]),h[i+1]=Math.round(255*c[1]),h[i+2]=Math.round(255*c[2]),h[i+3]=Math.round(255*c[3])},yf=function(a,c){return new Promise(function(d,e){var f=new THREE.DDSLoader,g=new b.CubeTexture;g.format=b.RGBAFormat,g.encoding=b.LinearEncoding,g.mapping=b.CubeReflectionMapping,g.isCompressedTexture=!0,g.generateMipmaps=!1;var h=Math.pow(2,c);f.load(a,function(a){xf(a,h);for(var b=0;b<a.image.length;b++)g.image[b]=a.image[b];g.minFilter=g.image[0].mipmaps.length>1?g.minFilter:THREE.LinearFilter,g.needsUpdate=!0,d(g)},function(){},function(a){e(new Error("environment map load failed"))})})},zf=function(a,b,c,d){return Promise.all([yf(b,d),yf(c,d)]).then(function(b){var c=b[0],e=b[1];return a.envMap=c,a.uniforms.envMap={value:c},a.uniforms.irrMap={value:e},a.uniforms.uEnvExp={value:Math.pow(2,d)},a.needsUpdate=!0,{specMap:c,irrMap:e}})},Af={Riverbank:{name:"Riverbank",path:"riverbank",exposure:-5.7},Contrast:{name:"Contrast",path:"IDViz",exposure:0},"Rim Highlights":{name:"Rim Highlights",path:"RimHighlights",exposure:-9},"Cool Light":{name:"Cool Light",path:"CoolLight",exposure:-9},"Warm Light":{name:"Warm Light",path:"WarmLight",exposure:-9},"Soft Light":{name:"Soft Light",path:"SoftLight",exposure:-9},"Grid Light":{name:"Grid Light",path:"GridLight",exposure:-9},Plaza:{name:"Plaza",path:"Plaza",exposure:-14},"Snow Field":{name:"Snow Field",path:"SnowField",exposure:-10.461343},Field:{name:"Field",path:"field",exposure:-2.9},Boardwalk:{name:"Boardwalk",path:"boardwalk",exposure:-7},Crossroads:{name:"Crossroads",path:"crossroads",exposure:-5.5},Seaport:{name:"Seaport",path:"seaport",exposure:-6.5},Glacier:{name:"Glacier",path:"glacier",exposure:0},"RaaS Test Env":{name:"RaaS Test Env",path:"Reflection",exposure:-1.5}},Bf="https://autodeskviewer.com/viewers/latest/res/environments/",Cf=function(a,b,c){var d=Af[a];return d?zf(b,Bf+d.path+"_mipdrop.logluv.dds",Bf+d.path+"_irr.logluv.dds",d.exposure).then(function(a){return c.background=a.specMap,a}):Promise.reject(new Error("Preset does not exist: "+a))},Df={fragmentShader:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvec3 decodeRGBM(in vec4 vRGBM) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    return ret;\n}\nvoid main() {\n    vec4 texel = textureCube(tCube, vWorldPosition.xyz);\n    vec3 color = toneMapping(decodeRGBM(texel));\n    gl_FragColor = vec4(color, opacity);\n    gl_FragColor = LinearToGamma(gl_FragColor, float(GAMMA_FACTOR));\n}\n"};a.PrismMaterial=uf,a.loadEnvPreset=Cf,a.IblCubemapShader=Df,a.VERSION="0.0.8",a.BackgroundShader=rb,a.BasicShader=ac,a.BlendShader=cc,a.CelShader=dc,a.CopyShader=ec,a.FXAAShader=fc,a.SAOBlurShader=gc,a.SAOShader=hc,a.NormalsShader=ic,a.EdgeShader=jc,a.LineShader=kc,a.OcclusionShader=lc,a.ShaderPass=qc,a.GaussianPass=sc,a.GroundReflection=Xc,a.WebGLShader=Yc,a.PhongShader=Zc,a.VertexEnumerator=id,a.DeriveTopology=td,a.VBIntersector=vd,a.GeometryList=z,a.RenderBatch=C,a.InstanceBufferBuilder=Ia,a.WebGLRenderer=xe,a.ModelIteratorLinear=Oa,a.ConsolidationIterator=Va,a.ModelIteratorBVH=Wa,a.BufferGeometryUtils=Ed,a.RenderScene=Xa,a.SortedList=Be,a.RenderModel=cb,a.MaterialConverter=Td,a.MaterialManager=Wd,a.consolidateFragmentList=Ua,a.copyVertexFormat=xa,a.copyPrimitiveProps=ya,a.mergeGeometries=Ba,a.Consolidation=Da,a.ConsolidationBuilder=Ea,a.registerWorkerSupport=Ga,a.multithreadingSupported=Ha,a.ConsolidationUtils=ae,a.isIOSDevice=uc,a.isAndroidDevice=vc,a.isMobileDevice=wc,a.isSafari=xc,a.isFirefox=yc,a.isMac=zc,a.isWindows=Ac,a.isNodeJS=Bc,a.rescueFromPolymer=Cc,a.pathToURL=Dc,a.clearAssets=Ec,a.MODEL_ROOT_LOADED_EVENT="svfLoaded",a.LOAD_MISSING_GEOMETRY="loadMissingGeometry",a.FRAGMENTS_LOADED_EVENT="fragmentLoaded",a.FILE_LOAD_STARTED="fileLoadStarted",a.GEOMETRY_DOWNLOAD_COMPLETE="geometryDownloadComplete",a.OBJECT_TREE_CREATED_EVENT="propertyDbLoaded",a.OBJECT_TREE_UNAVAILABLE_EVENT="propertyDbUnavailable",a.setMemoryOptimizedLoading=Fc,a.GPU_MEMORY_LIMIT=Gc,a.GPU_OBJECT_LIMIT=Hc,a.GEOMETRY_OVERHEAD=464,a.PIXEL_CULLING_THRESHOLD=Ic,a.PAGEOUT_SUCCESS=0,a.PAGEOUT_FAIL=Jc,a.PAGEOUT_NONE=Kc,a.RENDER_NORMAL=Lc,a.RENDER_HIGHLIGHTED=1,a.RENDER_HIDDEN=2,a.RENDER_SHADOWMAP=3,a.RENDER_FINISHED=4,a.GROUND_UNFINISHED=0,a.GROUND_FINISHED=1,a.GROUND_RENDERED=2,a.MESH_VISIBLE=Mc,a.MESH_HIGHLIGHTED=Nc,a.MESH_HIDE=Oc,a.MESH_ISLINE=8,a.MESH_MOVED=Pc,a.MESH_TRAVERSED=Qc,a.MESH_DRAWN=Rc,a.MESH_RENDERFLAG=Sc,a.MESH_ISPOINT=256,a.MESH_ISWIDELINE=512,a.DB_ID=0,a.FRAGMENT_ID=1,a.RESET_NORMAL=Tc,a.RESET_REDRAW=Uc,a.RESET_RELOAD=Vc,a.CutPlanesUniforms=sb,a.IdUniforms=tb,a.ThemingUniform=ub,a.ShadowMapCommonUniforms=vb,a.ShadowMapUniforms=wb,a.PointSizeUniforms=xb,a.WideLinesUniforms=yb,a.DepthTextureUniforms=zb,a.GetPrismMapSampleChunk=f,a.GetPrismMapUniformChunk=h,a.resolve=Eb,a.PackDepthShaderChunk=Fb,a.TonemapShaderChunk=Gb,a.OrderedDitheringShaderChunk=Hb,a.CutPlanesShaderChunk=Ib,a.PackNormalsShaderChunk=Jb,a.HatchPatternShaderChunk=Kb,a.EnvSamplingShaderChunk=Lb,a.IdVertexDeclaration=Mb,a.IdVertexShaderChunk=Nb,a.IdFragmentDeclaration=Ob,a.IdOutputShaderChunk=Pb,a.FinalOutputShaderChunk=Qb,
a.ThemingFragmentDeclaration=Rb,a.ThemingFragmentShaderChunk=Sb,a.InstancingVertexDeclaration=Tb,a.ShadowMapDeclareCommonUniforms=Ub,a.ShadowMapVertexDeclaration=Vb,a.ShadowMapVertexShaderChunk=Wb,a.ShadowMapFragmentDeclaration=Xb,a.AverageOfFloat3=Yb,a.PointSizeDeclaration=Zb,a.PointSizeShaderChunk=$b,a.ShaderChunks=_b,a.SAOMinifyFirstShader=He,a.SAOMinifyShader=Ie,a.LineStyleDefs=Jd,a.CreateLinePatternTexture=Kd,a.LineStyleDef=Ld,a.FloatToHalf=Ne,a.HalfToFloat=Oe,a.HALF_INT_MAX=59390,a.IntToHalf=Pe,a.HalfToInt=Qe,a.HalfTest=Re,a.HalfFloat=Se,a.createShaderMaterial=mc,a.setMacro=nc,a.removeMacro=oc,a.ShaderUtils=pc,a.createGroundShape=Ja,a.setGroundShapeTransform=le,a.GroundShadow=me,a.GroundShadowUtils=ne,a.PrismMaps=de,a.GetPrismMapChunk=ee,a.WebGLProgram=fe,a.WebGLProgramUtils=ge,a.GetPrismMapUniforms=V,a.PrismShader=Md,a.createPrismMaterial=Nd,a.clonePrismMaterial=Od,a.PrismShaderUtils=Pd,a.ShadowMapShader=oe,a.GroundShadowShader=pe,a.ShadowMapOverrideMaterials=qe,a.ShadowConfig=re,a.SHADOWMAP_NEEDS_UPDATE=se,a.SHADOWMAP_INCOMPLETE=te,a.SHADOWMAP_VALID=ue,a.ShadowMaps=La,a.ShadowRender=Ma,a.ShadowMapUtils=we,a.FrustumIntersector=A,a.OUTSIDE=0,a.INTERSECTS=1,a.CONTAINS=2,a.CONTAINMENT_UNKNOWN=-1,a.FragmentList=Ya,a.FragmentPointer=ab,a.FragmentListUtils=De,a.TileCoords=db,a.tile2Index=Te,a.index2Tile=Ue,a.TileUtils=Ve,a.TexQuadConfig=gb,a.ModelIteratorTexQuad=hb,a.ModelIteratorTexQuadUtils=af,a.SelectionMode=bf,a.InstanceTree=ib,a.DbidFragmentMap=jb,a.InstanceTreeStorage=kb,a.InstanceTreeAccess=mb,a.NodeArray=nb,a.BVHModule=nf,a.BVHBuilder=pb,a.setLogger=X,Object.defineProperty(a,"__esModule",{value:!0})})}).call(b,function(){return this}())},function(a,b){a.exports=THREE}]);"undefined"!=typeof module&&module.exports&&(module.exports=WGS);